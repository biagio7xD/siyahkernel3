diff -r update5/arch/arm/configs/q1_defconfig update6/arch/arm/configs/q1_defconfig
1274a1275
> CONFIG_WLAN_COUNTRY_CODE=y
diff -r update5/arch/arm/configs/u1_defconfig update6/arch/arm/configs/u1_defconfig
107c107
< CONFIG_PANIC_TIMEOUT=0
---
> CONFIG_PANIC_TIMEOUT=1
1285a1286
> CONFIG_WLAN_COUNTRY_CODE=y
1341c1342
< CONFIG_INPUT_MOUSEDEV=y
---
> # CONFIG_INPUT_MOUSEDEV is not set
diff -r update5/arch/arm/mach-exynos/cpufreq-4210.c update6/arch/arm/mach-exynos/cpufreq-4210.c
17a18
> #include <linux/regulator/consumer.h>
39a41
> static struct regulator *arm_regulator;
249a252,256
> static void exynos4210_set_arm_volt(unsigned int arm_volt)
> {
> 	regulator_set_voltage(arm_regulator, arm_volt, arm_volt + 25000);
> }
> 
422a430
> 	info->set_volt = exynos4210_set_arm_volt;
425a434,439
> 
> 	arm_regulator = regulator_get(NULL, "vdd_arm");
> 	if (IS_ERR(arm_regulator)) {
> 		printk(KERN_ERR "failed to get resource %s\n", "vdd_arm");
> 		goto err_mout_apll;
> 	}
diff -r update5/arch/arm/mach-exynos/cpufreq.c update6/arch/arm/mach-exynos/cpufreq.c
19d18
< #include <linux/regulator/consumer.h>
121c120
< 	if (index < g_cpufreq_limit_level)
---
> 	if (!exynos_cpufreq_lock_disable && (index < g_cpufreq_limit_level))
142,143c141
< 		regulator_set_voltage(arm_regulator, arm_volt,
< 				     arm_volt + 25000);
---
> 		exynos_info->set_volt(arm_volt);
147,148c145
< 		regulator_set_voltage(arm_regulator, safe_arm_volt,
< 				     safe_arm_volt + 25000);
---
> 		exynos_info->set_volt(safe_arm_volt);
158,159c155
< 		regulator_set_voltage(arm_regulator, arm_volt,
< 				     arm_volt + 25000);
---
> 		exynos_info->set_volt(arm_volt);
212a209,215
> 	if (cpufreq_level < exynos_info->max_support_idx
> 			|| cpufreq_level > exynos_info->min_support_idx) {
> 		pr_warn("%s: invalid cpufreq_level(%d:%d)\n", __func__, nId,
> 				cpufreq_level);
> 		return -EINVAL;
> 	}
> 
219a223
> 	mutex_lock(&set_cpu_freq_lock);
222a227
> 		mutex_unlock(&set_cpu_freq_lock);
226,230d230
< 	volt_table = exynos_info->volt_table;
< 	policy = cpufreq_cpu_get(0);
< 	freq_table = exynos_info->freq_table;
< 
< 	mutex_lock(&set_cpu_freq_lock);
278,279c278
< 			regulator_set_voltage(arm_regulator, safe_arm_volt,
< 					     safe_arm_volt + 25000);
---
> 			exynos_info->set_volt(safe_arm_volt);
282,283c281
< 		regulator_set_voltage(arm_regulator, arm_volt,
< 				     arm_volt + 25000);
---
> 		exynos_info->set_volt(arm_volt);
330a329,340
> 	if (exynos_cpufreq_disable) {
> 		pr_info("CPUFreq is already fixed\n");
> 		return -EPERM;
> 	}
> 
> 	if (cpufreq_level < exynos_info->max_support_idx
> 			|| cpufreq_level > exynos_info->min_support_idx) {
> 		pr_warn("%s: invalid cpufreq_level(%d:%d)\n", __func__, nId,
> 				cpufreq_level);
> 		return -EINVAL;
> 	}
> 
337a348
> 	mutex_lock(&set_cpu_freq_lock);
339a351
> 		mutex_unlock(&set_cpu_freq_lock);
343,347d354
< 	volt_table = exynos_info->volt_table;
< 	policy = cpufreq_cpu_get(0);
< 	freq_table = exynos_info->freq_table;
< 
< 	mutex_lock(&set_cpu_freq_lock);
385,386c392
< 			regulator_set_voltage(arm_regulator, safe_arm_volt,
< 					     safe_arm_volt + 25000);
---
> 			exynos_info->set_volt(safe_arm_volt);
389c395
< 		regulator_set_voltage(arm_regulator, arm_volt, arm_volt + 25000);
---
> 		exynos_info->set_volt(arm_volt);
431a438,458
> static void exynos_save_gov_freq(void)
> {
> 	unsigned int cpu = 0;
> 
> 	exynos_info->gov_support_freq = exynos_getspeed(cpu);
> 	pr_debug("cur_freq[%d] saved to freq[%d]\n", exynos_getspeed(0),
> 			exynos_info->gov_support_freq);
> }
> 
> static void exynos_restore_gov_freq(struct cpufreq_policy *policy)
> {
> 	unsigned int cpu = 0;
> 
> 	if (exynos_getspeed(cpu) != exynos_info->gov_support_freq)
> 		exynos_target(policy, exynos_info->gov_support_freq,
> 				CPUFREQ_RELATION_H);
> 
> 	pr_debug("freq[%d] restored to cur_freq[%d]\n",
> 			exynos_info->gov_support_freq, exynos_getspeed(cpu));
> }
> 
436,439c463,464
< 	unsigned int safe_arm_volt, arm_volt;
< 	unsigned int *volt_table;
< 
< 	volt_table = exynos_info->volt_table;
---
> 	unsigned int cpu = 0;
> 	struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
442a468,473
> 		/* If current governor is userspace or performance or powersave,
> 		 * save the current cpufreq before sleep.
> 		 */
> 		if (exynos_cpufreq_lock_disable)
> 			exynos_save_gov_freq();
> 
453d483
< 
465,483d494
< 		// In case of using performance governor,
< 		// max level should be used after sleep and wakeup
< 		if (exynos_cpufreq_lock_disable) {
< 			mutex_lock(&set_freq_lock);
< 
< 			/* get the voltage value */
< 			safe_arm_volt = exynos_get_safe_armvolt(exynos_info->pm_lock_idx, exynos_info->max_support_idx);
< 			if (safe_arm_volt)
< 				regulator_set_voltage(arm_regulator, safe_arm_volt,
< 					safe_arm_volt + 25000);
< 
< 			arm_volt = volt_table[exynos_info->max_support_idx];
< 			regulator_set_voltage(arm_regulator, arm_volt,
< 				arm_volt + 25000);
< 
< 			exynos_info->set_freq(exynos_info->pm_lock_idx, exynos_info->max_support_idx);
< 
< 			mutex_unlock(&set_freq_lock);
< 		}
484a496,500
> 		/* If current governor is userspace or performance or powersave,
> 		 * restore the saved cpufreq after waekup.
> 		 */
> 		if (exynos_cpufreq_lock_disable)
> 			exynos_restore_gov_freq(policy);
599c615
< 		goto err_vdd_arm;
---
> 		goto err_cpufreq_init;
604,610c620
< 		goto err_vdd_arm;
< 	}
< 
< 	arm_regulator = regulator_get(NULL, "vdd_arm");
< 	if (IS_ERR(arm_regulator)) {
< 		printk(KERN_ERR "failed to get resource %s\n", "vdd_arm");
< 		goto err_vdd_arm;
---
> 		goto err_cpufreq_init;
640,642c650
< 	if (!IS_ERR(arm_regulator))
< 		regulator_put(arm_regulator);
< err_vdd_arm:
---
> err_cpufreq_init:
diff -r update5/arch/arm/mach-exynos/cpuidle-exynos4.c update6/arch/arm/mach-exynos/cpuidle-exynos4.c
36a37,39
> #ifdef CONFIG_SEC_WATCHDOG_RESET
> #include <plat/regs-watchdog.h>
> #endif
378a382,386
> #ifdef CONFIG_SEC_WATCHDOG_RESET
> 	SAVE_ITEM(S3C2410_WTDAT),
> 	SAVE_ITEM(S3C2410_WTCNT),
> 	SAVE_ITEM(S3C2410_WTCON),
> #endif
384a393,397
> #ifdef CONFIG_SEC_WATCHDOG_RESET	
> 	SAVE_ITEM(S3C2410_WTDAT),
> 	SAVE_ITEM(S3C2410_WTCNT),
> 	SAVE_ITEM(S3C2410_WTCON),
> #endif
diff -r update5/arch/arm/mach-exynos/include/mach/cpufreq.h update6/arch/arm/mach-exynos/include/mach/cpufreq.h
70a71
> 	unsigned int	gov_support_freq;
74a76
> 	void (*set_volt)(unsigned int);
diff -r update5/arch/arm/mach-exynos/mach-u1.c update6/arch/arm/mach-exynos/mach-u1.c
2264c2264
< 		REGULATOR_CHANGE_STATUS, 1);
---
> 		REGULATOR_CHANGE_STATUS, 0);
2999c2999
< void sec_set_ldo1_constraints(int disabled)
---
> int sec_set_ldo1_constraints(int disabled)
3001,3005c3001,3019
< #if 0				/* later */
< 	/* VDD33_ADC */
< 	ldo1_init_data.constraints.state_mem.disabled = disabled;
< 	ldo1_init_data.constraints.state_mem.enabled = !disabled;
< #endif
---
> 
> 	struct regulator *regulator;
> 
> 	if (!disabled) {
> 		regulator = regulator_get(NULL, "vadc_3.3v");
> 		if (IS_ERR(regulator))
> 			return -1;
> 		regulator_enable(regulator);
> 		regulator_put(regulator);
> 	} else {
> 		regulator = regulator_get(NULL, "vadc_3.3v");
> 		if (IS_ERR(regulator))
> 			return -1;
> 		if (regulator_is_enabled(regulator))
> 			regulator_force_disable(regulator);
> 		regulator_put(regulator);
> 	}
> 
> 	return 0;
3011c3025
< 	.set_adc_power_contraints = sec_set_ldo1_constraints,
---
> 	.set_adc_power_constraints = sec_set_ldo1_constraints,
diff -r update5/arch/arm/mach-exynos/platsmp.c update6/arch/arm/mach-exynos/platsmp.c
35a36,38
> #ifdef CONFIG_SEC_WATCHDOG_RESET
> #include <plat/regs-watchdog.h>
> #endif
147a151,153
> #ifdef CONFIG_SEC_WATCHDOG_RESET
> 	unsigned int tmp_wtcon;
> #endif
154a161,164
> #ifdef CONFIG_SEC_WATCHDOG_RESET
> 	tmp_wtcon = __raw_readl(S3C2410_WTCON);
> #endif
> 
203a214,217
> 
> #ifdef CONFIG_SEC_WATCHDOG_RESET
> 	__raw_writel(tmp_wtcon, S3C2410_WTCON);
> #endif
diff -r update5/arch/arm/mach-exynos/sec_watchdog.c update6/arch/arm/mach-exynos/sec_watchdog.c
138,149d137
< #if defined(PET_BY_WORKQUEUE)
< static int __devinit watchdog_cpu_callback(struct notifier_block *nfb,
< 					   unsigned long action, void *hcpu)
< {
< 	switch (action) {
< 	case CPU_ONLINE:
< 		watchdog_start();
< 	}
< 	return NOTIFY_OK;
< }
< #endif
< 
169d156
< 	hotcpu_notifier(watchdog_cpu_callback, 0);
diff -r update5/arch/arm/mach-exynos/u1-wlan.c update6/arch/arm/mach-exynos/u1-wlan.c
16a17,18
> #define WLAN_STATIC_SCAN_BUF0		5
> #define WLAN_STATIC_SCAN_BUF1		6
46a49,50
> void *wlan_static_scan_buf0;
> void *wlan_static_scan_buf1;
51c55,58
< 
---
> 	if (section == WLAN_STATIC_SCAN_BUF0)
> 		return wlan_static_scan_buf0;	
> 	if (section == WLAN_STATIC_SCAN_BUF1)
> 		return wlan_static_scan_buf1;	
89c96,103
< 	printk(KERN_INFO"%s: WIFI MEM Allocated\n", __func__);
---
> 	wlan_static_scan_buf0 = kmalloc (65536, GFP_KERNEL);
> 	if(!wlan_static_scan_buf0)		
> 		goto err_mem_alloc;
> 	wlan_static_scan_buf1 = kmalloc (65536, GFP_KERNEL);
> 	if(!wlan_static_scan_buf1)		
> 		goto err_mem_alloc;
> 
> 	printk("%s: WIFI MEM Allocated\n", __FUNCTION__);
diff -r update5/drivers/media/video/samsung/tvout/hw_if/hdcp.c update6/drivers/media/video/samsung/tvout/hw_if/hdcp.c
160,161c160,162
< 		if (!s5p_hdmi_reg_get_hpd_status() ||
< 		    s5p_hdmi_ctrl_status() == false || on_stop_process)
---
> 		if (s5p_hdmi_ctrl_status() == false ||
> 		    !s5p_hdmi_reg_get_hpd_status() ||
> 		    on_stop_process)
200,201c201,203
< 		if (!s5p_hdmi_reg_get_hpd_status() ||
< 		    s5p_hdmi_ctrl_status() == false || on_stop_process)
---
> 		if (s5p_hdmi_ctrl_status() == false ||
> 		    !s5p_hdmi_reg_get_hpd_status() ||
> 		    on_stop_process)
diff -r update5/drivers/media/video/samsung/tvout/hw_if/hw_if.h update6/drivers/media/video/samsung/tvout/hw_if/hw_if.h
397c397
< extern int hdmi_audio_ext;
---
> extern bool hdmi_audio_ext;
diff -r update5/drivers/media/video/samsung/tvout/mhl/sii9234.c update6/drivers/media/video/samsung/tvout/mhl/sii9234.c
42a43,44
> #include <linux/wakelock.h>
> #include <linux/list.h>
63a66,73
> #ifdef CONFIG_SAMSUNG_MHL_9290
> #include <linux/30pin_con.h>
> #endif
> 
> #ifdef CONFIG_SAMSUNG_SMARTDOCK
> #define ADC_SMARTDOCK	0x10 /* 40.2K ohm */
> #endif
> 
78a89
> #define T_SRC_CBUS_FLOAT		50
81a93,96
> #define T_HPD_WIDTH			110
> #define T_SRC_RXSENSE_DEGLITCH		110
> #define T_SRC_CBUS_DEGLITCH		2
> #define T_TPKT_SENDER_TIMEOUT		100
89,94d103
< #define T_SRC_CBUS_FLOAT		50
< #define T_HPD_WIDTH			110
< #define T_SRC_RXSENSE_DEGLITCH		110
< #define T_SRC_CBUS_DEGLITCH		2
< #define T_TPKT_SENDER_TIMEOUT		100
< 
107a117
> 
108a119,124
> #define   INTR_POLARITY		(1 << 1)
> #define   INTR_OPEN_DRAIN	(1 << 2)
> #define   HPD_OUT_OVR_EN	(1 << 4)
> #define   HPD_OUT_OVR_VAL	(1 << 5)
> #define   HPD_OUT_OPEN_DRAIN	(1 << 6)
> 
116,118d131
< /* There doesn't seem to be any documentation for CTRL5 but it looks like
<  * it is some sort of pull up control register
<  */
159,161c172
< /* CBUS_INT_1_ENABLE: CBUS Transaction Interrupt #1 Mask */
< #define CBUS_INTR1_ENABLE_REG		0x09
< #define CBUS_INTR2_ENABLE_REG		0x1F
---
> #define CBUS_CONFIG_REG			0x07
163d173
< /* CBUS Interrupt Status Registers*/
164a175,191
> #define CBUS_INT_1_MASK			0x09
> 
> #define START_MSC_RESERVED		(1<<0)
> #define START_MSC_MSG			(1<<1)
> #define START_READ_DEVCAP		(1<<2)
> #define START_WRITE_STAT_INT		(1<<3)
> #define START_WRITE_BURST		(1<<4)
> 
> #define CBUS_MSC_RAP_CONTENT_ON		0x10
> #define CBUS_MSC_RAP_CONTENT_OFF	0x11
> #define CBUS_MSC_COMMAND_START		0x12
> #define CBUS_MSC_OFFSET_REG		0x13
> #define CBUS_MSC_FIRST_DATA_OUT		0x14
> #define CBUS_MSC_SECOND_DATA_OUT	0x15
> #define CBUS_MSC_FIRST_DATA_IN		0x16
> #define CBUS_MSC_MSG_CMD_IN		0x18
> #define CBUS_MSC_MSG_DATA_IN		0x19
165a193,211
> #define CBUS_INT_2_MASK			0x1F
> #define CBUS_LINK_CONTROL_2_REG		0x31
> 
> /* MHL Interrupt Registers */
> #define CBUS_MHL_INTR_REG_0		0xA0
> 
> #define CBUS_MHL_INTR_REG_1		0xA1
> #define   MHL_INT_EDID_CHG	(1<<1)
> 
> #define CBUS_MHL_INTR_REG_2		0xA2
> #define CBUS_MHL_INTR_REG_3		0xA3
> 
> /* MHL Status Registers */
> #define CBUS_MHL_STATUS_REG_0		0xB0
> #define   MHL_STATUS_DCAP_READY	(1<<0)
> 
> #define CBUS_MHL_STATUS_REG_1		0xB1
> #define CBUS_MHL_STATUS_REG_2		0xB2
> #define CBUS_MHL_STATUS_REG_3		0xB3
191,200c237,244
< #define CBUS_INTR_STATUS_1_ENABLE_MASK\
< 			(MSC_RESP_ABORT_MASK |\
< 			MSC_REQ_ABORT_MASK |\
< 			MSC_REQ_DONE_MASK |\
< 			MSC_MSG_RECD_MASK |\
< 			CBUS_DDC_ABORT_MASK)
< 
< #define CBUS_INTR_STATUS_2_ENABLE_MASK\
< 			(WRT_STAT_RECD_MASK |\
< 			SET_INT_RECD_MASK)
---
> #define CBUS_INTR_STATUS_1_ENABLE_MASK (MSC_RESP_ABORT_MASK |\
> 					MSC_REQ_ABORT_MASK |\
> 					MSC_REQ_DONE_MASK |\
> 					MSC_MSG_RECD_MASK |\
> 					CBUS_DDC_ABORT_MASK)
> 
> #define CBUS_INTR_STATUS_2_ENABLE_MASK (WRT_STAT_RECD_MASK |\
> 					SET_INT_RECD_MASK)
215d258
< /* reason for MSC_REQ_ABORT interrupt on CBUS */
216a260
> 
219c263
< /* MSC Requestor Abort Reason Register bits*/
---
> /* MSC Requestor/Responder Abort Reason Register bits*/
277,288d320
< /* MHL Interrupt Registers */
< #define CBUS_MHL_INTR_REG_0		0xA0
< #define CBUS_MHL_INTR_REG_1		0xA1
< #define CBUS_MHL_INTR_REG_2		0xA2
< #define CBUS_MHL_INTR_REG_3		0xA3
< 
< /* MHL Status Registers */
< #define CBUS_MHL_STATUS_REG_0		0xB0
< #define CBUS_MHL_STATUS_REG_1		0xB1
< #define CBUS_MHL_STATUS_REG_2		0xB2
< #define CBUS_MHL_STATUS_REG_3		0xB3
< 
322,324d353
< #define CBUS_CONFIG_REG			0x07
< #define CBUS_LINK_CONTROL_2_REG		0x31
< 
339,377d367
< /* MHL SideBand Channel(MSC) Registers */
< #define CBUS_MSC_COMMAND_START_REG	0x12
< #define CBUS_MSC_OFFSET_REG		0x13
< #define CBUS_MSC_FIRST_DATA_OUT_REG	0x14
< #define CBUS_MSC_SECOND_DATA_OUT_REG	0x15
< #define CBUS_MSC_FIRST_DATA_IN_REG	0x16
< #define CBUS_MSC_SECOND_DATA_IN_REG	0x17
< #define CBUS_MSC_MSG_CMD_IN_REG		0x18
< #define CBUS_MSC_MSG_DATA_IN_REG	0x19
< #define CBUS_MSC_WRITE_BURST_LEN	0x20
< /*Turn content streaming ON.*/
< #define CBUS_MSC_RAP_CONTENT_ON		0x10
< /*Turn content streaming OFF.*/
< #define CBUS_MSC_RAP_CONTENT_OFF	0x11
< /*Register Bits for CBUS_MSC_COMMAND_START_REG */
< #define START_BIT_MSC_RESERVED		(1<<0)
< #define START_BIT_MSC_MSG		(1<<1)
< #define START_BIT_READ_DEVCAP		(1<<2)
< #define START_BIT_WRITE_STAT_INT	(1<<3)
< #define START_BIT_WRITE_BURST		(1<<4)
< 
< /* MHL Device Capability Register offsets */
< #define DEVCAP_DEV_STATE		0x00
< #define DEVCAP_MHL_VERSION		0x01
< #define DEVCAP_DEV_CAT			0x02
< #define DEVCAP_ADOPTER_ID_H		0x03
< #define DEVCAP_ADOPTER_ID_L		0x04
< #define DEVCAP_VID_LINK_MODE		0x05
< #define DEVCAP_AUD_LINK_MODE		0x06
< #define DEVCAP_VIDEO_TYPE		0x07
< #define DEVCAP_LOG_DEV_MAP		0x08
< #define DEVCAP_BANDWIDTH		0x09
< #define DEVCAP_DEV_FEATURE_FLAG		0x0A
< #define DEVCAP_DEVICE_ID_H		0x0B
< #define DEVCAP_DEVICE_ID_L		0x0C
< #define DEVCAP_SCRATCHPAD_SIZE		0x0D
< #define DEVCAP_INT_STAT_SIZE		0x0E
< #define DEVCAP_RESERVED			0x0F
< 
380,382d369
< /* Device Capability Ready Bit */
< #define MHL_STATUS_DCAP_READY		(1<<0)
< 
395c382
< #define CBUS_PKT_BUF_COUNT		18
---
> #define MSC_MAX_QUEUE			16
400a388,390
> #define MHL_DEVCAP_DEV_CAT			0x02
> #define MHL_DEVCAP_FEATURE_FLAG		0x0A
> 
433c423
< 	CBUS_IDLE =	0x00,
---
> 	CBUS_IDLE =		0x00,
435,437c425,428
< 	CBUS_NACK =		0x35,
< 	CBUS_WRITE_STAT  =	0x60 | 0x80,
< 	CBUS_SET_INT     =	0x60,
---
> 	CBUS_NACK =		0x34,
> 	CBUS_ABORT =		0x35,
> 	CBUS_WRITE_STAT =	0x60 | 0x80,
> 	CBUS_SET_INT =		0x60,
453,479d443
< enum mhl_status_type {
< 	NO_MHL_STATUS = 0x00,
< 	MHL_INIT_DONE,
< 	MHL_WAITING_RGND_DETECT,
< 	MHL_CABLE_CONNECT,
< 	MHL_DISCOVERY_START,
< 	MHL_DISCOVERY_END,
< 	MHL_DISCOVERY_SUCCESS,
< 	MHL_DISCOVERY_FAIL,
< 	MHL_RSEN_GLITCH,
< 	MHL_RSEN_LOW,
< };
< 
< struct mhl_tx_status_type {
< 	u8 intr4_mask_value;
< 	u8 intr1_mask_value;
< 	u8 intr_cbus1_mask_value;
< 	u8 intr_cbus2_mask_value;
< 	enum mhl_status_type	mhl_status;
< 	u8 linkmode;
< 	u8 connected_ready;
< 	bool cbus_connected;
< 	bool sink_hpd;
< 	bool rgnd_1k;
< 	u8 rsen_check_available;
< };
< 
482a447
> static struct workqueue_struct *sii9234_msc_wq;
489,495d453
< /* Structure for holding MSC command data */
< struct cbus_packet {
< 	enum cbus_command command;
< 	u8 offset;
< 	u8 data[2];
< 	u8 status;
< };
497,512c455,460
< struct device_cap {
< 	u8 mhl_ver;
< 	u8 dev_type;
< 	u16 adopter_id;
< 	u8 vid_link_mode;
< 	u8 aud_link_mode;
< 	u8 video_type;
< 	u8 log_dev_map;
< 	u8 bandwidth;
< 	u16 device_id;
< 	u8 scratchpad_size;
< 	u8 int_stat_size;
< 
< 	bool rcp_support;
< 	bool rap_support;
< 	bool sp_support;
---
> struct msc_packet {
> 	enum cbus_command	command;
> 	u8	offset;
> 	u8	data_1;
> 	u8	data_2;
> 	struct list_head p_msc_packet_list;
514a463,465
> LIST_HEAD(g_msc_packet_list);
> static int g_list_cnt;
> 
519c470,472
< 
---
> #ifdef CONFIG_SAMSUNG_MHL_9290
> 	struct notifier_block           acc_con_nb;
> #endif
525c478,480
< 
---
> #ifdef CONFIG_MACH_MIDAS
> 	struct wake_lock		wlock;
> #endif
527,533c482,488
< 	struct mutex			cbus_lock;
< 	struct cbus_packet		cbus_pkt;
< 	struct cbus_packet		cbus_pkt_buf[CBUS_PKT_BUF_COUNT];
< 	struct device_cap		devcap;
< 	struct mhl_tx_status_type	mhl_status_value;
< #ifdef CONFIG_SII9234_RCP
< 	u8 error_key;
---
> 
> 	bool				msc_dcap_read_ready;
> 	struct mutex			msc_lock;
> 	struct completion		msc_complete;
> 	struct work_struct		msc_work;
> 	u8				devcap[16];
> 	u8				link_mode;
535d489
< #endif
538,545c492,493
< static u8 sii9234_tmds_control(struct sii9234_data *sii9234, bool enable);
< static void __sii9234_power_down(struct sii9234_data *sii9234);
< 
< #ifdef CONFIG_SII9234_CBUS
< static bool cbus_command_request(struct sii9234_data *sii9234,
< 				 enum cbus_command command,
< 				 u8 offset, u8 data);
< static void cbus_command_response(struct sii9234_data *sii9234);
---
> #ifdef CONFIG_SAMSUNG_MHL_9290
> static int sii9234_30pin_init_for_9290(struct sii9234_data *sii9234);
547a496,500
> static int sii9234_tmds_control(struct sii9234_data *sii9234, bool enable);
> static void __sii9234_power_down(struct sii9234_data *sii9234);
> static int sii9234_enqueue_msc_work(struct sii9234_data *sii9234, u8 command,
> 		u8 offset, u8 data_1, u8 data_2);
> 
548a502
> #if !defined(CONFIG_MACH_P4NOTEPQ_BD)
551c505,510
< 	return	max77693_muic_get_status1_adc1k_value();
---
> #ifdef CONFIG_SAMSUNG_SMARTDOCK
> 	if (max77693_muic_get_status1_adc_value() == ADC_SMARTDOCK)
> 		return 1;
> 	else
> #endif
> 		return max77693_muic_get_status1_adc1k_value();
553a513
> #endif
560c520
< 		printk(KERN_ERR	"[ERR] %s() getting resource is failed\n",
---
> 		printk(KERN_ERR	"[ERROR]sii9234: %s() getting resource is failed\n",
567c527
< 		pr_info("%s() mhl already %s\n",
---
> 		pr_info("sii9234: %s() mhl already %s\n",
572c532
< 		pr_info("%s(%s)\n", __func__, onoff ? "on" : "off");
---
> 		pr_info("sii9234: %s(%s)\n", __func__, onoff ? "on" : "off");
598c558
< 			printk(KERN_ERR	"[ERROR] %s() hw_onoff is NULL\n",
---
> 			printk(KERN_ERR	"[ERROR]sii9234: %s() hw_onoff is NULL\n",
601a562
> #if !defined(CONFIG_MACH_P4NOTEPQ_BD)
602a564
> #endif
604c566
< 			pr_info("%s() mhl still inserted, retry discovery\n",
---
> 			pr_info("sii9234: %s() mhl still inserted, retry discovery\n",
609c571,572
< 			pr_info("%s() mhl cable is removed\n", __func__);
---
> 			pr_info("sii9234: %s() mhl cable is removed\n",
> 					__func__);
632c595
< 		printk(KERN_ERR "[ERROR] %s():%d failed !\n", __func__,
---
> 		printk(KERN_ERR "[ERROR]sii9234: %s():%d failed !\n", __func__,
648c611
< 		printk(KERN_ERR "[ERROR] %s():%d failed !\n", __func__,
---
> 		printk(KERN_ERR "[ERROR]sii9234: %s():%d failed !\n", __func__,
654c617
< 		printk(KERN_ERR "[ERROR] %s():%d failed !\n", __func__,
---
> 		printk(KERN_ERR "[ERROR]sii9234: %s():%d failed !\n", __func__,
671c634
< 		printk(KERN_ERR "[ERROR] %s():%d failed !\n", __func__,
---
> 		printk(KERN_ERR "[ERROR]sii9234: %s():%d failed !\n", __func__,
679c642
< 		printk(KERN_ERR "[ERROR] %s():%d failed !\n", __func__,
---
> 		printk(KERN_ERR "[ERROR]sii9234: %s():%d failed !\n", __func__,
694c657
< 		printk(KERN_ERR "[ERROR] %s():%d failed !\n", __func__,
---
> 		printk(KERN_ERR "[ERROR]sii9234: %s():%d failed !\n", __func__,
702c665
< 		printk(KERN_ERR "[ERROR] %s():%d failed !\n", __func__,
---
> 		printk(KERN_ERR "[ERROR]sii9234: %s():%d failed !\n", __func__,
716c679
< 		printk(KERN_ERR "[ERROR] %s():%d failed !\n", __func__,
---
> 		printk(KERN_ERR "[ERROR]sii9234: %s():%d failed !\n", __func__,
728c691
< 		printk(KERN_ERR "[ERROR] %s():%d failed !\n", __func__,
---
> 		printk(KERN_ERR "[ERROR]sii9234: %s():%d failed !\n", __func__,
735c698
< 		printk(KERN_ERR "[ERROR] %s():%d failed !\n", __func__,
---
> 		printk(KERN_ERR "[ERROR]sii9234: %s():%d failed !\n", __func__,
741c704
< 		printk(KERN_ERR "[ERROR] %s():%d failed !\n", __func__,
---
> 		printk(KERN_ERR "[ERROR]sii9234: %s():%d failed !\n", __func__,
757c720
< 		printk(KERN_ERR "[ERROR] %s():%d failed !\n", __func__,
---
> 		printk(KERN_ERR "[ERROR]sii9234: %s():%d failed !\n", __func__,
769c732
< 		printk(KERN_ERR "[ERROR] %s():%d failed !\n", __func__,
---
> 		printk(KERN_ERR "[ERROR]sii9234: %s():%d failed !\n", __func__,
775c738
< 		printk(KERN_ERR "[ERROR] %s():%d failed !\n", __func__,
---
> 		printk(KERN_ERR "[ERROR]sii9234: %s():%d failed !\n", __func__,
781c744
< 		printk(KERN_ERR "[ERROR] %s():%d failed !\n", __func__,
---
> 		printk(KERN_ERR "[ERROR]sii9234: %s():%d failed !\n", __func__,
797c760
< 		printk(KERN_ERR "[ERROR] %s():%d failed !\n", __func__,
---
> 		printk(KERN_ERR "[ERROR]sii9234: %s():%d failed !\n", __func__,
809c772
< 		printk(KERN_ERR "[ERROR] %s():%d failed !\n", __func__,
---
> 		printk(KERN_ERR "[ERROR]sii9234: %s():%d failed !\n", __func__,
815c778
< 		printk(KERN_ERR "[ERROR] %s():%d failed !\n", __func__,
---
> 		printk(KERN_ERR "[ERROR]sii9234: %s():%d failed !\n", __func__,
821c784
< 		printk(KERN_ERR "[ERROR] %s():%d failed !\n", __func__,
---
> 		printk(KERN_ERR "[ERROR]sii9234: %s():%d failed !\n", __func__,
838c801
< 		printk(KERN_ERR "[ERROR] %s():%d failed !\n", __func__,
---
> 		printk(KERN_ERR "[ERROR]sii9234: %s():%d failed !\n", __func__,
846c809
< 		printk(KERN_ERR "[ERROR] %s():%d failed !\n", __func__,
---
> 		printk(KERN_ERR "[ERROR]sii9234: %s():%d failed !\n", __func__,
863c826
< 		printk(KERN_ERR "[ERROR] %s():%d failed !\n", __func__,
---
> 		printk(KERN_ERR "[ERROR]sii9234: %s():%d failed !\n", __func__,
873c836
< 		printk(KERN_ERR "[ERROR] %s():%d failed !\n", __func__,
---
> 		printk(KERN_ERR "[ERROR]sii9234: %s():%d failed !\n", __func__,
890c853
< 		printk(KERN_ERR "[ERROR] %s():%d failed !\n", __func__,
---
> 		printk(KERN_ERR "[ERROR]sii9234: %s():%d failed !\n", __func__,
898c861
< 		printk(KERN_ERR "[ERROR] %s():%d failed !\n", __func__,
---
> 		printk(KERN_ERR "[ERROR]sii9234: %s():%d failed !\n", __func__,
906c869
< 		printk(KERN_ERR "[ERROR] %s():%d failed !\n", __func__,
---
> 		printk(KERN_ERR "[ERROR]sii9234: %s():%d failed !\n", __func__,
914c877
< 		printk(KERN_ERR "[ERROR] %s():%d failed !\n", __func__,
---
> 		printk(KERN_ERR "[ERROR]sii9234: %s():%d failed !\n", __func__,
944c907
< 	ret = cbus_write_reg(sii9234, CBUS_INTR1_ENABLE_REG, 0);
---
> 	ret = cbus_write_reg(sii9234, CBUS_INT_1_MASK, 0);
951c914
< 	ret = cbus_write_reg(sii9234, CBUS_INTR2_ENABLE_REG, 0);
---
> 	ret = cbus_write_reg(sii9234, CBUS_INT_2_MASK, 0);
966c929
< 	pr_debug("sii9234: cbus init\n");
---
> 	pr_debug("%s()\n", __func__);
990c953
< 	cbus_write_reg(sii9234, 0x85, 0x01);
---
> 	cbus_write_reg(sii9234, 0x85, 0x24);
993c956
< 	cbus_write_reg(sii9234, 0x88, (1<<1) | (1<<2) | (1<<3) | (1<<7));
---
> 	cbus_write_reg(sii9234, 0x88, 1<<7);
1022,1023c985,986
< 	cbus_write_reg(sii9234, CBUS_INTR1_ENABLE_REG, 0);
< 	cbus_write_reg(sii9234, CBUS_INTR2_ENABLE_REG, 0);
---
> 	cbus_write_reg(sii9234, CBUS_INT_1_MASK, 0);
> 	cbus_write_reg(sii9234, CBUS_INT_2_MASK, 0);
1029a993
> 	pr_debug("sii9234: %s() open usb_id\n", __func__);
1036,1037c1000,1001
< 	mhl_tx_set_reg(sii9234, MHL_TX_DISC_CTRL3_REG, 0x86);
< /*	mhl_tx_set_reg(sii9234, MHL_TX_DISC_CTRL3_REG, 0xA6); */
---
> /*	mhl_tx_set_reg(sii9234, MHL_TX_DISC_CTRL3_REG, 0x86);*/
> 	mhl_tx_set_reg(sii9234, MHL_TX_DISC_CTRL3_REG, 0xA6);
1039c1003,1004
< 	mhl_tx_clear_reg(sii9234, MHL_TX_INT_CTRL_REG, (1<<4) | (1<<5));
---
> 	mhl_tx_clear_reg(sii9234, MHL_TX_INT_CTRL_REG, (1<<5));
> 	mhl_tx_set_reg(sii9234, MHL_TX_INT_CTRL_REG, (1<<4));
1044c1009,1011
< 	msleep(T_SRC_CBUS_FLOAT);
---
> 	usleep_range(T_SRC_CBUS_FLOAT * USEC_PER_MSEC,
> 			T_SRC_CBUS_FLOAT * USEC_PER_MSEC);
> 	pr_debug("sii9234: %s() release usb_id\n", __func__);
1046a1014
> 
1056c1024
< 	pr_debug("sii9234: MSC Request Aborted:");
---
> 	pr_debug("sii9234: %s() MSC Request Aborted:", __func__);
1062,1072d1029
< 		if (abort_reason & BIT_MSC_XFR_ABORT) {
< 			cbus_read_reg(sii9234, MSC_REQ_ABORT_REASON_REG,
< 							&abort_reason);
< 			pr_cont("ABORT_REASON_REG = %d\n", abort_reason);
< 			cbus_write_reg(sii9234, MSC_REQ_ABORT_REASON_REG, 0xff);
< 		}
< 		if (abort_reason & BIT_MSC_ABORT) {
< 			cbus_read_reg(sii9234, BIT_MSC_ABORT, &abort_reason);
< 			pr_cont("BIT_MSC_ABORT = %d\n", abort_reason);
< 			cbus_write_reg(sii9234, BIT_MSC_ABORT, 0xff);
< 		}
1098c1055
< 	pr_debug("sii9234: MSC Response Aborted:");
---
> 	pr_debug("sii9234: %s() MSC Response Aborted:", __func__);
1123c1080,1081
< 		pr_debug("Applying DDC Abort Safety(SWA 18958)\n)");
---
> 		pr_debug("sii9234: %s() Applying DDC Abort Safety(SWA18958)\n",
> 				__func__);
1133c1091
< 	pr_debug("sii9234: DDC abort interrupt\n");
---
> 	pr_debug("sii9234: %s() DDC abort interrupt\n", __func__);
1139c1097
< static void rcp_uevent_report(struct sii9234_data *sii9234, u8 key)
---
> static void rcp_key_report(struct sii9234_data *sii9234, u8 key)
1141,1153c1099,1101
< #ifdef MHL_RCP_FRAMEWORK
< 	char tempkey[32];
< 	char *envp[] = { tempkey, NULL };
< 
< 	struct kobject *kobj = &sii9234->pdata->cbus_client->dev.kobj;
< 
< 	snprintf(tempkey, sizeof(tempkey),
< 			"MHL_RCP=%s", code[key].name);
< 	kobject_uevent_env(kobj, KOBJ_CHANGE, envp);
< #else
< 	pr_info("rcp_uevent_report key: %d\n", key);
< 	input_report_key(sii9234->input_dev, (unsigned int)key+1, 1);
< 	input_report_key(sii9234->input_dev, (unsigned int)key+1, 0);
---
> 	pr_debug("sii9234: %s(): report rcp key: %d\n", __func__, key);
> 	input_report_key(sii9234->input_dev, (unsigned int)key + 1, 1);
> 	input_report_key(sii9234->input_dev, (unsigned int)key + 1, 0);
1155d1102
< #endif
1159a1107,1108
> 	u8 offset, data_2 = 0;
> 
1162,1165c1111,1113
< 		rcp_uevent_report(sii9234, key);
< 		/* Send the RCP ack */
< 		cbus_command_request(sii9234, CBUS_MSC_MSG,
< 						MSG_RCPK, key);
---
> 		rcp_key_report(sii9234, key);
> 		offset = MSG_RCPK;
> 		key = MSG_RCPK;
1167d1114
< 		sii9234->error_key = key;
1175c1122,1123
< 		cbus_command_request(sii9234, CBUS_MSC_MSG, MSG_RCPE, 0x01);
---
> 		offset = MSG_RCPE;
> 		data_2 = 0x01;
1176a1125,1126
> 
> 	sii9234_enqueue_msc_work(sii9234, CBUS_MSC_MSG, offset, key, data_2);
1186c1136
< 	cbus_command_request(sii9234, CBUS_MSC_MSG, MSG_RAPK, 0x00);
---
> 	sii9234_enqueue_msc_work(sii9234, CBUS_MSC_MSG, MSG_RAPK, 0x0, 0x0);
1204d1153
< 	mutex_lock(&sii9234->cbus_lock);
1206,1207c1155
< 		pr_debug("sii9234: invalid MHL state\n");
< 		mutex_unlock(&sii9234->cbus_lock);
---
> 		pr_debug("sii9234: %s(): invalid MHL state\n", __func__);
1211,1212c1159,1160
< 	cbus_read_reg(sii9234, CBUS_MSC_MSG_CMD_IN_REG, &cmd_code);
< 	cbus_read_reg(sii9234, CBUS_MSC_MSG_DATA_IN_REG, &key);
---
> 	cbus_read_reg(sii9234, CBUS_MSC_MSG_CMD_IN, &cmd_code);
> 	cbus_read_reg(sii9234, CBUS_MSC_MSG_DATA_IN, &key);
1214c1162,1163
< 	pr_debug("sii9234: cmd_code:%d, key:%d\n", cmd_code, key);
---
> 	pr_debug("sii9234: %s(): cmd_code:%d, key:%d\n", __func__,
> 			cmd_code, key);
1218,1219c1167,1168
< 		pr_debug("sii9234: RCP Arrived. KEY CODE:%d\n", key);
< 		mutex_unlock(&sii9234->cbus_lock);
---
> 		pr_debug("sii9234: %s(): RCP Arrived. KEY CODE:%d\n",
> 				__func__, key);
1221c1170
< 		return;
---
> 		break;
1223,1224c1172
< 		pr_debug("sii9234: RAP Arrived\n");
< 		mutex_unlock(&sii9234->cbus_lock);
---
> 		pr_debug("sii9234: %s(): RAP Arrived\n", __func__);
1226c1174
< 		return;
---
> 		break;
1228c1176
< 		pr_debug("sii9234: RCPK Arrived\n");
---
> 		pr_debug("sii9234: %s(): RCPK Arrived\n", __func__);
1231c1179
< 		pr_debug("sii9234: RCPE Arrived\n");
---
> 		pr_debug("sii9234: %s(): RCPE Arrived\n", __func__);
1234c1182
< 		pr_debug("sii9234: RAPK Arrived\n");
---
> 		pr_debug("sii9234: %s(): RAPK Arrived\n", __func__);
1237,1240c1185,1188
< 		pr_debug("sii9234: MAC error\n");
< 		mutex_unlock(&sii9234->cbus_lock);
< 		cbus_command_request(sii9234, CBUS_GET_MSC_ERR_CODE, 0, 0);
< 		return;
---
> 		pr_debug("sii9234: %s(): MAC error\n", __func__);
> 		sii9234_enqueue_msc_work(sii9234, CBUS_GET_MSC_ERR_CODE,
> 								0x0, 0x0, 0x0);
> 		break;
1242d1189
< 	mutex_unlock(&sii9234->cbus_lock);
1248,1249c1195,1196
< 	pr_debug("sii9234: mhl_path_enable MHL_STATUS_PATH %s\n",
< 					path_en ? "ENABLED" : "DISABLED");
---
> 	pr_debug("sii9234: %s(): mhl_path_enable MHL_STATUS_PATH %s\n",
> 				__func__, path_en ? "ENABLED" : "DISABLED");
1252c1199
< 		sii9234->mhl_status_value.linkmode |= MHL_STATUS_PATH_ENABLED;
---
> 		sii9234->link_mode |= MHL_STATUS_PATH_ENABLED;
1254c1201
< 		sii9234->mhl_status_value.linkmode &= ~MHL_STATUS_PATH_ENABLED;
---
> 		sii9234->link_mode &= ~MHL_STATUS_PATH_ENABLED;
1256,1257c1203,1204
< 	cbus_command_request(sii9234, CBUS_WRITE_STAT, CBUS_LINK_CONTROL_2_REG,
< 					sii9234->mhl_status_value.linkmode);
---
> 	sii9234_enqueue_msc_work(sii9234, CBUS_WRITE_STAT,
> 			CBUS_LINK_CONTROL_2_REG, sii9234->link_mode, 0x0);
1260d1206
< 
1265c1211
< 	pr_debug("sii9234: CBUS WRT_STAT_RECD\n");
---
> 	pr_debug("sii9234: %s(): CBUS WRT_STAT_RECD\n", __func__);
1282,1283c1228,1229
< 	pr_debug("sii9234: STATUS_REG0 : [%d];STATUS_REG1 : [%d]\n",
< 			status_reg0, status_reg1);
---
> 	pr_debug("sii9234: %s(): STATUS_REG0 : [%d];STATUS_REG1 : [%d]\n",
> 			__func__, status_reg0, status_reg1);
1285,1286c1231
< 	if (!(sii9234->mhl_status_value.linkmode &
< 				MHL_STATUS_PATH_ENABLED) &&
---
> 	if (!(sii9234->link_mode & MHL_STATUS_PATH_ENABLED) &&
1289,1290c1234
< 	} else if ((sii9234->mhl_status_value.linkmode &
< 				MHL_STATUS_PATH_ENABLED) &&
---
> 	} else if ((sii9234->link_mode & MHL_STATUS_PATH_ENABLED) &&
1296,1300c1240,1251
< 		pr_debug("sii9234: DEV CAP READY\n");
< 		cbus_command_request(sii9234, CBUS_READ_DEVCAP,
< 						DEVCAP_DEV_CAT, 0x00);
< 		cbus_command_request(sii9234, CBUS_READ_DEVCAP,
< 						DEVCAP_DEV_FEATURE_FLAG, 0x00);
---
> 		pr_debug("sii9234: %s(): DEV CAP READY\n", __func__);
> 
> 		sii9234->msc_dcap_read_ready = true;
> 
> 		pr_debug("sii9234: %s(): DEV CAP READY dev cat\n", __func__);
> 		sii9234_enqueue_msc_work(sii9234, CBUS_READ_DEVCAP,
> 					MHL_DEVCAP_DEV_CAT, 0x0, 0x0);
> 
> 		pr_debug("sii9234: %s(): DEV CAP READY feature flag\n",
> 				__func__);
> 		sii9234_enqueue_msc_work(sii9234, CBUS_READ_DEVCAP,
> 					MHL_DEVCAP_FEATURE_FLAG, 0x0, 0x0);
1346,1347c1297,1298
< 	pr_debug("sii9234: INTR_REG0 : [%d]; INTR_REG1 : [%d]\n",
< 			intr_reg0, intr_reg1);
---
> 	pr_debug("sii9234: %s(): INTR_REG0 : [%d]; INTR_REG1 : [%d]\n",
> 			__func__, intr_reg0, intr_reg1);
1350,1354c1301,1307
< 		pr_debug("sii9234: MHL_INT_DCAP_CHG\n");
< 		cbus_command_request(sii9234, CBUS_READ_DEVCAP,
< 				DEVCAP_DEV_CAT, 0x00);
< 		cbus_command_request(sii9234, CBUS_READ_DEVCAP,
< 				DEVCAP_DEV_FEATURE_FLAG, 0x00);
---
> 		pr_debug("sii9234: %s(): IHL_INT_DCAP_CHG\n", __func__);
> 
> 		sii9234_enqueue_msc_work(sii9234, CBUS_READ_DEVCAP,
> 					MHL_DEVCAP_DEV_CAT, 0x0, 0x0);
> 
> 		sii9234_enqueue_msc_work(sii9234, CBUS_READ_DEVCAP,
> 					MHL_DEVCAP_FEATURE_FLAG, 0x0, 0x0);
1358c1311
< 		pr_debug("sii9234:  MHL_INT_DSCR_CHG\n");
---
> 		pr_debug("sii9234: %s(): IHL_INT_DSCR_CHG\n", __func__);
1361,1363c1314,1317
< 		pr_debug("sii9234:  MHL_INT_REQ_WRT\n");
< 		cbus_command_request(sii9234, CBUS_SET_INT,
< 					 MHL_RCHANGE_INT, MHL_INT_GRT_WRT);
---
> 		pr_debug("sii9234: %s(): MHL_INT_REQ_WRT\n", __func__);
> 
> 		sii9234_enqueue_msc_work(sii9234, CBUS_SET_INT,
> 					MHL_RCHANGE_INT, MHL_INT_GRT_WRT, 0x0);
1367c1321
< 		pr_debug("sii9234:  MHL_INT_GRT_WRT\n");
---
> 		pr_debug("sii9234: %s(): MHL_INT_GRT_WRT\n", __func__);
1370,1371c1324
< 		pr_debug("sii9234: MHL_INT_EDID_CHG\n");
< 
---
> 		pr_debug("sii9234: %s(): MHL_INT_EDID_CHG\n", __func__);
1582c1535,1537
< int rsen_state_timer_out(struct sii9234_data *sii9234)
---
> /* Must call with sii9234->lock held */
> static int sii9234_msc_req_locked(struct sii9234_data *sii9234,
> 					struct msc_packet *msc_pkt)
1584,1585c1539,1540
< 	int ret = 0;
< 	u8 value;
---
> 	int ret;
> 	u8 start_command;
1587,1591c1542,1602
< 	ret = mhl_tx_read_reg(sii9234, MHL_TX_SYSSTAT_REG, &value);
< 	if (ret < 0) {
< 		printk(KERN_ERR
< 			"[ERROR] %s() read MHL_TX_SYSSTAT_REG\n", __func__);
< 		goto err_exit;
---
> 	if (sii9234->state != STATE_ESTABLISHED)
> 		return -ENOENT;
> 
> 	init_completion(&sii9234->msc_complete);
> 
> 	cbus_write_reg(sii9234, CBUS_MSC_OFFSET_REG, msc_pkt->offset);
> 	if (msc_pkt->command == CBUS_MSC_MSG)
> 		msc_pkt->data_1 = msc_pkt->offset;
> 	cbus_write_reg(sii9234, CBUS_MSC_FIRST_DATA_OUT, msc_pkt->data_1);
> 
> 	switch (msc_pkt->command) {
> 	case CBUS_SET_INT:
> 	case CBUS_WRITE_STAT:
> 		start_command = START_WRITE_STAT_INT;
> 		break;
> 	case CBUS_MSC_MSG:
> 		cbus_write_reg(sii9234, CBUS_MSC_SECOND_DATA_OUT,
> 							msc_pkt->data_2);
> 		cbus_write_reg(sii9234, CBUS_MSC_OFFSET_REG, msc_pkt->command);
> 
> 		start_command = START_MSC_MSG;
> 		break;
> 	case CBUS_READ_DEVCAP:
> 		start_command = START_READ_DEVCAP;
> 		break;
> 	case CBUS_WRITE_BURST:
> 		start_command = START_WRITE_BURST;
> 		break;
> 	case CBUS_GET_STATE:
> 		if (msc_pkt->command == CBUS_GET_STATE)
> 			pr_info("%s() CBUS_GET_STATE\n", __func__);
> 	case CBUS_GET_VENDOR_ID:
> 		if (msc_pkt->command == CBUS_GET_VENDOR_ID)
> 			pr_info("%s() CBUS_GET_VENDOR_ID\n", __func__);
> 	case CBUS_SET_HPD:
> 		if (msc_pkt->command == CBUS_SET_HPD)
> 			pr_info("%s() CBUS_SET_HPD\n", __func__);
> 	case CBUS_CLR_HPD:
> 		if (msc_pkt->command == CBUS_CLR_HPD)
> 			pr_info("%s() CBUS_CLR_HPD\n", __func__);
> 	case CBUS_GET_MSC_ERR_CODE:
> 		if (msc_pkt->command == CBUS_GET_MSC_ERR_CODE)
> 			pr_info("%s() CBUS_GET_MSC_ERR_CODE\n", __func__);
> 	case CBUS_GET_SC3_ERR_CODE:
> 		if (msc_pkt->command == CBUS_GET_SC3_ERR_CODE)
> 			pr_info("%s() CBUS_GET_SC3_ERR_CODE\n", __func__);
> 	case CBUS_GET_SC1_ERR_CODE:
> 		if (msc_pkt->command == CBUS_GET_SC1_ERR_CODE)
> 			pr_info("%s() CBUS_GET_SC1_ERR_CODE\n", __func__);
> 	case CBUS_GET_DDC_ERR_CODE:
> 		if (msc_pkt->command == CBUS_GET_DDC_ERR_CODE)
> 			pr_info("%s() CBUS_GET_DDC_ERR_CODE\n", __func__);
> 
> 		cbus_write_reg(sii9234, CBUS_MSC_OFFSET_REG, msc_pkt->command);
> 
> 		start_command = START_MSC_RESERVED;
> 		break;
> 	default:
> 		pr_err("[ERROR] %s() invalid msc command(%d)\n",
> 			__func__, msc_pkt->command);
> 		return -EINVAL;
1594c1605
< 	sii9234->rsen = value & RSEN_STATUS;
---
> 	cbus_write_reg(sii9234, CBUS_MSC_COMMAND_START, start_command);
1596,1607c1607,1641
< 	if (value & RSEN_STATUS) {
< 		pr_info("sii9234: MHL cable connected.. RESN High\n");
< 	} else {
< 		pr_info("sii9234: RSEN lost\n");
< 		/* Once RSEN loss is confirmed,we need to check
< 		 * based on cable status and chip power status,whether
< 		 * it is SINK Loss(HDMI cable not connected, TV Off)
< 		 * or MHL cable disconnection
< 		 * TODO: Define the below mhl_disconnection()
< 		 */
< 		msleep(T_SRC_RXSENSE_DEGLITCH);
< 		ret = mhl_tx_read_reg(sii9234, MHL_TX_SYSSTAT_REG, &value);
---
> 	mutex_unlock(&sii9234->lock);
> 	ret = wait_for_completion_timeout(&sii9234->msc_complete,
> 					  msecs_to_jiffies(500));
> 	if (ret == 0)
> 		printk(KERN_ERR	"[ERROR] %s() MSC_REQ_DONE timeout\n",
> 			__func__);
> 
> 	mutex_lock(&sii9234->lock);
> 
> 	return ret ? 0 : -EIO;
> }
> 
> void sii9234_process_msc_work(struct work_struct *work)
> {
> 	u8 val;
> 	int ret;
> 	struct msc_packet *p_msc_pkt, *scratch;
> 	struct sii9234_data *sii9234 = container_of(work,
> 						struct sii9234_data,
> 						msc_work);
> 
> 	mutex_lock(&sii9234->msc_lock);
> 	mutex_lock(&sii9234->lock);
> 
> 	pr_info("%s() - start\n", __func__);
> 
> 	list_for_each_entry_safe(p_msc_pkt, scratch,
> 		&g_msc_packet_list, p_msc_packet_list) {
> 
> 		pr_info("[MSC] %s() command(0x%x), offset(0x%x), data_1(0x%x), data_2(0x%x)\n",
> 			__func__, p_msc_pkt->command, p_msc_pkt->offset,
> 			p_msc_pkt->data_1, p_msc_pkt->data_2);
> 
> 		/* msc request */
> 		ret = sii9234_msc_req_locked(sii9234, p_msc_pkt);
1609,1612c1643,1645
< 			printk(KERN_ERR
< 				"[ERROR] %s() read MHL_TX_SYSSTAT_REG\n",
< 				__func__);
< 			goto err_exit;
---
> 			pr_info("%s(): msc_req_locked error %d\n", __func__,
> 					ret);
> 			goto exit;
1615,1624c1648,1674
< 		pr_info("sys_stat: %x ~\n", value);
< 		if ((value & RSEN_STATUS) == 0)	{
< 			printk(KERN_INFO
< 				"%s() RSEN Really LOW ~\n", __func__);
< 			/*To meet CTS 3.3.22.2 spec*/
< 			sii9234_tmds_control(sii9234, false);
< 			force_usb_id_switch_open(sii9234);
< 			release_usb_id_switch_open(sii9234);
< 			ret = -1;
< 			goto err_exit;
---
> 		/* MSC_REQ_DONE received */
> 		switch (p_msc_pkt->command) {
> 		case CBUS_MSC_MSG:
> 			if ((p_msc_pkt->offset == MSG_RCPE) &&
> 				(p_msc_pkt->data_2 == 0x01)) {
> 				sii9234_enqueue_msc_work(
> 					sii9234, CBUS_MSC_MSG,
> 					MSG_RCPK, MSG_RCPK,
> 					0x0);
> 			}
> 			break;
> 		case CBUS_WRITE_STAT:
> 			break;
> 		case CBUS_SET_INT:
> 			break;
> 		case CBUS_WRITE_BURST:
> 			break;
> 		case CBUS_READ_DEVCAP:
> 			ret = cbus_read_reg(sii9234,
> 					CBUS_MSC_FIRST_DATA_IN, &val);
> 			if (ret < 0)
> 				break;
> 
> 			sii9234->devcap[p_msc_pkt->offset] = val;
> 			break;
> 		default:
> 			break;
1625a1676,1680
> 
> 		list_del(&p_msc_pkt->p_msc_packet_list);
> 		pr_info("[MSC] %s() free item , addr = 0x%x, cnt=%d\n",
> 			__func__, (unsigned int)p_msc_pkt, --g_list_cnt);
> 		kfree(p_msc_pkt);
1627c1682,1685
< 	return ret;
---
> exit:
> 	mutex_unlock(&sii9234->lock);
> 	mutex_unlock(&sii9234->msc_lock);
> }
1629,1633c1687,1743
< err_exit:
< 	printk(KERN_ERR	"[ERROR] %s() err_exit\n", __func__);
< 	/*turn off mhl and change usb_sel to usb*/
< 	mhl_onoff_ex(sii9234, false);
< 	return ret;
---
> static int sii9234_enqueue_msc_work(struct sii9234_data *sii9234, u8 command,
> 		u8 offset, u8 data_1, u8 data_2)
> {
> 	struct msc_packet *packet_item;
> 
> 	packet_item = kmalloc(sizeof(struct msc_packet), GFP_KERNEL);
> 	if (!packet_item) {
> 		pr_err("[ERROR] %s() kmalloc error\n", __func__);
> 		return -ENOMEM;
> 	} else
> 		pr_info("[MSC] %s() add item, addr = 0x%x, cnt=%d\n",
> 			__func__, (unsigned int)packet_item, ++g_list_cnt);
> 
> 	packet_item->command = command;
> 	packet_item->offset = offset;
> 	packet_item->data_1 = data_1;
> 	packet_item->data_2 = data_2;
> 
> 	pr_info("[MSC] %s() command(0x%x), offset(0x%x), data_1(0x%x), data_2(0x%x)\n",
> 		__func__, command, offset, data_1, data_2);
> 	list_add_tail(&packet_item->p_msc_packet_list, &g_msc_packet_list);
> 
> 	pr_info("[MSC] %s() msc work schedule\n", __func__);
> 	queue_work(sii9234_msc_wq, &(sii9234->msc_work));
> 
> 	return 0;
> }
> 
> /* Must call with sii9234->lock held */
> static int sii9234_devcap_read_locked(struct sii9234_data *sii9234, u8 offset)
> {
> 	int ret;
> 	u8 val;
> 	struct msc_packet msc_pkt;
> 
> 	if (offset > 0xf)
> 		return -EINVAL;
> 
> 	msc_pkt.command = CBUS_READ_DEVCAP;
> 	msc_pkt.offset = offset;
> 	msc_pkt.data_1 = 0x0;
> 
> 	ret = sii9234_msc_req_locked(sii9234, &msc_pkt);
> 	if (ret < 0) {
> 		pr_err("[ERROR] %s() sii9234_msc_req_locked ret=%d\n",
> 			__func__, ret);
> 		return ret;
> 	}
> 
> 	ret = cbus_read_reg(sii9234, CBUS_MSC_FIRST_DATA_IN, &val);
> 	if (ret < 0) {
> 		pr_err("[ERROR] %s() read CBUS_MSC_FIRST_DATA_IN ret=%d\n",
> 			__func__, ret);
> 		return ret;
> 	}
> 
> 	return val;
1635a1746
> 
1643c1754
< 			"[ERR] %s() getting resource is failed\n", __func__);
---
> 			"[ERROR] %s() getting resource is failed\n", __func__);
1652c1763,1764
< 		pr_debug("sii9234: detection callback is already scheduled.\n");
---
> 		pr_debug("%s(): detection callback is already scheduled.\n",
> 				__func__);
1661a1774
> 	int i;
1675c1788
< 	sii9234->mhl_status_value.linkmode = MHL_STATUS_CLK_MODE_NORMAL;
---
> 	sii9234->link_mode = MHL_STATUS_CLK_MODE_NORMAL;
1679c1792
< 	memset(sii9234->cbus_pkt_buf, 0x00, sizeof(sii9234->cbus_pkt_buf));
---
> 	sii9234->msc_dcap_read_ready = false;
1683a1797
> 
1812,1819d1925
< 	ret = mhl_tx_set_reg(sii9234, MHL_TX_DISC_CTRL6_REG, USB_ID_OVR);
< 	if (ret < 0) {
< 		printk(KERN_ERR
< 		       "[ERROR] %s():%d set MHL_TX_DISC_CTRL6_REG failed !\n",
< 		       __func__, __LINE__);
< 		goto unhandled;
< 	}
< 
1829,1830c1935,1936
< 	ret = mhl_tx_set_reg(sii9234, MHL_TX_DISC_CTRL3_REG, 0x86);
< /*	ret = mhl_tx_set_reg(sii9234, MHL_TX_DISC_CTRL3_REG, 0xA6); */
---
> /*	ret = mhl_tx_set_reg(sii9234, MHL_TX_DISC_CTRL3_REG, 0x86); */
> 	ret = mhl_tx_set_reg(sii9234, MHL_TX_DISC_CTRL3_REG, 0xA6);
1864,1874d1969
< #if 0
< 	/* release usb_id switch */
< 	ret = mhl_tx_clear_reg(sii9234, MHL_TX_DISC_CTRL6_REG, USB_ID_OVR);
< 	if (ret < 0) {
< 		printk(KERN_ERR
< 		       "[ERROR] %s():%d clear MHL_TX_DISC_CTRL6_REG failed !\n",
< 		       __func__, __LINE__);
< 		goto unhandled;
< 	}
< #endif
< 
1921c2016
< 	ret = cbus_write_reg(sii9234, CBUS_INTR1_ENABLE_REG,
---
> 	ret = cbus_write_reg(sii9234, CBUS_INT_1_MASK,
1930c2025
< 	ret = cbus_write_reg(sii9234, CBUS_INTR2_ENABLE_REG,
---
> 	ret = cbus_write_reg(sii9234, CBUS_INT_2_MASK,
1940c2035,2036
< /*	mhl_tx_clear_reg(sii9234, MHL_TX_DISC_CTRL5_REG, (1<<1) | (1<<0));*/
---
> 	/* refer to wolverine */
> 	mhl_tx_clear_reg(sii9234, MHL_TX_DISC_CTRL5_REG, (1<<1) | (1<<0));
1942,1943c2038,2039
< /*end of this*/
< 	pr_debug("sii9234: waiting for RGND measurement\n");
---
> 
> 	pr_debug("%s(): waiting for RGND measurement\n", __func__);
1970c2066
< 	pr_debug("sii9234: waiting for detection\n");
---
> 	pr_debug("%s(): waiting for detection\n", __func__);
2004c2100
< 	pr_debug("sii9234: waiting for RSEN_INT\n");
---
> 	pr_debug("%s(): waiting for RSEN_INT\n", __func__);
2008,2015d2103
< 	if (ret == 0) {
< 		/*CTS 3.3.14.3 Discovery;Sink Never Drives MHL+/- HIGH*/
< 		/*MHL SPEC 8.2.1.1.1;Transition SRC4-SRC7*/
< 		if (rsen_state_timer_out(sii9234) < 0) {
< 			pr_info("sii9234: rsen_state_timer_out\n");
< 			goto unhandled;
< 		}
< 	}
2019c2107
< 		pr_debug("sii9234: Recheck RSEN value\n");
---
> 		pr_debug("%s(): Recheck RSEN value\n", __func__);
2021,2022c2109,2111
< 			msleep(T_SRC_RXSENSE_DEGLITCH);
< 			pr_debug("sii9234: RSEN is low -> retry once\n");
---
> 			usleep_range(T_SRC_RXSENSE_DEGLITCH * USEC_PER_MSEC,
> 					T_SRC_RXSENSE_DEGLITCH * USEC_PER_MSEC);
> 			pr_debug("%s(): RSEN is low -> retry once\n", __func__);
2027c2116
< 				pr_debug("sii9234: RSEN is still low\n");
---
> 				pr_debug("%s(): RSEN is still low\n", __func__);
2033a2123
> 	pr_info("%s(): RSEN OK\n", __func__);
2035,2036d2124
< 	pr_info("sii9234: connection established\n");
< 	sii9234->claimed = true;
2041,2042c2129,2161
< 	if (sii9234->pdata->vbus_present)
< 		sii9234->pdata->vbus_present(true);
---
> 	mutex_unlock(&sii9234->lock);
> 
> 	ret = wait_event_timeout(sii9234->wq, sii9234->msc_dcap_read_ready,
> 						msecs_to_jiffies(2000));
> 
> 	if (sii9234->msc_dcap_read_ready) {
> 		pr_info("%s(): read devcap\n", __func__);
> 		memset(sii9234->devcap, 0x0, sizeof(sii9234->devcap));
> 		for (i = 0; i < 16; i++) {
> 			mutex_lock(&sii9234->msc_lock);
> 			mutex_lock(&sii9234->lock);
> 			ret = sii9234_devcap_read_locked(sii9234, i);
> 			mutex_unlock(&sii9234->lock);
> 			if (ret < 0) {
> 				mutex_unlock(&sii9234->msc_lock);
> 				pr_err("[ERROR] %s() sii9234_devcap_read_locked\n",
> 					__func__);
> 				break;
> 			}
> 			sii9234->devcap[i] = ret;
> 			mutex_unlock(&sii9234->msc_lock);
> 		}
> #ifdef DEBUG
> 		if (ret >= 0)
> 			print_hex_dump(KERN_DEBUG, "sii9234: devcap = ",
> 						DUMP_PREFIX_NONE, 16, 1,
> 						sii9234->devcap, 16, false);
> #endif
> 	} else {
> 		printk(KERN_ERR"%s() msc not ready : ret=%d, msc_dcap_read_ready=%d\n",
> 			__func__, ret, sii9234->msc_dcap_read_ready);
> 	}
> 	mutex_lock(&sii9234->lock);
2043a2163,2175
> 	/* It's possible for devcap reading to fail but the adapter still
> 	 * be connected.  Therefore we must keep ownership of the port
> 	 * as long as it's still connected.
> 	 */
> 	if (sii9234->state != STATE_ESTABLISHED) {
> 		printk(KERN_ERR"%s() state is wrong : 0x%x\n",
> 			__func__, sii9234->state);
> 		goto unhandled;
> 	}
> 
> 	pr_info("%s(): connection established\n", __func__);
> 
> 	sii9234->claimed = true;
2049c2181
< 	pr_info("sii9234: Detection failed");
---
> 	pr_info("%s(): Detection failed", __func__);
2058,2062c2190,2192
< 	/*mhl spec: 8.3.3, if discovery failed, must retry discovering*/
< 	if ((sii9234->state == STATE_DISCOVERY_FAILED) &&
< 						 (sii9234->rgnd == RGND_1K)) {
< 		pr_cont("Discovery failed but RGND_1K impedence"
< 					" restart detection_callback");
---
> 	pr_info("%s() mhl power off\n", __func__);
> 	mutex_unlock(&sii9234->lock);
> 	mhl_onoff_ex(sii9234, false);
2064,2065c2194,2196
< 		if (sii9234->pdata->hw_reset)
< 			sii9234->pdata->hw_reset();
---
> 	pr_debug("%s(): dectection callback finished\n", __func__);
> 	return;
> }
2067,2068c2198,2212
< 		queue_work(sii9234_wq, &(sii9234->sii9234_int_work));
< 		mutex_unlock(&sii9234->lock);
---
> #ifdef CONFIG_SAMSUNG_MHL_9290
> static int sii9234_30pin_callback(struct notifier_block *this,
> 					unsigned long event, void *ptr)
> {
> 	int ret = false;
> 	struct sii9234_data *sii9234 = container_of(this, struct sii9234_data,
> 								acc_con_nb);
> 
> 	pr_debug("%s\n", __func__);
> 	/* if connection event, start detection */
> 	if (event) {
> 		ret = sii9234_30pin_init_for_9290(sii9234);
> #ifdef	CONFIG_SAMSUNG_WORKAROUND_HPD_GLANCE
> 		mhl_hpd_handler(true);
> #endif
2070,2072c2214,2220
< 		printk(KERN_INFO	"%s() mhl power off\n", __func__);
< 		mutex_unlock(&sii9234->lock);
< 		mhl_onoff_ex(sii9234, false);
---
> 		pr_info("sii9234: power down for 9290\n");
> 		sii9234->state = STATE_DISCONNECTED;
> 		sii9234->pdata->hw_onoff(0);
> #ifdef	CONFIG_SAMSUNG_WORKAROUND_HPD_GLANCE
> 		mhl_hpd_handler(false);
> #endif
> 		ret = false;
2074,2076c2222
< 
< 	pr_debug("sii9234: dectection callback finished\n");
< 	return;
---
> 	return ret;
2079c2225,2227
< #ifdef	CONFIG_SII9234_CBUS
---
> static int sii9234_cbus_init_for_9290(struct sii9234_data *sii9234)
> {
> 	int ret = 0;
2081c2229,2255
< static void save_cbus_pkt_to_buffer(struct sii9234_data *sii9234)
---
> 	ret = cbus_write_reg(sii9234, 0x1F, 0x02);
> 	if (ret < 0)
> 		return ret;
> 	ret = cbus_write_reg(sii9234, 0x07, 0x30 | 0x06);
> 	if (ret < 0)
> 		return ret;
> 	ret = cbus_write_reg(sii9234, 0x40, 0x03);
> 	if (ret < 0)
> 		return ret;
> 	ret = cbus_write_reg(sii9234, 0x42, 0x06);
> 	if (ret < 0)
> 		return ret;
> 	ret = cbus_write_reg(sii9234, 0x36, 0x0C);
> 	if (ret < 0)
> 		return ret;
> 	ret = cbus_write_reg(sii9234, 0x3D, 0xFD);
> 	if (ret < 0)
> 		return ret;
> 	ret = cbus_write_reg(sii9234, 0x1C, 0x00);
> 	if (ret < 0)
> 		return ret;
> 	ret = cbus_write_reg(sii9234, 0x44, 0x00);
> 
> 	return ret;
> }
> 
> static int sii9234_30pin_reg_init_for_9290(struct sii9234_data *sii9234)
2083c2257,2258
< 	int index;
---
> 	int ret = 0;
> 	u8 value;
2085,2087c2260,2262
< 	for (index = 0; index < CBUS_PKT_BUF_COUNT; index++)
< 		if (sii9234->cbus_pkt_buf[index].status == false)
< 			break;
---
> 	ret = tpi_write_reg(sii9234, 0x3D, 0x3F);
> 	if (ret < 0)
> 		return ret;
2089,2092c2264,2351
< 	if (index == CBUS_PKT_BUF_COUNT) {
< 		pr_debug("sii9234: Error save_cbus_pkt Buffer Full\n");
< 		index -= 1; /*adjust index*/
< 	}
---
> 	ret = hdmi_rx_write_reg(sii9234, 0x11, 0x01);
> 	if (ret < 0)
> 		return ret;
> 	ret = hdmi_rx_write_reg(sii9234, 0x12, 0x15);
> 	if (ret < 0)
> 		return ret;
> 	ret = mhl_tx_write_reg(sii9234, 0x08, 0x35);
> 	if (ret < 0)
> 		return ret;
> 	ret = hdmi_rx_write_reg(sii9234, 0x00, 0x00);
> 	if (ret < 0)
> 		return ret;
> 	ret = hdmi_rx_write_reg(sii9234, 0x13, 0x60);
> 	if (ret < 0)
> 		return ret;
> 	ret = hdmi_rx_write_reg(sii9234, 0x14, 0xF0);
> 	if (ret < 0)
> 		return ret;
> 	ret = hdmi_rx_write_reg(sii9234, 0x4B, 0x06);
> 	if (ret < 0)
> 		return ret;
> 
> 	/* Analog PLL Control */
> 	ret = hdmi_rx_write_reg(sii9234, 0x17, 0x07);
> 	if (ret < 0)
> 		return ret;
> 	ret = hdmi_rx_write_reg(sii9234, 0x1A, 0x20);
> 	if (ret < 0)
> 		return ret;
> 	ret = hdmi_rx_write_reg(sii9234, 0x22, 0xE0);
> 	if (ret < 0)
> 		return ret;
> 	ret = hdmi_rx_write_reg(sii9234, 0x23, 0xC0);
> 	if (ret < 0)
> 		return ret;
> 	ret = hdmi_rx_write_reg(sii9234, 0x24, 0xA0);
> 	if (ret < 0)
> 		return ret;
> 	ret = hdmi_rx_write_reg(sii9234, 0x25, 0x80);
> 	if (ret < 0)
> 		return ret;
> 	ret = hdmi_rx_write_reg(sii9234, 0x26, 0x60);
> 	if (ret < 0)
> 		return ret;
> 	ret = hdmi_rx_write_reg(sii9234, 0x27, 0x40);
> 	if (ret < 0)
> 		return ret;
> 	ret = hdmi_rx_write_reg(sii9234, 0x28, 0x20);
> 	if (ret < 0)
> 		return ret;
> 	ret = hdmi_rx_write_reg(sii9234, 0x29, 0x00);
> 	if (ret < 0)
> 		return ret;
> 
> 	ret = hdmi_rx_write_reg(sii9234, 0x4D, 0x02);
> 	if (ret < 0)
> 		return ret;
> 	ret = hdmi_rx_write_reg(sii9234, 0x4C, 0xA0);
> 	if (ret < 0)
> 		return ret;
> 
> 	ret = mhl_tx_write_reg(sii9234, 0x80, 0x34);
> 	if (ret < 0)
> 		return ret;
> 
> 	ret = hdmi_rx_write_reg(sii9234, 0x31, 0x0B);
> 	if (ret < 0)
> 		return ret;
> 	ret = hdmi_rx_write_reg(sii9234, 0x45, 0x06);
> 	if (ret < 0)
> 		return ret;
> 	ret = mhl_tx_write_reg(sii9234, 0xA0, 0xD0);
> 	if (ret < 0)
> 		return ret;
> 	ret = mhl_tx_write_reg(sii9234, 0xA1, 0xFC);
> 	if (ret < 0)
> 		return ret;
> 
> 	ret = mhl_tx_write_reg(sii9234, 0xA3, 0xEB);	/*output swing level*/
> 	if (ret < 0)
> 		return ret;
> 	ret = mhl_tx_write_reg(sii9234, 0xA6, 0x00);
> 	if (ret < 0)
> 		return ret;
> 
> 	ret = mhl_tx_write_reg(sii9234, 0x2B, 0x01);
> 	if (ret < 0)
> 		return ret;
2094,2097c2353,2428
< 	pr_debug("sii9234: save_cbus_pkt_to_buffer index = %d\n", index);
< 	memcpy(&sii9234->cbus_pkt_buf[index], &sii9234->cbus_pkt,
< 					sizeof(struct cbus_packet));
< 	sii9234->cbus_pkt_buf[index].status = true;
---
> 	/* CBUS & Discovery */
> 	ret = mhl_tx_read_reg(sii9234, MHL_TX_DISC_CTRL1_REG, &value);
> 	if (ret < 0)
> 		return ret;
> 	value &= ~(1<<2);
> 	value |= (1<<3);
> 	ret = mhl_tx_write_reg(sii9234, MHL_TX_DISC_CTRL1_REG, value);
> 	if (ret < 0)
> 		return ret;
> 
> 	ret = mhl_tx_write_reg(sii9234, 0x91, 0xE5);
> 	if (ret < 0)
> 		return ret;
> 	ret = mhl_tx_write_reg(sii9234, 0x94, 0x66);
> 	if (ret < 0)
> 		return ret;
> 
> 	ret = cbus_read_reg(sii9234, 0x31, &value);
> 	if (ret < 0)
> 		return ret;
> 	value |= 0x0C;
> 	if (ret < 0)
> 		return ret;
> 	ret = cbus_write_reg(sii9234, 0x31, value);
> 	if (ret < 0)
> 		return ret;
> 
> 	ret = mhl_tx_write_reg(sii9234, 0xA5, 0x80);
> 	if (ret < 0)
> 		return ret;
> 	ret = mhl_tx_write_reg(sii9234, 0x95, 0x31);
> 	if (ret < 0)
> 		return ret;
> 	ret = mhl_tx_write_reg(sii9234, 0x96, 0x22);
> 	if (ret < 0)
> 		return ret;
> 
> 	ret = mhl_tx_read_reg(sii9234, MHL_TX_DISC_CTRL6_REG, &value);
> 	if (ret < 0)
> 		return ret;
> 	value |= (1<<6);
> 	ret = mhl_tx_write_reg(sii9234, MHL_TX_DISC_CTRL6_REG, value);
> 	if (ret < 0)
> 		return ret;
> 
> 	ret = mhl_tx_write_reg(sii9234, 0x92, 0x46);
> 	if (ret < 0)
> 		return ret;
> 	ret = mhl_tx_write_reg(sii9234, 0x93, 0xDC);
> 	if (ret < 0)
> 		return ret;
> 
> 	ret = mhl_tx_clear_reg(sii9234, MHL_TX_INT_CTRL_REG, (1<<2) | (1<<1));
> 	if (ret < 0)
> 		return ret;
> 
> 	mdelay(25);
> 
> 	ret = mhl_tx_clear_reg(sii9234, MHL_TX_DISC_CTRL6_REG, USB_ID_OVR);
> 	if (ret < 0)
> 		return ret;
> 
> 	ret = mhl_tx_write_reg(sii9234, 0x90, 0x27);
> 	if (ret < 0)
> 		return ret;
> 
> 	ret = sii9234_cbus_init_for_9290(sii9234);
> 	if (ret < 0)
> 		return ret;
> 
> 	ret = mhl_tx_write_reg(sii9234, 0x05, 0x4);
> 	if (ret < 0)
> 		return ret;
> 	ret = mhl_tx_write_reg(sii9234, 0x0D, 0x1C);
> 
> 	return ret;
2100c2431
< static void cbus_command_response(struct sii9234_data *sii9234)
---
> static int sii9234_30pin_init_for_9290(struct sii9234_data *sii9234)
2102,2104c2433,2434
< 	bool unsupported_key_received = false;
< 	bool req_write_status = false;
< 	u8 value, offset = 0;
---
> 	u8 value;
> 	int ret = 0;
2106,2107c2436,2438
< 	mutex_lock(&sii9234->cbus_lock);
< 	pr_debug("sii9234: cbus_command_response\n");
---
> 	mutex_lock(&sii9234->lock);
> 	sii9234->pdata->hw_onoff(1);
> 	sii9234->pdata->hw_reset();
2109,2208c2440
< 	switch (sii9234->cbus_pkt.command) {
< 	case CBUS_MSC_MSG:
< 		pr_debug("sii9234: cbus_command_response Received"
< 					" ACK for CBUS_MSC_MSG\n");
< #ifdef CONFIG_SII9234_RCP
< 		if (sii9234->cbus_pkt.data[0] == MSG_RCPE &&
< 					sii9234->cbus_pkt.data[1] == 0x01) {
< 			sii9234->cbus_pkt.command = CBUS_IDLE;
< 			mutex_unlock(&sii9234->cbus_lock);
< 			cbus_command_request(sii9234, CBUS_MSC_MSG, MSG_RCPK,
< 							sii9234->error_key);
< 			return;
< 		}
< #endif
< 		break;
< 	case CBUS_WRITE_STAT:
< 		pr_debug("sii9234: cbus_command_response"
< 					"CBUS_WRITE_STAT\n");
< 		cbus_read_reg(sii9234, CBUS_MSC_FIRST_DATA_IN_REG,
< 					&sii9234->cbus_pkt.data[0]);
< 		break;
< 	case CBUS_SET_INT:
< 		pr_debug("sii9234: cbus_command_response CBUS_SET_INT\n");
< 		if (sii9234->cbus_pkt.offset == MHL_RCHANGE_INT &&
< 				sii9234->cbus_pkt.data[0] == MHL_INT_DSCR_CHG) {
< 			/*Write burst final step... Req->GRT->Write->DSCR*/
< 			pr_debug("sii9234: MHL_RCHANGE_INT &"
< 						"MHL_INT_DSCR_CHG\n");
< 		} else if (sii9234->cbus_pkt.offset == MHL_RCHANGE_INT &&
< 				sii9234->cbus_pkt.data[0] == MHL_INT_DCAP_CHG) {
< 			pr_debug("sii9234: MHL_RCHANGE_INT &"
< 						"MHL_INT_DCAP_CHG\n");
< 			sii9234->cbus_pkt.command = CBUS_IDLE;
< 			mutex_unlock(&sii9234->cbus_lock);
< 			cbus_command_request(sii9234, CBUS_WRITE_STAT,
< 						MHL_STATUS_REG_CONNECTED_RDY,
< 						MHL_STATUS_DCAP_READY);
< 			return;
< 		}
< 		break;
< 	case CBUS_WRITE_BURST:
< 		pr_debug("sii9234: cbus_command_response"
< 						"MHL_WRITE_BURST\n");
< 		sii9234->cbus_pkt.command = CBUS_IDLE;
< 		mutex_unlock(&sii9234->cbus_lock);
< 		cbus_command_request(sii9234, CBUS_SET_INT,
< 					 MHL_RCHANGE_INT, MHL_INT_DSCR_CHG);
< 		return;
< 	case CBUS_READ_DEVCAP:
< 		pr_debug("sii9234: cbus_command_response"
< 					" CBUS_READ_DEVCAP\n");
< 		cbus_read_reg(sii9234, CBUS_MSC_FIRST_DATA_IN_REG,
< 								 &value);
< 		switch (sii9234->cbus_pkt.offset) {
< 		case DEVCAP_MHL_VERSION:
< 			sii9234->devcap.mhl_ver = value;
< 			pr_debug("sii9234: MHL_VERSION: %X\n", value);
< 			break;
< 		case DEVCAP_DEV_CAT:
< 			if (value & MHL_DEV_CATEGORY_POW_BIT)
< 				pr_debug("sii9234: CAT=POWERED");
< 			else
< 				pr_debug("sii9234: CAT=UNPOWERED");
< 				break;
< 		case DEVCAP_ADOPTER_ID_H:
< 			sii9234->devcap.adopter_id = (value & 0xFF) << 0x8;
< 			pr_debug("sii9234: DEVCAP_ADOPTER_ID_H = %X\n", value);
< 			break;
< 		case DEVCAP_ADOPTER_ID_L:
< 			sii9234->devcap.adopter_id |= value & 0xFF;
< 			pr_debug("sii9234: DEVCAP_ADOPTER_ID_L = %X\n", value);
< 			break;
< 		case DEVCAP_VID_LINK_MODE:
< 			sii9234->devcap.vid_link_mode = 0x3F & value;
< 			pr_debug("sii9234: MHL_CAP_VID_LINK_MODE = %d\n",
< 					 sii9234->devcap.vid_link_mode);
< 			break;
< 		case DEVCAP_AUD_LINK_MODE:
< 			sii9234->devcap.aud_link_mode = 0x03 & value;
< 			pr_debug("sii9234: DEVCAP_AUD_LINK_MODE =%d\n",
< 					sii9234->devcap.aud_link_mode);
< 			break;
< 		case DEVCAP_VIDEO_TYPE:
< 			sii9234->devcap.video_type = 0x8F & value;
< 			pr_debug("sii9234: DEVCAP_VIDEO_TYPE =%d\n",
< 					sii9234->devcap.video_type);
< 			break;
< 		case DEVCAP_LOG_DEV_MAP:
< 			sii9234->devcap.log_dev_map = value;
< 			pr_debug("sii9234: DEVCAP_LOG_DEV_MAP =%d\n",
< 					sii9234->devcap.log_dev_map);
< 			break;
< 		case DEVCAP_BANDWIDTH:
< 			sii9234->devcap.bandwidth = value;
< 			pr_debug("sii9234: DEVCAP_BANDWIDTH =%d\n",
< 						sii9234->devcap.bandwidth);
< 			break;
< 		case DEVCAP_DEV_FEATURE_FLAG:
< 			if ((value & MHL_FEATURE_RCP_SUPPORT) == 0)
< 				pr_debug("sii9234: FEATURE_FLAG=RCP");
---
> 	/*sii9234->state = STATE_9290_CONNECTED;*/
2210,2211c2442,2445
< 			if ((value & MHL_FEATURE_RAP_SUPPORT) == 0)
< 				pr_debug("sii9234: FEATURE_FLAG=RAP\n");
---
> 	/* init registers */
> 	ret = sii9234_30pin_reg_init_for_9290(sii9234);
> 	if (ret < 0)
> 		goto unhandled;
2213,2248c2447,2524
< 			if ((value & MHL_FEATURE_SP_SUPPORT) == 0)
< 				pr_debug("sii9234: FEATURE_FLAG=SP\n");
< 			break;
< 		case DEVCAP_DEVICE_ID_H:
< 			sii9234->devcap.device_id = (value & 0xFF) << 0x8;
< 			pr_info("sii9234: DEVICE_ID_H=0x%x\n", value);
< 			offset = DEVCAP_DEVICE_ID_L;
< 			break;
< 		case DEVCAP_DEVICE_ID_L:
< 			sii9234->devcap.device_id |= value & 0xFF;
< 			pr_info("sii9234: DEVICE_ID_L=0x%x\n", value);
< 			break;
< 		case DEVCAP_SCRATCHPAD_SIZE:
< 			  sii9234->devcap.scratchpad_size = value;
< 			  pr_debug("sii9234: DEVCAP_SCRATCHPAD_SIZE =%d\n",
< 					sii9234->devcap.scratchpad_size);
< 			  break;
< 		case DEVCAP_INT_STAT_SIZE:
< 			  sii9234->devcap.int_stat_size = value;
< 			  pr_debug("sii9234: DEVCAP_INT_STAT_SIZE =%d\n",
< 					sii9234->devcap.int_stat_size);
< 			  break;
< 		case DEVCAP_RESERVED:
< 			pr_info("sii9234: DEVCAP_RESERVED : %d\n", value);
< 			break;
< 		case DEVCAP_DEV_STATE:
< 			pr_debug("sii9234: DEVCAP_DEV_STATE\n");
< 			break;
< 		default:
< 			pr_debug("sii9234: DEVCAP DEFAULT\n");
< 			 break;
< 		}
< 		break;
< 	default:
< 		pr_debug("sii9234: error: cbus_command_response"
< 			" cannot handle : %d\n", sii9234->cbus_pkt.command);
---
> 	/* start tpi */
> 	ret = mhl_tx_write_reg(sii9234, 0xC7, 0x00);
> 	if (ret < 0)
> 		goto unhandled;
> 
> 	/* enable interrupts */
> 	ret = mhl_tx_write_reg(sii9234, 0xBC, 0x01);
> 	if (ret < 0)
> 		goto unhandled;
> 	ret = mhl_tx_write_reg(sii9234, 0xBD, 0x78);
> 	if (ret < 0)
> 		goto unhandled;
> 	ret = mhl_tx_write_reg(sii9234, 0xBE, 0x01);
> 	if (ret < 0)
> 		goto unhandled;
> 
> 	/* mhd rx connected */
> 	ret = mhl_tx_write_reg(sii9234, 0xBC, 0x01);
> 	if (ret < 0)
> 		goto unhandled;
> 	ret = mhl_tx_write_reg(sii9234, 0xBD, 0xA0);
> 	if (ret < 0)
> 		goto unhandled;
> 	ret = mhl_tx_write_reg(sii9234, 0xBE, 0x10);
> 	if (ret < 0)
> 		goto unhandled;
> 	ret = cbus_write_reg(sii9234, 0x07, 0x30 | 0x0E);
> 	if (ret < 0)
> 		goto unhandled;
> 	ret = cbus_write_reg(sii9234, 0x47, 0x03);
> 	if (ret < 0)
> 		goto unhandled;
> 	ret = cbus_write_reg(sii9234, 0x21, 0x01);
> 	if (ret < 0)
> 		goto unhandled;
> 
> 	/* enable mhd tx */
> 	ret = mhl_tx_clear_reg(sii9234, 0x1A, 1<<4);
> 	if (ret < 0)
> 		goto unhandled;
> 
> 	/* set mhd power active mode */
> 	ret = mhl_tx_clear_reg(sii9234, 0x1E, 1<<1 | 1<<0);
> 	if (ret < 0)
> 		goto unhandled;
> 
> 	ret = mhl_tx_write_reg(sii9234, 0xBC, 0x01);
> 	if (ret < 0)
> 		goto unhandled;
> 	ret = mhl_tx_write_reg(sii9234, 0xBD, 0xA0);
> 	if (ret < 0)
> 		goto unhandled;
> 
> 	ret = mhl_tx_read_reg(sii9234, 0xBE, &value);
> 	if (ret < 0)
> 		goto unhandled;
> 	if ((value & (1<<7 | 1<<6)) != 0x00) {
> 		/* Assert Mobile HD FIFO Reset */
> 		ret = mhl_tx_write_reg(sii9234, 0xBC, 0x01);
> 		if (ret < 0)
> 			goto unhandled;
> 		ret = mhl_tx_write_reg(sii9234, 0xBD, 0x05);
> 		if (ret < 0)
> 			goto unhandled;
> 		ret = mhl_tx_write_reg(sii9234, 0xBE, (1<<4 | 0x04));
> 		if (ret < 0)
> 			goto unhandled;
> 		mdelay(1);
> 		/* Deassert Mobile HD FIFO Reset */
> 		ret = mhl_tx_write_reg(sii9234, 0xBC, 0x01);
> 		if (ret < 0)
> 			goto unhandled;
> 		ret = mhl_tx_write_reg(sii9234, 0xBD, 0x05);
> 		if (ret < 0)
> 			goto unhandled;
> 		ret = mhl_tx_write_reg(sii9234, 0xBE, 0x04);
> 		if (ret < 0)
> 			goto unhandled;
2251,2252c2527,2528
< 	sii9234->cbus_pkt.command = CBUS_IDLE;
< 	mutex_unlock(&sii9234->cbus_lock);
---
> 	mutex_unlock(&sii9234->lock);
> 	return true;
2254,2291c2530,2534
< #ifdef CONFIG_SII9234_RCP
< 	if (unsupported_key_received)
< 		cbus_command_request(sii9234, CBUS_MSC_MSG, MSG_RCPK,
< 						sii9234->error_key);
< #endif
< 
< 	if (offset)
< 		cbus_command_request(sii9234, CBUS_READ_DEVCAP,
< 						offset, 0x00);
< 
< 	if (req_write_status)
< 		cbus_command_request(sii9234, CBUS_WRITE_STAT,
< 					MHL_STATUS_REG_CONNECTED_RDY,
< 						MHL_STATUS_DCAP_READY);
< }
< 
< #ifdef DEBUG_MHL
< static void cbus_command_response_dbg_msg(struct sii9234_data *sii9234,
< 							 u8 index)
< {
< 	/*Added to debugcbus_pkt_buf*/
< 	pr_info("sii9234: cbus_pkt_buf[index].command = %d,"
< 			"sii9234->cbus_pkt.command = %d\n",
< 					sii9234->cbus_pkt_buf[index].command,
< 					sii9234->cbus_pkt.command);
< 	pr_info("sii9234: cbus_pkt_buf[index].data[0] = %d,"
< 			"sii9234->cbus_pkt.data[0] =  %d\n",
< 					sii9234->cbus_pkt_buf[index].data[0],
< 					sii9234->cbus_pkt.data[0]);
< 
< 	pr_info("sii9234: cbus_pkt_buf[index].data[1] = %d,"
< 			 "sii9234->cbus_pkt.data[1] = %d\n",
< 					sii9234->cbus_pkt_buf[index].data[1],
< 					sii9234->cbus_pkt.data[1]);
< 	pr_info("sii9234: cbus_pkt_buf[index].offset = %d,"
< 			"sii9234->cbus_pkt.offset = %d\n",
< 					sii9234->cbus_pkt_buf[index].offset,
< 					sii9234->cbus_pkt.offset);
---
> unhandled:
> 	sii9234->pdata->hw_onoff(0);
> 	sii9234->state = STATE_DISCONNECTED;
> 	mutex_unlock(&sii9234->lock);
> 	return false;
2295,2320c2538
< static void cbus_command_response_all(struct sii9234_data *sii9234)
< {
< 	u8 index;
< 	struct cbus_packet cbus_pkt_process_buf[CBUS_PKT_BUF_COUNT];
< 	pr_debug("sii9234: cbus_command_response_all for All requests\n");
< 
< 	/*take bkp of cbus_pkt_buf*/
< 	memcpy(cbus_pkt_process_buf, sii9234->cbus_pkt_buf,
< 			sizeof(cbus_pkt_process_buf));
< 
< 	/*clear cbus_pkt_buf  to hold next request*/
< 	memset(sii9234->cbus_pkt_buf, 0x00, sizeof(sii9234->cbus_pkt_buf));
< 
< 	/*process all previous requests*/
< 	for (index = 0; index < CBUS_PKT_BUF_COUNT; index++) {
< 		if (cbus_pkt_process_buf[index].status == true) {
< 			memcpy(&sii9234->cbus_pkt, &cbus_pkt_process_buf[index],
< 						sizeof(struct cbus_packet));
< 			cbus_command_response(sii9234);
< #ifdef DEBUG_MHL
< 			/*print cbus_cmd messg*/
< 			cbus_command_response_dbg_msg(sii9234, index);
< #endif
< 		}
< 	}
< }
---
> #ifdef	CONFIG_SII9234_CBUS
2322,2323c2540
< static bool cbus_command_request(struct sii9234_data *sii9234,
< 				 enum cbus_command command, u8 offset, u8 data)
---
> static int sii9234_cbus_irq(struct sii9234_data *sii9234)
2325c2542,2545
< 	u8 start_bit = 0;
---
> 	u8 cbus_intr1, cbus_intr2;
> 	u8 cbus_intr1_enable, cbus_intr2_enable;
> 	u8 mhl_intr0, mhl_intr1;
> 	u8 mhl_status0, mhl_status1, mhl_status2, mhl_status3;
2327,2333c2547,2574
< 	mutex_lock(&sii9234->cbus_lock);
< 	if (sii9234->state != STATE_ESTABLISHED) {
< 		pr_debug("sii9234: cbus_command_request without establish\n");
< 		pr_debug("sii9234: ==> command:0x%X, offset:0x%X",
< 							command, offset);
< 			mutex_unlock(&sii9234->cbus_lock);
< 			return -EINVAL;
---
> 	int ret = 0;
> 
> 	cbus_read_reg(sii9234, CBUS_INT_STATUS_1_REG, &cbus_intr1);
> 	cbus_read_reg(sii9234, CBUS_INT_STATUS_2_REG, &cbus_intr2);
> 	cbus_read_reg(sii9234, CBUS_INT_1_MASK, &cbus_intr1_enable);
> 	cbus_read_reg(sii9234, CBUS_INT_2_MASK, &cbus_intr2_enable);
> 	cbus_read_reg(sii9234, CBUS_MHL_INTR_REG_0, &mhl_intr0);
> 	cbus_read_reg(sii9234, CBUS_MHL_INTR_REG_1, &mhl_intr1);
> 	cbus_read_reg(sii9234, CBUS_MHL_STATUS_REG_0, &mhl_status0);
> 	cbus_read_reg(sii9234, CBUS_MHL_STATUS_REG_1, &mhl_status1);
> 	cbus_read_reg(sii9234, CBUS_MHL_STATUS_REG_2, &mhl_status2);
> 	cbus_read_reg(sii9234, CBUS_MHL_STATUS_REG_3, &mhl_status3);
> 
> 	pr_debug("sii9234: cbus_intr %02x/%02x %02x/%02x\n",
> 		cbus_intr1, cbus_intr1_enable, cbus_intr2, cbus_intr2_enable);
> 
> 	if (cbus_intr1 & MSC_RESP_ABORT)
> 		cbus_resp_abort_error(sii9234);
> 
> 	if (cbus_intr1 & MSC_REQ_ABORT)
> 		cbus_req_abort_error(sii9234);
> 
> 	if (cbus_intr1 & CBUS_DDC_ABORT) {
> 		pr_debug("%s(): CBUS DDC abort\n", __func__);
> 		if (cbus_ddc_abort_error(sii9234)) {
> 			printk(KERN_ERR	"%s() ddc abort error\n", __func__);
> 			goto err_handler;
> 		}
2336,2341c2577,2580
< 	sii9234->cbus_pkt.command = command;
< 	sii9234->cbus_pkt.offset = offset;
< 	if (command == CBUS_MSC_MSG)
< 		sii9234->cbus_pkt.data[0] = offset;
< 	else
< 		sii9234->cbus_pkt.data[0] = data;
---
> 	if (cbus_intr1 & MSC_REQ_DONE) {
> 		pr_debug("%s(): CBUS cmd ACK Received\n", __func__);
> 		complete(&sii9234->msc_complete);
> 	}
2343,2351c2582,2585
< 	pr_debug("sii9234: %s() Sending MSC_MSG SubCommand=%d"
< 				", key-code=%d\n", __func__,
< 				sii9234->cbus_pkt.offset,
< 				sii9234->cbus_pkt.data[0]);
< 
< 	cbus_write_reg(sii9234, CBUS_MSC_OFFSET_REG,
< 						sii9234->cbus_pkt.offset);
< 	cbus_write_reg(sii9234, CBUS_MSC_FIRST_DATA_OUT_REG,
< 					sii9234->cbus_pkt.data[0]);
---
> 	if (cbus_intr1 & MSC_MSG_RECD) {
> 		pr_debug("%s(): MSC MSG received\n", __func__);
> 		cbus_handle_msc_msg(sii9234);
> 	}
2353,2402c2587,2591
< 	switch (sii9234->cbus_pkt.command) {
< 	case CBUS_SET_INT:
< 		pr_debug("sii9234: cbus_command_request"
< 						" CBUS_SET_INT\n");
< 		start_bit = START_BIT_WRITE_STAT_INT;
< 		break;
< 	case CBUS_WRITE_STAT:
< 		pr_debug("sii9234: cbus_command_request"
< 						" CBUS_WRITE_STAT\n");
< 		start_bit = START_BIT_WRITE_STAT_INT;
< 		break;
< 	case CBUS_MSC_MSG:
< 		/*treat offset as data[0] in case of CBUS_MSC_MSG*/
< 		sii9234->cbus_pkt.data[0] = offset;
< 		sii9234->cbus_pkt.data[1] = data;
< 		pr_debug("sii9234: cbus_command_request CBUS_MSC_MSG"
< 					" SubCommand=%d,key-code=%d\n",
< 					sii9234->cbus_pkt.command,
< 					sii9234->cbus_pkt.data[1]);
< 
< 		cbus_write_reg(sii9234, CBUS_MSC_SECOND_DATA_OUT_REG,
< 					sii9234->cbus_pkt.data[1]);
< 		cbus_write_reg(sii9234, CBUS_MSC_OFFSET_REG,
< 					sii9234->cbus_pkt.command);
< 		start_bit = START_BIT_MSC_MSG;
< 		break;
< 	case CBUS_READ_DEVCAP:
< 		pr_debug("sii9234: cbus_command_request CBUS_READ_DEVCAP\n");
< 		start_bit = START_BIT_READ_DEVCAP;
< 		break;
< 	case CBUS_WRITE_BURST:
< 		pr_debug("sii9234: cbus_command_request CBUS_WRITE_BURST\n");
< 		start_bit = START_BIT_WRITE_BURST;
< 		break;
< 	case CBUS_GET_STATE:
< 	case CBUS_GET_VENDOR_ID:
< 	case CBUS_SET_HPD:
< 	case CBUS_CLR_HPD:
< 	case CBUS_GET_MSC_ERR_CODE:
< 	case CBUS_GET_SC3_ERR_CODE:
< 	case CBUS_GET_SC1_ERR_CODE:
< 	case CBUS_GET_DDC_ERR_CODE:
< 		cbus_write_reg(sii9234, CBUS_MSC_OFFSET_REG,
< 					sii9234->cbus_pkt.command);
< 		start_bit = START_BIT_MSC_RESERVED;
< 		break;
< 	default:
< 		pr_debug("sii9234: error send cbus command fail\n");
< 		mutex_unlock(&sii9234->cbus_lock);
< 		return false;
---
> 	if (cbus_intr2 & WRT_STAT_RECD) {
> 		pr_debug("%s(): write stat received\n", __func__);
> 		cbus_handle_wrt_stat_recd(sii9234);
> 		sii9234->msc_dcap_read_ready =
> 			mhl_status0 & MHL_STATUS_DCAP_READY;
2405,2408c2594,2597
< 	pr_debug("sii9234: startbit = %d\n", start_bit);
< 	cbus_write_reg(sii9234, CBUS_MSC_COMMAND_START_REG, start_bit);
< 	save_cbus_pkt_to_buffer(sii9234);
< 	mutex_unlock(&sii9234->cbus_lock);
---
> 	if (cbus_intr2 & SET_INT_RECD) {
> 		pr_debug("%s(): SET_INT_RECD received\n", __func__);
> 		cbus_handle_set_int_recd(sii9234);
> 	}
2410c2599,2616
< 	return true;
---
> 	if (cbus_intr2 & WRT_BURST_RECD)
> 		pr_debug("%s(): write burst received\n", __func__);
> 
> 	cbus_write_reg(sii9234, CBUS_INT_STATUS_1_REG, cbus_intr1);
> 	cbus_write_reg(sii9234, CBUS_INT_STATUS_2_REG, cbus_intr2);
> 	cbus_write_reg(sii9234, CBUS_MHL_INTR_REG_0, mhl_intr0);
> 	cbus_write_reg(sii9234, CBUS_MHL_INTR_REG_1, mhl_intr1);
> 	cbus_write_reg(sii9234, CBUS_MHL_STATUS_REG_0, 0xFF);
> 	cbus_write_reg(sii9234, CBUS_MHL_STATUS_REG_1, 0xFF);
> 	cbus_write_reg(sii9234, CBUS_MHL_STATUS_REG_2, 0xFF);
> 	cbus_write_reg(sii9234, CBUS_MHL_STATUS_REG_3, 0xFF);
> 
> 	return ret;
> 
> err_handler:
> 	mhl_onoff_ex(sii9234, false);
> 
> 	return	-1;
2411a2618
> 
2414c2621
< static u8 sii9234_tmds_control(struct sii9234_data *sii9234, bool enable)
---
> static int sii9234_tmds_control(struct sii9234_data *sii9234, bool enable)
2416c2623,2624
< 	u8 ret = -1;
---
> 
> 	int ret = -1;
2424c2632
< 		pr_debug("sii9234: %s() MHL HPD High, enabled TMDS\n",
---
> 		pr_debug("%s() MHL HPD High, enabled TMDS\n",
2427a2636,2640
> 		if (ret < 0) {
> 			printk(KERN_ERR
> 				"%s() mhl_tx_set_reg fail\n", __func__);
> 			return ret;
> 		}
2435,2438c2648,2650
< /*
< 		ret = mhl_tx_clear_reg(sii9234, MHL_TX_INT_CTRL_REG,
< 							(1<<4) | (1<<5));
< */
---
> 		pr_debug("%s() MHL HPD low, disabled TMDS\n", __func__);
> 
> 		/* HPD force low - fixed issue unbalanced hpd state */
2455c2667
< 		pr_info("sii9234 MHL HPD low, disabled TMDS\n");
---
> 		pr_info("%s(): MHL HPD low, disabled TMDS\n", __func__);
2467,2470d2678
< 	bool	retry_detection = false;
< #ifdef	CONFIG_SII9234_CBUS
< 	u8 cbus_intr1, cbus_intr2;
< #endif
2472c2680,2684
< 	void (*cbus_resp_callback)(struct sii9234_data *) = NULL;
---
> 
> #ifdef	CONFIG_MHL_DEBUG
> 	u8	cbus_intr1, cbus_intr1_enable, cbus_intr2, cbus_intr2_enable;
> 	u8	intr_reg0, intr_reg1;
> #endif
2507,2530c2719,2723
< #ifdef CONFIG_SII9234_CBUS
< 	ret = cbus_read_reg(sii9234, CBUS_INT_STATUS_1_REG, &cbus_intr1);
< 	if (ret < 0) {
< 		printk(KERN_ERR
< 		       "[ERROR] %s():%d read CBUS_INT_STATUS_1_REG failed !\n",
< 		       __func__, __LINE__);
< 		goto i2c_error_exit;
< 	}
< 
< 	ret = cbus_read_reg(sii9234, CBUS_INT_STATUS_2_REG, &cbus_intr2);
< 	if (ret < 0) {
< 		printk(KERN_ERR
< 		       "[ERROR] %s():%d read CBUS_INT_STATUS_2_REG failed !\n",
< 		       __func__, __LINE__);
< 		goto i2c_error_exit;
< 	}
< 
< 	ret = cbus_write_reg(sii9234, CBUS_INT_STATUS_1_REG, 0xFF);
< 	if (ret < 0) {
< 		printk(KERN_ERR
< 		       "[ERROR] %s():%d write CBUS_INT_STATUS_1_REG failed !\n",
< 		       __func__, __LINE__);
< 		goto i2c_error_exit;
< 	}
---
> #ifdef	CONFIG_MHL_DEBUG
> 	cbus_read_reg(sii9234, CBUS_INT_STATUS_1_REG, &cbus_intr1);
> 	cbus_read_reg(sii9234, CBUS_INT_STATUS_2_REG, &cbus_intr2);
> 	cbus_read_reg(sii9234, CBUS_INT_1_MASK, &cbus_intr1_enable);
> 	cbus_read_reg(sii9234, CBUS_INT_2_MASK, &cbus_intr2_enable);
2532,2538c2725,2726
< 	ret = cbus_write_reg(sii9234, CBUS_INT_STATUS_2_REG, 0xFF);
< 	if (ret < 0) {
< 		printk(KERN_ERR
< 		       "[ERROR] %s():%d write CBUS_INT_STATUS_2_REG failed !\n",
< 		       __func__, __LINE__);
< 		goto i2c_error_exit;
< 	}
---
> 	cbus_read_reg(sii9234, CBUS_MHL_INTR_REG_0, &intr_reg0);
> 	cbus_read_reg(sii9234, CBUS_MHL_INTR_REG_1, &intr_reg1);
2540,2544c2728,2735
< 	pr_debug("sii9234: irq intr1(%02x/%02x)"
< 		" intr4(%02x/%02x) cbus(%02x/%02x\n)",
< 			intr1, intr1_en,
< 			intr4, intr4_en,
< 			cbus_intr1, cbus_intr2);
---
> 	pr_debug("%s(): irq intr1(%02x/%02x) intr4(%02x/%02x)"
> 		" cbus1(%02x/%02x) cbus2(%02x/%02x) cbus_mhl(%02x/%02x)\n",
> 		__func__, intr1, intr1_en, intr4, intr4_en,
> 		cbus_intr1, cbus_intr1_enable, cbus_intr2,
> 		cbus_intr2_enable, intr_reg0, intr_reg1);
> #else
> 	pr_debug("%s(): irq %02x/%02x %02x/%02x\n", __func__, intr1, intr1_en,
> 		 intr4, intr4_en);
2547c2738
< 	if (intr4 & RGND_READY_INT) {
---
> 	if (intr4 & RGND_READY_INT) { /* 1<<6 */
2553a2745,2746
> 		pr_debug("%s(): RGND_READY_INT, TX_STAT2=0x%x\n",
> 			__func__, value);
2557c2750
< 			pr_debug("sii9234: RGND Open\n");
---
> 			pr_debug("%s(): RGND Open\n", __func__);
2559,2560d2751
< 			memset(sii9234->cbus_pkt_buf, 0x00,
< 					sizeof(sii9234->cbus_pkt_buf));
2563,2565c2754
< 			pr_debug("sii9234: RGND 1K\n");
< /*After applying RGND patch, there is some issue about discovry failure
< this poin is add to fix that problem*/
---
> 			pr_debug("%s(): RGND 1K\n", __func__);
2574,2575c2763,2765
< 
< 			mhl_tx_write_reg(sii9234, MHL_TX_DISC_CTRL5_REG, 0x77);
---
> 			/* refer to D2 */
> 			ret = mhl_tx_write_reg(sii9234,
> 				MHL_TX_DISC_CTRL5_REG, 0x77);
2583c2773,2774
< 			mhl_tx_set_reg(sii9234, MHL_TX_DISC_CTRL6_REG, 0x05);
---
> 			ret = mhl_tx_set_reg(sii9234,
> 				MHL_TX_DISC_CTRL6_REG, 0x05);
2603,2604c2794,2795
< 			cbus_write_reg(sii9234, CBUS_INTR1_ENABLE_REG, 0);
< 			cbus_write_reg(sii9234, CBUS_INTR2_ENABLE_REG, 0);
---
> 			cbus_write_reg(sii9234, CBUS_INT_1_MASK, 0);
> 			cbus_write_reg(sii9234, CBUS_INT_2_MASK, 0);
2606d2796
< 
2608c2798
< 			pr_debug("sii9234: RGND 2K\n");
---
> 			pr_debug("%s(): RGND 2K\n", __func__);
2610,2611d2799
< 			memset(sii9234->cbus_pkt_buf, 0x00,
< 					sizeof(sii9234->cbus_pkt_buf));
2614c2802
< 			pr_debug("sii9234: RGND Short\n");
---
> 			pr_debug("%s(): RGND Short\n", __func__);
2616,2617d2803
< 			memset(sii9234->cbus_pkt_buf, 0x00,
< 					sizeof(sii9234->cbus_pkt_buf));
2619,2665c2805,2808
< 		};
< 
< 		if (sii9234->rgnd != RGND_1K) {
< 			printk(KERN_INFO
< 				"%s() rgnd is not 1K. power off\n", __func__);
< 			mhl_poweroff = 1; /*Power down mhl chip*/
< 			goto err_exit;
< 		}
< 	}
< 
< 	if (intr1 & RSEN_CHANGE_INT) {
< 		ret = mhl_tx_read_reg(sii9234, MHL_TX_SYSSTAT_REG, &value);
< 		if (ret < 0) {
< 			pr_info("sii9234: MHL_TX_SYSSTAT_REG read error\n");
< 			goto err_exit;
< 		}
< 		sii9234->rsen = value & RSEN_STATUS;
< 
< 		if (value & RSEN_STATUS) {
< 			pr_info("sii9234: MHL cable connected.. RSEN High\n");
< 		} else {
< 			pr_info("sii9234: RSEN lost -");
< 			/* Once RSEN loss is confirmed,we need to check
< 			 * based on cable status and chip power status,whether
< 			 * it is SINK Loss(HDMI cable not connected, TV Off)
< 			 * or MHL cable disconnection
< 			 */
< 			/* mhl_disconnection(); */
< 			msleep(T_SRC_RXSENSE_DEGLITCH);
< 			ret = mhl_tx_read_reg(sii9234, MHL_TX_SYSSTAT_REG,
< 								 &value);
< 			pr_cont(" sys_stat: %x\n", value);
< 
< 			if ((value & RSEN_STATUS) == 0) {
< 				if (sii9234->claimed == true)
< 					retry_detection = true;
< 
< 				memset(sii9234->cbus_pkt_buf, 0x00,
< 					sizeof(sii9234->cbus_pkt_buf));
< 
< 				printk(KERN_INFO
< 					"%s() RSEN lost. tmds disable, power down\n",
< 					__func__);
< 				sii9234_tmds_control(sii9234, false);
< 				mhl_poweroff = 1; /*Power down mhl chip */
< 				goto i2c_error_exit;
< 			}
---
> 		default:
> 			pr_err("[ERROR] %s() unknown state : 0x%x\n",
> 				__func__, value);
> 			break;
2669,2670c2812,2813
< 	if (intr4 & CBUS_LKOUT_INT) {
< 		pr_debug("sii9234: CBUS Lockout Interrupt\n");
---
> 	if (intr4 & CBUS_LKOUT_INT) { /* 1<<4 */
> 		pr_debug("%s(): CBUS Lockout Interrupt\n", __func__);
2674,2675c2817,2818
< 	if (intr4 & MHL_DISC_FAIL_INT) {
< 		printk(KERN_ERR	"[ERROR]	sii9234: MHL_DISC_FAIL_INT\n");
---
> 	if (intr4 & MHL_DISC_FAIL_INT) { /* 1<<3 */
> 		printk(KERN_ERR	"[ERROR] %s(): MHL_DISC_FAIL_INT\n", __func__);
2677,2678d2819
< 		memset(sii9234->cbus_pkt_buf, 0x00,
< 					sizeof(sii9234->cbus_pkt_buf));
2681,2688c2822,2823
< 	if (intr4 & MHL_EST_INT) {
< 		pr_debug("sii9234: mhl est interrupt %d\n", value);
< 		/* work_around code for 1K & USB_OPEN TEST */
< 		if (!sii9234->rsen) {
< 			pr_info("sii9234: EST_INT without RSEN_HIGH\n");
< 			mhl_poweroff = 1;
< 			goto err_exit;
< 		}
---
> 	if (intr4 & MHL_EST_INT) { /* 1<<2 */
> 		pr_debug("%s(): mhl est interrupt\n", __func__);
2726,2727c2861,2862
< 		cbus_command_request(sii9234, CBUS_SET_INT,
< 					 MHL_RCHANGE_INT, MHL_INT_DCAP_CHG);
---
> 		sii9234_enqueue_msc_work(sii9234, CBUS_SET_INT, MHL_RCHANGE_INT,
> 						MHL_INT_DCAP_CHG, 0x0);
2732c2867
< 		cbus_write_reg(sii9234, CBUS_INTR1_ENABLE_REG,
---
> 		cbus_write_reg(sii9234, CBUS_INT_1_MASK,
2734c2869
< 		cbus_write_reg(sii9234, CBUS_INTR2_ENABLE_REG,
---
> 		cbus_write_reg(sii9234, CBUS_INT_2_MASK,
2739c2874
< 	if (intr1 & HPD_CHANGE_INT) {
---
> 	if (intr1 & HPD_CHANGE_INT) { /* 1<<6 */
2743,2744c2878,2879
< 			pr_info("sii9234: hpd high\n");
< 			/* Downstream HPD Highi */
---
> 			pr_info("%s() hpd high\n", __func__);
> 
2746,2760c2881,2883
< 			/* Do we need to send HPD upstream using
< 			 * Register 0x79(page0)? Is HPD need to be overriden??
< 			 *      TODO: See if we need code for overriding HPD OUT
< 			 *      as per Page 0,0x79 Register
< 			 */
< 			sii9234->mhl_status_value.sink_hpd = true;
< 			ret = cbus_command_request(sii9234, CBUS_WRITE_STAT,
< 					CBUS_LINK_CONTROL_2_REG,
< 					sii9234->mhl_status_value.linkmode);
< 			if (ret < 0) {
< 				printk(KERN_ERR
< 				       "[ERROR] %s():%d cbus_command_request failed !\n",
< 				       __func__, __LINE__);
< 				goto i2c_error_exit;
< 			}
---
> 			sii9234_enqueue_msc_work(sii9234, CBUS_WRITE_STAT,
> 						CBUS_LINK_CONTROL_2_REG,
> 						sii9234->link_mode, 0x0);
2762d2884
< 
2771c2893
< 			pr_debug("sii9234: %s() MHL HPD High, enabled TMDS\n",
---
> 			pr_debug("%s(): MHL HPD High, enabled TMDS\n",
2775,2782c2897
< 			pr_info("sii9234: hpd low\n");
< 			/*Downstream HPD Low*/
< 
< 			/* Similar to above comments.
< 			 * TODO:Do we need to override HPD OUT value
< 			 * and do we need to disable TMDS here?
< 			 */
< 			sii9234->mhl_status_value.sink_hpd = false;
---
> 			pr_info("%s(): hpd low\n", __func__);
2794,2799c2909,2910
< #ifdef	CONFIG_SII9234_CBUS
< 	/*
< 	 * Process CBUS interrupts only when MHL connection has been
< 	 * established
< 	 */
< 	if (sii9234->state == STATE_ESTABLISHED) {
---
> 	if (intr1 & RSEN_CHANGE_INT) { /* 1<<5 */
> 		ret = mhl_tx_read_reg(sii9234, MHL_TX_SYSSTAT_REG, &value);
2801,2802c2912,2934
< 		if (cbus_intr1 & MSC_RESP_ABORT)
< 			cbus_resp_abort_error(sii9234);
---
> 		sii9234->rsen = value & RSEN_STATUS;
> 
> 		if (value & RSEN_STATUS) {
> 			pr_info("%s(): MHL cable connected.. RSEN High\n",
> 				__func__);
> 		} else {
> 			pr_info("%s(): RSEN lost\n", __func__);
> 			/* Once RSEN loss is confirmed,we need to check
> 			 * based on cable status and chip power status,whether
> 			 * it is SINK Loss(HDMI cable not connected, TV Off)
> 			 * or MHL cable disconnection
> 			 */
> 			usleep_range(T_SRC_RXSENSE_DEGLITCH * USEC_PER_MSEC,
> 					T_SRC_RXSENSE_DEGLITCH * USEC_PER_MSEC);
> 			ret = mhl_tx_read_reg(sii9234, MHL_TX_SYSSTAT_REG,
> 								 &value);
> 			if (ret < 0) {
> 				printk(KERN_ERR
> 					"[ERROR] %s() read MHL_TX_SYSSTAT_REG\n",
> 					__func__);
> 				goto err_exit;
> 			}
> 			pr_info("%s(): sys_stat: %x ~\n", __func__, value);
2804,2805c2936,2938
< 		if (cbus_intr1 & MSC_REQ_ABORT)
< 			cbus_req_abort_error(sii9234);
---
> 			if ((value & RSEN_STATUS) == 0)	{
> 				printk(KERN_INFO
> 					"%s() RSEN Really LOW ~\n", __func__);
2807,2815c2940,2941
< 		if ((cbus_intr1 & CBUS_DDC_ABORT) ||
< 					 (cbus_intr1 & MSC_RESP_ABORT)) {
< 			pr_debug("sii9234: CBUS DDC abort\n");
< 			if (cbus_ddc_abort_error(sii9234)) {
< 				printk(KERN_ERR "[ERROR] %s():%d cbus_ddc_abort_error\n",
< 					__func__, __LINE__);
< 				if (sii9234->claimed == true)
< 					retry_detection = true;
< 				mhl_poweroff = 1; /*Power down mhl chip */
---
> 				sii9234_tmds_control(sii9234, false);
> 				mhl_poweroff = true;
2818a2945
> 	}
2820,2828c2947,2949
< 		if (cbus_intr1 & MSC_REQ_DONE) {
< 			pr_debug("sii9234: CBUS cmd ACK Received\n");
< 			cbus_resp_callback = cbus_command_response_all;
< 		}
< #ifdef CONFIG_SII9234_RCP
< 		if (cbus_intr1 & MSC_MSG_RECD) {
< 			pr_debug("sii9234: MSC MSG Received\n");
< 			cbus_handle_msc_msg(sii9234);
< 		}
---
> #ifdef	CONFIG_SII9234_CBUS
> 	if (sii9234->state == STATE_ESTABLISHED)
> 		sii9234_cbus_irq(sii9234);
2831,2845c2952,2954
< 		if (cbus_intr1 & MSC_REQ_DONE) {
< 			pr_debug("sii9234: MSC_REQ_DONE(ACK) Received\n");
< 			cbus_read_reg(sii9234, CBUS_MHL_INTR_REG_1, &value);
< 			if (!(value & MHL_INT_EDID_CHG))
< 				cbus_resp_callback = cbus_command_response_all;
< 		}
< 
< 		/* ignore WRT_STAT_RECD interrupt when we get HPD CHANGE */
< 		if (cbus_intr2 & WRT_STAT_RECD && intr1 == 0)
< 			cbus_handle_wrt_stat_recd(sii9234);
< 
< 		if (cbus_intr2 & SET_INT_RECD)
< 			cbus_handle_set_int_recd(sii9234);
< 	}
< #endif /* CONFIG_SII9234_CBUS */
---
> err_exit:
> 	mhl_tx_write_reg(sii9234, MHL_TX_INTR1_REG, intr1);
> 	mhl_tx_write_reg(sii9234, MHL_TX_INTR4_REG, intr4);
2847,2853c2956
<  err_exit:
< 	ret = mhl_tx_write_reg(sii9234, MHL_TX_INTR1_REG, intr1);
< 	if (ret < 0) {
< 		printk(KERN_ERR "[ERROR] %s():%d write MHL_TX_INTR1_REG\n",
< 		       __func__, __LINE__);
< 		goto i2c_error_exit;
< 	}
---
> 	mutex_unlock(&sii9234->lock);
2855,2867c2958,2959
< 	ret = mhl_tx_write_reg(sii9234, MHL_TX_INTR4_REG, intr4);
< 	if (ret < 0) {
< 		printk(KERN_ERR "[ERROR] %s():%d write MHL_TX_INTR4_REG\n",
< 		       __func__, __LINE__);
< 		goto i2c_error_exit;
< 	}
<  #ifdef	CONFIG_SII9234_CBUS
< 	ret = cbus_write_reg(sii9234, CBUS_INT_STATUS_1_REG, cbus_intr1);
< 	if (ret < 0) {
< 		printk(KERN_ERR "[ERROR] %s():%d write CBUS_INT_STATUS_1_REG\n",
< 		       __func__, __LINE__);
< 		goto i2c_error_exit;
< 	}
---
> 	pr_debug("%s(): wake_up\n", __func__);
> 	wake_up(&sii9234->wq);
2869,2875c2961
< 	ret = cbus_write_reg(sii9234, CBUS_INT_STATUS_2_REG, cbus_intr2);
< 	if (ret < 0) {
< 		printk(KERN_ERR "[ERROR] %s():%d write CBUS_INT_STATUS_2_REG\n",
< 		       __func__, __LINE__);
< 		goto i2c_error_exit;
< 	}
< #endif
---
> 	return IRQ_HANDLED;
2880c2966
< 	pr_info("sii9234: wake_up\n");
---
> 	pr_info("%s(): wake_up\n", __func__);
2883,2885d2968
< 	if (cbus_resp_callback)
< 		cbus_resp_callback(sii9234);
< 
2887c2970
< 		printk(KERN_INFO	"%s() mhl_poweroff\n", __func__);
---
> 		printk(KERN_INFO "%s() mhl_poweroff\n", __func__);
2890,2895d2972
< /* need to more test */
< /*
< 	if (retry_detection) {
< 		printk(KERN_INFO	"%s() retry_detection\n", __func__);
< 
< 		sii9234_mhl_detection_sched();
2897,2898d2973
< 	}
< */
2918c2993
< 	pr_info("sel_show sii_id: %X\n", sii_id);
---
> 	pr_info("sii9234: %s() sel_show sii_id: %X\n", __func__, sii_id);
2932,2945d3006
< static ssize_t sysfs_ddc_i2c_num_show(struct class *class,
< 	struct class_attribute *attr, char *buf)
< {
< 	int size;
< 	struct sii9234_data *sii9234 = dev_get_drvdata(sii9244_mhldev);
< 
< 	pr_info("ddc_i2c_num : %d\n", sii9234->pdata->ddc_i2c_num);
< 	size = sprintf(buf, "DDC %d\n", sii9234->pdata->ddc_i2c_num);
< 
< 	return size;
< }
< 
< static CLASS_ATTR(ddc_i2c_num, 0664 , sysfs_ddc_i2c_num_show, NULL);
< 
2949c3010
< 	pr_info("sysfs_mhl_read_reg_show\n");
---
> 	pr_info("sii9234: %s()\n", __func__);
2963a3025
> 	char *token;
2966c3028
< 		pr_info("Error : Unsupported format\n");
---
> 		pr_info("sii9234: Error : Unsupported format\n");
2971c3033
< 		printk(KERN_INFO	"%s() - mhl start\n", __func__);
---
> 		printk(KERN_INFO "sii9234: %s() - mhl start\n", __func__);
2975c3037,3044
< 	strcpy(dest, strsep(&buffer, ":"));
---
> 	token = strsep(&buffer, ":");
> 	if (token != NULL)
> 		strcpy(dest, token);
> 	else {
> 		pr_info("sii9234: Error: command parsing error\n");
> 		return size;
> 	}
> 
2978c3047
< 		pr_info("Error : Page number\n");
---
> 		pr_info("sii9234: Error : Page number\n");
2986c3055
< 		pr_info("Error : Offset number\n");
---
> 		pr_info("sii9234: Error : Offset number\n");
3004c3073
< 		pr_info("\nError : Out of the page number range\n");
---
> 		pr_info("\nsii9234: Error : Out of the page number range\n");
3007c3076
< 	pr_info("[sii9234] MHL register Page%d:0x%02x = 0x%02x\n", pn, offset,
---
> 	pr_info("sii9234: MHL register Page%d:0x%02x = 0x%02x\n", pn, offset,
3019a3089,3106
> #ifdef CONFIG_MACH_MIDAS
> void sii9234_wake_lock(void)
> {
> 	struct sii9234_data *sii9234 = dev_get_drvdata(sii9244_mhldev);
> 	wake_lock(&sii9234->wlock);
> 	pr_debug("%s()\n", __func__);
> }
> EXPORT_SYMBOL(sii9234_wake_lock);
> 
> void sii9234_wake_unlock(void)
> {
> 	struct sii9234_data *sii9234 = dev_get_drvdata(sii9244_mhldev);
> 	wake_unlock(&sii9234->wlock);
> 	pr_debug("%s()\n", __func__);
> }
> EXPORT_SYMBOL(sii9234_wake_unlock);
> #endif
> 
3071c3158
< 	mutex_init(&sii9234->cbus_lock);
---
> 	mutex_init(&sii9234->msc_lock);
3091c3178,3187
< 	pr_info("create mhl sysfile\n");
---
> 	sii9234_msc_wq = create_singlethread_workqueue("sii9234_msc_wq");
> 	if (!sii9234_msc_wq) {
> 		printk(KERN_ERR
> 		       "[ERROR] %s() workqueue create fail\n", __func__);
> 		ret = -ENOMEM;
> 		goto err_exit1b;
> 	}
> 	INIT_WORK(&sii9234->msc_work, sii9234_process_msc_work);
> 
> 	pr_info("%s(): create mhl sysfile\n", __func__);
3100,3105d3195
< 	ret = class_create_file(sec_mhl, &class_attr_ddc_i2c_num);
< 	if (ret) {
< 		pr_err("Failed to create device file in sysfs entries!\n");
< 		ret = -ENOMEM;
< 		goto err_exit2;
< 	}
3111c3201
< 		goto err_exit2a;
---
> 		goto err_exit2;
3115,3117d3204
< 	sii9234->cbus_pkt.command = CBUS_IDLE;
< 	sii9234->cbus_pkt.offset = DEVCAP_DEV_STATE;
< 
3134a3222,3226
> #ifdef CONFIG_MACH_MIDAS
> 	wake_lock_init(&sii9234->wlock, WAKE_LOCK_SUSPEND, "mhl_wake_lock");
> 	pr_debug("%s(): wake lock is initialized.\n", __func__);
> #endif
> 
3146c3238,3241
< 
---
> #ifdef CONFIG_SAMSUNG_MHL_9290
> 	sii9234->acc_con_nb.notifier_call = sii9234_30pin_callback;
> 	acc_register_notifier(&sii9234->acc_con_nb);
> #endif
3158,3161d3252
< 
<  err_exit2a:
< 	class_remove_file(sec_mhl, &class_attr_ddc_i2c_num);
< 
3172c3263
< 	mutex_destroy(&sii9234->cbus_lock);
---
> 	mutex_destroy(&sii9234->msc_lock);
3351a3443
> 
diff -r update5/drivers/media/video/samsung/tvout/s5p_tvout.c update6/drivers/media/video/samsung/tvout/s5p_tvout.c
67c67
< int hdmi_audio_ext;
---
> bool hdmi_audio_ext;
83c83
< 	unsigned long value = !strncmp(buf, "1", 1) ? true : false;
---
> 	bool value = !strncmp(buf, "1", 1) ? true : false;
85c85
< 	printk(KERN_ERR "[HDMI] Change AUDIO PATH: %ld\n", value);
---
> 	printk(KERN_ERR "[HDMI] Change AUDIO PATH: %d\n", (int)value);
87,92c87,94
< 	if (value) {
< 		s5p_hdmi_ctrl_set_audio(1);
< 		hdmi_audio_ext = 0;
< 	} else {
< 		s5p_hdmi_ctrl_set_audio(0);
< 		hdmi_audio_ext = 1;
---
> 	if (value == hdmi_audio_ext) {
> 		if (value) {
> 			hdmi_audio_ext = 0;
> 			s5p_hdmi_ctrl_set_audio(1);
> 		} else {
> 			hdmi_audio_ext = 1;
> 			s5p_hdmi_ctrl_set_audio(0);
> 		}
441a444,445
> 
> 	hdmi_audio_ext = false;
diff -r update5/drivers/media/video/samsung/tvout/s5p_tvout_v4l2.c update6/drivers/media/video/samsung/tvout/s5p_tvout_v4l2.c
382c382,384
< 
---
> #ifdef CONFIG_HAS_EARLYSUSPEND
> 		s5p_tvout_mutex_unlock();
> #endif
diff -r update5/drivers/net/wireless/bcmdhd/Kconfig update6/drivers/net/wireless/bcmdhd/Kconfig
13a14,19
> config BCM43241
> 	tristate "---Broadcom WiFi Driver for 43241"
> 	depends on WLAN
> 	---help---
> 		Select this option to build Broadcom wlan driver
> 
16c22
< 	depends on (BCM4330 || BCM4334)
---
>     depends on (BCM4330 || BCM4334 || BCM43241)
18a25,43
> 
> config WLAN_COUNTRY_CODE
> 	tristate "---Broadcom WiFi Driver for 5GH channel setting"
>    	depends on WLAN
>    	default	n
> 
> config WLAN_REGION_CODE
> 	int "---Region codes for Broadcom WiFi Driver"
> 	depends on (BCM4330 || BCM4334 || BCM43241)
> 	default 100
> 	---help---
> 		This is a region code for Broadcom Wi-Fi featured functions.
> 		- 100 : EUR OPEN
> 		- 101 : EUR ORG
> 		- 200 : KOR OPEN
> 		- 201 : KOR SKT
> 		- 202 : KOR KTT
> 		- 203 : KOR LGT
> 		- 300 : CHN OPEN
diff -r update5/drivers/net/wireless/bcmdhd/Makefile update6/drivers/net/wireless/bcmdhd/Makefile
4c4
<         -DDHDTHREAD -DDHD_GPL -DDHD_SCHED -DDHD_DEBUG -DSDTEST -DBDC -DTOE    \
---
>         -DDHDTHREAD -DDHD_GPL -DDHD_SCHED -DDHD_DEBUG -DBDC -DTOE    \
14c14
< DHDCFLAGS += -DHW_OOB -DBCM4334_CHECK_CHIP_REV
---
> DHDCFLAGS += -DBCM4334_CHIP -DHW_OOB -DBCM4334_CHECK_CHIP_REV
16a17,19
> DHDCFLAGS += -DVSDB -DHT40_GO
> DHDCFLAGS += -DWL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
> DHDCFLAGS += -DDHD_USE_IDLECOUNT
19c22
< DHDCFLAGS += -DHW_OOB -DBCM4334_CHECK_CHIP_REV
---
> DHDCFLAGS += -DBCM4334_CHIP -DHW_OOB -DBCM4334_CHECK_CHIP_REV
21a25,27
> DHDCFLAGS += -DVSDB -DHT40_GO
> DHDCFLAGS += -DWL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
> DHDCFLAGS += -DDHD_USE_IDLECOUNT
25c31,34
< DHDCFLAGS += -DCONFIG_CONTROL_PM -DPOWER_ON_DELAY_4330
---
> DHDCFLAGS += -DBCM4330_CHIP
> DHDCFLAGS += -DMCAST_LIST_ACCUMULATION
> DHDCFLAGS += -DCONFIG_CONTROL_PM
> DHDCFLAGS += -DROAM_ENABLE -DROAM_API -DROAM_CHANNEL_CACHE
29c38,41
< DHDCFLAGS += -DCONFIG_CONTROL_PM -DPOWER_ON_DELAY_4330
---
> DHDCFLAGS += -DBCM4330_CHIP
> DHDCFLAGS += -DMCAST_LIST_ACCUMULATION
> DHDCFLAGS += -DCONFIG_CONTROL_PM
> DHDCFLAGS += -DROAM_ENABLE -DROAM_API -DROAM_CHANNEL_CACHE
31,33c43,46
< 
< ifeq ($(CONFIG_MACH_U1),y)
< DHDCFLAGS += -DUSE_CID_CHECK -DWRITE_MACADDR -DU1_MACADDR
---
> ifeq ($(CONFIG_BCM43241),m)
> DHDCFLAGS += -DBCM43241_CHIP -DHW_OOB
> DHDCFLAGS += -DMCAST_LIST_ACCUMULATION
> DHDCFLAGS += -fno-pic
35,38c48,50
< 
< ifeq ($(CONFIG_TARGET_LOCALE_KOR),y)
< DHDCFLAGS += -DUSE_CID_CHECK -DRDWR_MACADDR -DU1_MACADDR
< DHDCFLAGS += -DROAM_ENABLE -DROAM_API
---
> ifeq ($(CONFIG_BCM43241),y)
> DHDCFLAGS += -DBCM43241_CHIP -DHW_OOB
> DHDCFLAGS += -DMCAST_LIST_ACCUMULATION
41,44c53,67
< ifeq ($(CONFIG_MACH_U1_KOR_KT), y)
< DHDCFLAGS += -DVLAN_MODE_OFF
< DHDCFLAGS += -DKEEP_ALIVE_PACKET_PERIOD_30_SEC
< DHDCFLAGS += -DFULL_ROAMING_SCAN_PERIOD_60_SEC
---
> # For p2p connection issue
> DHDCFLAGS += -DWL_CFG80211_GON_COLLISION
> DHDCFLAGS += -DWL_CFG80211_SYNC_GON_TIME
> #end p2p connection
> 
> 
> # For Passing all multicast packets to host when not in suspend mode.
> DHDCFLAGS += -DPASS_ALL_MCAST_PKTS
> DHDCFLAGS += -DUSE_INITIAL_2G_SCAN
> 
> # For Scan result patch
> DHDCFLAGS += -DESCAN_RESULT_PATCH
> 
> ifeq ($(CONFIG_MACH_SAMSUNG_T1),y)
> DHDCFLAGS += -DUSE_CID_CHECK -DWRITE_MACADDR
46a70,71
> DHDCFLAGS += -DROAM_ENABLE -DROAM_CHANNEL_CACHE -DROAM_API
> 
51a77,90
> # CCX feture is enable for U1 PROD
> DHDCFLAGS += -DBCMCCX
> 
> # For SLP feature
> ifeq ($(CONFIG_SLP),y)
> DHDCFLAGS += -DSLP_PATH -DWRITE_MACADDR
> endif
> 
> # 5GHz channels setting
> ifeq ($(CONFIG_WLAN_COUNTRY_CODE),y)
> DHDCFLAGS += -DGLOBALCONFIG_WLAN_COUNTRY_CODE
> endif
> 
> # For ICS SEC Features
55,56c94,101
< ifeq ($(SEC_REGION),CHN)
< DHDCFLAGS += -DBCMWAPI_WPI -DBCMWAPI_WAI
---
> 
> ##############################################################
> # dhd_sec_feature.h
> 
> REGION_CODE := $(CONFIG_WLAN_REGION_CODE)
> 
> ifeq ($(CONFIG_TARGET_LOCALE_KOR),y)
> REGION_CODE=200
59,61c104,105
< # For SLP feature
< ifeq ($(CONFIG_SLP),y)
< DHDCFLAGS += -DSLP_PATH
---
> ifeq ($(CONFIG_MACH_U1_KOR_KT), y)
> REGION_CODE=202
63a108,121
> ifeq ($(CONFIG_TARGET_LOCALE_CHN),y)
> REGION_CODE=300
> endif
> 
> ifeq ($(SEC_MODEL_NAME),U1)
> ifeq ($(X_BUILD_LOCALE),EUR_ORG)
> REGION_CODE=101
> endif
> endif
> 
> DHDCFLAGS += -DWLAN_REGION_CODE=$(REGION_CODE)
> 
> ##############################################################
> 
65c123
< EXTRA_CFLAGS += $(DHDCFLAGS) -DWL_CFG80211
---
> EXTRA_CFLAGS += $(DHDCFLAGS) -DWL_CFG80211 -DRSSI_OFFSET=0
73a132,133
> EXTRA_CFLAGS += -I$(src)/src/wl/bcmwifi/src/
> EXTRA_CFLAGS += -I$(src)/src/wl/bcmwifi/include/
88c148
< 	 src/shared/bcmutils.o		src/shared/bcmwifi.o \
---
> 	 src/shared/bcmutils.o		src/wl/bcmwifi/src/bcmwifi_channels.o \
93c153
< 	 src/wl/sys/wl_linux_mon.o
---
> 	 src/wl/sys/wl_linux_mon.o	src/wl/sys/wl_roam.o
114c174,176
<         src/wl/sys/.*.o.cmd
---
> 	src/wl/sys/.*.o.cmd \
> 	src/wl/bcmwifi/src/bcmwifi_channels.o \
> 	src/wl/bcmwifi/src/.*.o.cmd
diff -r update5/drivers/net/wireless/bcmdhd/src/bcmsdio/sys/bcmsdh_linux.c update6/drivers/net/wireless/bcmdhd/src/bcmsdio/sys/bcmsdh_linux.c
150,160d149
< static struct device_driver bcmsdh_driver = {
< 	.name		= "pxa2xx-mci",
< 	.bus		= &platform_bus_type,
< 	.probe		= bcmsdh_probe,
< 	.remove		= bcmsdh_remove,
< 	.suspend	= NULL,
< 	.resume		= NULL,
< 	};
< #endif /* BCMLXSDMMC */
< 
< #ifndef BCMLXSDMMC
525a515,532
> extern int sdio_func_reg_notify(void* semaphore);
> extern void sdio_func_unreg_notify(void);
> 
> #if defined(BCMLXSDMMC)
> int bcmsdh_reg_sdio_notify(void* semaphore)
> {
> 
> 	return sdio_func_reg_notify(semaphore);
> 
> }
> 
> void bcmsdh_unreg_sdio_notify(void)
> {
> 	sdio_func_unreg_notify();
> 
> }
> #endif /* defined(BCMLXSDMMC) */
> 
534d540
< #if defined(BCMLXSDMMC)
537,540d542
< #else
< 	SDLX_MSG(("Intel PXA270 SDIO Driver\n"));
< 	error = driver_register(&bcmsdh_driver);
< #endif /* defined(BCMLXSDMMC) */
568,570d569
< #if defined(BCMPLATFORM_BUS) && !defined(BCMLXSDMMC)
< 		driver_unregister(&bcmsdh_driver);
< #endif
573a573
> 
575c575
< 		pci_unregister_driver(&bcmsdh_pci_driver);
---
> 	pci_unregister_driver(&bcmsdh_pci_driver);
641,646d640
< void *bcmsdh_get_drvdata(void)
< {
< 	if (!sdhcinfo)
< 		return NULL;
< 	return dev_get_drvdata(sdhcinfo->dev);
< }
670a665,673
> }
> #endif /* defined(OOB_INTR_ONLY) */
> 
> #if defined(BCMLXSDMMC)
> void *bcmsdh_get_drvdata(void)
> {
> 	if (!sdhcinfo)
> 		return NULL;
> 	return dev_get_drvdata(sdhcinfo->dev);
diff -r update5/drivers/net/wireless/bcmdhd/src/bcmsdio/sys/bcmsdh_sdmmc.c update6/drivers/net/wireless/bcmdhd/src/bcmsdio/sys/bcmsdh_sdmmc.c
4c4
<  * Copyright (C) 1999-2011, Broadcom Corporation
---
>  * Copyright (C) 1999-2012, Broadcom Corporation
24c24
<  * $Id: bcmsdh_sdmmc.c 301795 2011-12-08 20:41:47Z $
---
>  * $Id: bcmsdh_sdmmc.c 309548 2012-01-20 01:13:08Z $
37a38
> #include <linux/mmc/card.h>
150a152
> 	sd->use_rxchain = FALSE;
514c516
< 		int_val = FALSE;
---
> 		int_val = (int32)si->use_rxchain;
804,811c806,815
< 				sdio_claim_host(gInstance->func[func]);
< 				/*
< 				* this sdio_f0_writeb() can be replaced with another api
< 				* depending upon MMC driver change.
< 				* As of this time, this is temporaray one
< 				*/
< 				sdio_writeb(gInstance->func[func], *byte, regaddr, &err_ret);
< 				sdio_release_host(gInstance->func[func]);
---
> 				if (gInstance->func[func]){
> 					sdio_claim_host(gInstance->func[func]);
> 					/*
> 					* this sdio_f0_writeb() can be replaced with another api
> 					* depending upon MMC driver change.
> 					* As of this time, this is temporaray one
> 					*/
> 					sdio_writeb(gInstance->func[func], *byte, regaddr, &err_ret);
> 					sdio_release_host(gInstance->func[func]);
> 				}
818,820c822,826
< 				sdio_claim_host(gInstance->func[func]);
< 				sdio_f0_writeb(gInstance->func[func], *byte, regaddr, &err_ret);
< 				sdio_release_host(gInstance->func[func]);
---
> 				if (gInstance->func[func]){
> 					sdio_claim_host(gInstance->func[func]);
> 					sdio_f0_writeb(gInstance->func[func], *byte, regaddr, &err_ret);
> 					sdio_release_host(gInstance->func[func]);
> 				}
824,826c830,834
< 			sdio_claim_host(gInstance->func[func]);
< 			sdio_writeb(gInstance->func[func], *byte, regaddr, &err_ret);
< 			sdio_release_host(gInstance->func[func]);
---
> 			if (gInstance->func[func]){
> 				sdio_claim_host(gInstance->func[func]);
> 				sdio_writeb(gInstance->func[func], *byte, regaddr, &err_ret);
> 				sdio_release_host(gInstance->func[func]);
> 			}
830c838,839
< 		sdio_claim_host(gInstance->func[func]);
---
> 		if (gInstance->func[func]){
> 			sdio_claim_host(gInstance->func[func]);
832,836c841,845
< 		if (func == 0) {
< 			*byte = sdio_f0_readb(gInstance->func[func], regaddr, &err_ret);
< 		} else {
< 			*byte = sdio_readb(gInstance->func[func], regaddr, &err_ret);
< 		}
---
> 			if (func == 0) {
> 				*byte = sdio_f0_readb(gInstance->func[func], regaddr, &err_ret);
> 			} else {
> 				*byte = sdio_readb(gInstance->func[func], regaddr, &err_ret);
> 			}
838c847,848
< 		sdio_release_host(gInstance->func[func]);
---
> 			sdio_release_host(gInstance->func[func]);
> 		}
904,905c914,919
< 
< 	void *pnext;
---
> 	void *pnext, *pprev;
> 	uint ttl_len, dma_len, lft_len, xfred_len, pkt_len;
> 	uint blk_num;
> 	struct mmc_request mmc_req;
> 	struct mmc_command mmc_cmd;
> 	struct mmc_data mmc_dat;
913,918c927,939
< 	/* Claim host controller */
< 	sdio_claim_host(gInstance->func[func]);
< 	for (pnext = pkt; pnext; pnext = PKTNEXT(sd->osh, pnext)) {
< 		uint pkt_len = PKTLEN(sd->osh, pnext);
< 		pkt_len += 3;
< 		pkt_len &= 0xFFFFFFFC;
---
> 	ttl_len = xfred_len = 0;
> 	/* at least 4 bytes alignment of skb buff is guaranteed */
> 	for (pnext = pkt; pnext; pnext = PKTNEXT(sd->osh, pnext))
> 		ttl_len += PKTLEN(sd->osh, pnext);
> 
> 	if (!sd->use_rxchain || ttl_len <= sd->client_block_size[func]) {
> 		blk_num = 0;
> 		dma_len = 0;
> 	} else {
> 		blk_num = ttl_len / sd->client_block_size[func];
> 		dma_len = blk_num * sd->client_block_size[func];
> 	}
> 	lft_len = ttl_len - dma_len;
920,948c941,966
< #ifdef CONFIG_MMC_MSM7X00A
< 		if ((pkt_len % 64) == 32) {
< 			sd_trace(("%s: Rounding up TX packet +=32\n", __FUNCTION__));
< 			pkt_len += 32;
< 		}
< #endif /* CONFIG_MMC_MSM7X00A */
< 		/* Make sure the packet is aligned properly. If it isn't, then this
< 		 * is the fault of sdioh_request_buffer() which is supposed to give
< 		 * us something we can work with.
< 		 */
< 		ASSERT(((uint32)(PKTDATA(sd->osh, pkt)) & DMA_ALIGN_MASK) == 0);
< 
< 		if ((write) && (!fifo)) {
< 			err_ret = sdio_memcpy_toio(gInstance->func[func], addr,
< 				((uint8*)PKTDATA(sd->osh, pnext)),
< 				pkt_len);
< 		} else if (write) {
< 			err_ret = sdio_memcpy_toio(gInstance->func[func], addr,
< 				((uint8*)PKTDATA(sd->osh, pnext)),
< 				pkt_len);
< 		} else if (fifo) {
< 			err_ret = sdio_readsb(gInstance->func[func],
< 				((uint8*)PKTDATA(sd->osh, pnext)),
< 				addr,
< 				pkt_len);
< 		} else {
< 			err_ret = sdio_memcpy_fromio(gInstance->func[func],
< 				((uint8*)PKTDATA(sd->osh, pnext)),
< 				addr,
---
> 	sd_trace(("%s: %s %dB to func%d:%08x, %d blks with DMA, %dB leftover\n",
> 		__FUNCTION__, write ? "W" : "R",
> 		ttl_len, func, addr, blk_num, lft_len));
> 
> 	if (0 != dma_len) {
> 		memset(&mmc_req, 0, sizeof(struct mmc_request));
> 		memset(&mmc_cmd, 0, sizeof(struct mmc_command));
> 		memset(&mmc_dat, 0, sizeof(struct mmc_data));
> 
> 		/* Set up DMA descriptors */
> 		pprev = pkt;
> 		for (pnext = pkt;
> 		     pnext && dma_len;
> 		     pnext = PKTNEXT(sd->osh, pnext)) {
> 			pkt_len = PKTLEN(sd->osh, pnext);
> 
> 			if (dma_len > pkt_len)
> 				dma_len -= pkt_len;
> 			else {
> 				pkt_len = xfred_len = dma_len;
> 				dma_len = 0;
> 				pkt = pnext;
> 			}
> 
> 			sg_set_buf(&sd->sg_list[SGCount++],
> 				(uint8*)PKTDATA(sd->osh, pnext),
950d967
< 		}
952,961c969,973
< 		if (err_ret) {
< 			sd_err(("%s: %s FAILED %p[%d], addr=0x%05x, pkt_len=%d, ERR=0x%08x\n",
< 				__FUNCTION__,
< 				(write) ? "TX" : "RX",
< 				pnext, SGCount, addr, pkt_len, err_ret));
< 		} else {
< 			sd_trace(("%s: %s xfr'd %p[%d], addr=0x%05x, len=%d\n",
< 				__FUNCTION__,
< 				(write) ? "TX" : "RX",
< 				pnext, SGCount, addr, pkt_len));
---
> 			if (SGCount >= SDIOH_SDMMC_MAX_SG_ENTRIES) {
> 				sd_err(("%s: sg list entries exceed limit\n",
> 					__FUNCTION__));
> 				return (SDIOH_API_RC_FAIL);
> 			}
964,967c976,992
< 		if (!fifo) {
< 			addr += pkt_len;
< 		}
< 		SGCount ++;
---
> 		mmc_dat.sg = sd->sg_list;
> 		mmc_dat.sg_len = SGCount;
> 		mmc_dat.blksz = sd->client_block_size[func];
> 		mmc_dat.blocks = blk_num;
> 		mmc_dat.flags = write ? MMC_DATA_WRITE : MMC_DATA_READ;
> 
> 		mmc_cmd.opcode = 53;		/* SD_IO_RW_EXTENDED */
> 		mmc_cmd.arg = write ? 1<<31 : 0;
> 		mmc_cmd.arg |= (func & 0x7) << 28;
> 		mmc_cmd.arg |= 1<<27;
> 		mmc_cmd.arg |= fifo ? 0 : 1<<26;
> 		mmc_cmd.arg |= (addr & 0x1FFFF) << 9;
> 		mmc_cmd.arg |= blk_num & 0x1FF;
> 		mmc_cmd.flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_ADTC;
> 
> 		mmc_req.cmd = &mmc_cmd;
> 		mmc_req.data = &mmc_dat;
968a994,1012
> 		sdio_claim_host(gInstance->func[func]);
> 		mmc_set_data_timeout(&mmc_dat, gInstance->func[func]->card);
> 		mmc_wait_for_req(gInstance->func[func]->card->host, &mmc_req);
> 		sdio_release_host(gInstance->func[func]);
> 
> 		err_ret = mmc_cmd.error? mmc_cmd.error : mmc_dat.error;
> 		if (0 != err_ret) {
> 			sd_err(("%s:CMD53 %s failed with code %d\n",
> 			       __FUNCTION__,
> 			       write ? "write" : "read",
> 			       err_ret));
> 			sd_err(("%s:Disabling rxchain and fire it with PIO\n",
> 			       __FUNCTION__));
> 			sd->use_rxchain = FALSE;
> 			pkt = pprev;
> 			lft_len = ttl_len;
> 		} else if (!fifo) {
> 			addr = addr + ttl_len - lft_len - dma_len;
> 		}
971,972c1015,1074
< 	/* Release host controller */
< 	sdio_release_host(gInstance->func[func]);
---
> 	/* PIO mode */
> 	if (0 != lft_len) {
> 		/* Claim host controller */
> 		sdio_claim_host(gInstance->func[func]);
> 		for (pnext = pkt; pnext; pnext = PKTNEXT(sd->osh, pnext)) {
> 			uint8 *buf = (uint8*)PKTDATA(sd->osh, pnext) +
> 				xfred_len;
> 			pkt_len = PKTLEN(sd->osh, pnext);
> 			if (0 != xfred_len) {
> 				pkt_len -= xfred_len;
> 				xfred_len = 0;
> 			}
> 
> 			/* Align Patch */
> 			if (!write) // read
> 				pkt_len = (pkt_len + 3) & 0xFFFFFFFC;
> 			else if(pkt_len % DHD_SDALIGN) // write
> 				pkt_len += DHD_SDALIGN - (pkt_len % DHD_SDALIGN);
> 
> #ifdef CONFIG_MMC_MSM7X00A
> 			if ((pkt_len % 64) == 32) {
> 				sd_trace(("%s: Rounding up TX packet +=32\n", __FUNCTION__));
> 				pkt_len += 32;
> 			}
> #endif /* CONFIG_MMC_MSM7X00A */
> 
> 			if ((write) && (!fifo))
> 				err_ret = sdio_memcpy_toio(
> 						gInstance->func[func],
> 						addr, buf, pkt_len);
> 			else if (write)
> 				err_ret = sdio_memcpy_toio(
> 						gInstance->func[func],
> 						addr, buf, pkt_len);
> 			else if (fifo)
> 				err_ret = sdio_readsb(
> 						gInstance->func[func],
> 						buf, addr, pkt_len);
> 			else
> 				err_ret = sdio_memcpy_fromio(
> 						gInstance->func[func],
> 						buf, addr, pkt_len);
> 
> 			if (err_ret)
> 				sd_err(("%s: %s FAILED %p[%d], addr=0x%05x, pkt_len=%d, ERR=%d\n",
> 				       __FUNCTION__,
> 				       (write) ? "TX" : "RX",
> 				       pnext, SGCount, addr, pkt_len, err_ret));
> 			else
> 				sd_trace(("%s: %s xfr'd %p[%d], addr=0x%05x, len=%d\n",
> 					__FUNCTION__,
> 					(write) ? "TX" : "RX",
> 					pnext, SGCount, addr, pkt_len));
> 
> 			if (!fifo)
> 				addr += pkt_len;
> 			SGCount ++;
> 		}
> 		sdio_release_host(gInstance->func[func]);
> 	}
1233,1234c1335
< 		ret = sdio_reset_comm(gInstance->func[0]->card);
< 		if (ret) {
---
> 		if ((ret = sdio_reset_comm(gInstance->func[0]->card))) {
1236,1238c1337,1339
< 			SDIOH_ASSERT(0);
< 			ASSERT(0);
< 		} else {
---
> 			return ret;
> 		}
> 		else {
diff -r update5/drivers/net/wireless/bcmdhd/src/bcmsdio/sys/bcmsdh_sdmmc_linux.c update6/drivers/net/wireless/bcmdhd/src/bcmsdio/sys/bcmsdh_sdmmc_linux.c
81a82,84
> extern int dhd_os_check_wakelock(void *dhdp);
> extern int dhd_os_check_if_up(void *dhdp);
> extern void *bcmsdh_get_drvdata(void);
101a105
> extern volatile bool dhd_mmc_suspend;
140c144
< 	sd_trace(("bcmsdh_sdmmc: %s Enter\n", __FUNCTION__));
---
> 	sd_err(("bcmsdh_sdmmc: %s Enter\n", __FUNCTION__));
147c151
< 		sd_trace(("F2 found, calling bcmsdh_remove...\n"));
---
> 		sd_err(("F2 found, calling bcmsdh_remove...\n"));
168d171
< #ifndef BOARD_PANDA
170d172
< #endif
175a178,254
> #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 39)) && defined(CONFIG_PM)
> static int bcmsdh_sdmmc_suspend(struct device *pdev)
> {
> 	struct sdio_func *func = dev_to_sdio_func(pdev);
> 
> 	if (func->num != 2)
> 		return 0;
> 
> 	sd_trace(("%s Enter\n", __FUNCTION__));
> 
> 	if (dhd_os_check_wakelock(bcmsdh_get_drvdata()))
> 		return -EBUSY;
> #if defined(OOB_INTR_ONLY)
> 	bcmsdh_oob_intr_set(0);
> #endif	/* defined(OOB_INTR_ONLY) */
> 	dhd_mmc_suspend = TRUE;
> 	smp_mb();
> 
> 	return 0;
> }
> 
> static int bcmsdh_sdmmc_resume(struct device *pdev)
> {
> #if defined(OOB_INTR_ONLY)
> 	struct sdio_func *func = dev_to_sdio_func(pdev);
> #endif
> 	sd_trace(("%s Enter\n", __FUNCTION__));
> 	dhd_mmc_suspend = FALSE;
> #if defined(OOB_INTR_ONLY)
> 	if ((func->num == 2) && dhd_os_check_if_up(bcmsdh_get_drvdata()))
> 		bcmsdh_oob_intr_set(1);
> #endif /* (OOB_INTR_ONLY) */
> 
> 	smp_mb();
> 	return 0;
> }
> 
> static const struct dev_pm_ops bcmsdh_sdmmc_pm_ops = {
> 	.suspend	= bcmsdh_sdmmc_suspend,
> 	.resume		= bcmsdh_sdmmc_resume,
> };
> #endif  /* (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 39)) && defined(CONFIG_PM) */
> 
> #if defined(BCMLXSDMMC)
> static struct semaphore *notify_semaphore = NULL;
> 
> static int dummy_probe(struct sdio_func *func,
>                               const struct sdio_device_id *id)
> {
> 	if (notify_semaphore)
> 	up(notify_semaphore);
> 	return 0;
> }
> 
> static void dummy_remove(struct sdio_func *func)
> {
> }
> 
> static struct sdio_driver dummy_sdmmc_driver = {
> 	.probe		= dummy_probe,
> 	.remove		= dummy_remove,
> 	.name		= "dummy_sdmmc",
> 	.id_table	= bcmsdh_sdmmc_ids,
> 	};
> 
> int sdio_func_reg_notify(void* semaphore)
> {
> 	notify_semaphore = semaphore;
> 	return sdio_register_driver(&dummy_sdmmc_driver);
> }
> 
> void sdio_func_unreg_notify(void)
> {
> 	sdio_unregister_driver(&dummy_sdmmc_driver);
> }
> #endif /* defined(BCMLXSDMMC) */
> 
180a260,266
> #if 0
> #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 39)) && defined(CONFIG_PM)
> 	.drv = {
> 	.pm	= &bcmsdh_sdmmc_pm_ops,
> 	},
> #endif /* (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 39)) && defined(CONFIG_PM) */
> #endif /* (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 39)) && defined(CONFIG_PM) */
diff -r update5/drivers/net/wireless/bcmdhd/src/dhd/sys/dhd_bus.h update6/drivers/net/wireless/bcmdhd/src/dhd/sys/dhd_bus.h
99a100,106
> #define DHD_SET_BUS_STATE_DOWN(_bus)  do { \
> 	(_bus)->dhd->busstate = DHD_BUS_DOWN; \
> } while (0)
> /* Register a dummy SDIO client driver in order to be notified of new SDIO device */
> extern int dhd_bus_reg_sdio_notify(void* semaphore);
> extern void dhd_bus_unreg_sdio_notify(void);
> 
diff -r update5/drivers/net/wireless/bcmdhd/src/dhd/sys/dhd_cdc.c update6/drivers/net/wireless/bcmdhd/src/dhd/sys/dhd_cdc.c
4c4
<  * Copyright (C) 1999-2011, Broadcom Corporation
---
>  * Copyright (C) 1999-2012, Broadcom Corporation
239d238
< 
241,242c240,242
< 	if ((g_pm_control == TRUE) && (cmd == WLC_SET_PM)) {
< 		DHD_TRACE(("%s: SET PM ignored!\n", __func__));
---
> 	if ((g_pm_control == TRUE) && (cmd == WLC_SET_PM))
> 	{
> 		DHD_ERROR(("SET PM ignored!!!!!!!!!!!!!!!!!!!!!!\n"));
297a298,300
> #if defined(NDIS630)
> 	bool acquired = FALSE;
> #endif
302a306,317
> #if defined(NDIS630)
> 	if (dhd_os_proto_block(dhd))
> 	{
> 		acquired = TRUE;
> 	}
> 	else
> 	{
> 		/* attempt to acquire protocol mutex timed out. */
> 		ret = -1;
> 		return ret;
> 	}
> #endif /* NDIS630 */
352a368,371
> #if defined(NDIS630)
> 	if (acquired)
> 	   dhd_os_proto_unblock(dhd);
> #endif
1313a1333,1344
> 	else if (action == eWLFC_MAC_ENTRY_ACTION_UPDATE) {
> 		entry->occupied = 1;
> 		entry->state = WLFC_STATE_OPEN;
> 		entry->requested_credit = 0;
> 		entry->interface_id = ifid;
> 		entry->iftype = iftype;
> 		entry->ac_bitmap = 0xff; /* update this when handling APSD */
> 		/* for an interface entry we may not care about the MAC address */
> 		if (ea != NULL)
> 			memcpy(&entry->ea[0], ea, ETHER_ADDR_LEN);
> 	}
> 
2174a2206,2208
> 			h->items[i].state = WLFC_HANGER_ITEM_STATE_FREE;
> 			h->items[i].pkt = NULL;
> 			h->items[i].identifier = 0;
2279a2314,2316
> #if defined(NDIS630)
> 	h->dataOffset = 0;
> #endif
2298a2336
> #if !defined(NDIS630)
2304c2342
< 
---
> #endif
2321a2360
> #if !defined(NDIS630)
2322a2362
> #endif
diff -r update5/drivers/net/wireless/bcmdhd/src/dhd/sys/dhd_cfg80211.c update6/drivers/net/wireless/bcmdhd/src/dhd/sys/dhd_cfg80211.c
4c4
<  * Copyright (C) 1999-2011, Broadcom Corporation
---
>  * Copyright (C) 1999-2012, Broadcom Corporation
48a49,50
> static s32 wl_dongle_up(struct net_device *ndev, u32 up);
> 
70a73,82
> static s32 wl_dongle_up(struct net_device *ndev, u32 up)
> {
> 	s32 err = 0;
> 
> 	err = wldev_ioctl(ndev, WLC_UP, &up, sizeof(up), true);
> 	if (unlikely(err)) {
> 		WL_ERR(("WLC_UP error (%d)\n", err));
> 	}
> 	return err;
> }
89a102,106
> 	err = wl_dongle_up(ndev, 0);
> 	if (unlikely(err)) {
> 		WL_ERR(("wl_dongle_up failed\n"));
> 		goto default_conf_out;
> 	}
466c483
< #endif
---
> #endif /* COEX_DHCP */
diff -r update5/drivers/net/wireless/bcmdhd/src/dhd/sys/dhd_common.c update6/drivers/net/wireless/bcmdhd/src/dhd/sys/dhd_common.c
4c4
<  * Copyright (C) 1999-2011, Broadcom Corporation
---
>  * Copyright (C) 1999-2012, Broadcom Corporation
55a56,62
> #define htod32(i) i
> #define htod16(i) i
> #define dtoh32(i) i
> #define dtoh16(i) i
> #define htodchanspec(i) i
> #define dtohchanspec(i) i
> 
83,86d89
< #define htod32(i) i
< #define htod16(i) i
< #define dtoh32(i) i
< #define dtoh16(i) i
92a96
> extern bool dhd_concurrent_fw(dhd_pub_t *dhd);
181c185
< struct dhd_cmn *
---
> void
184d187
< 	dhd_cmn_t *cmn;
193,198d195
< 	if (!(cmn = MALLOC(osh, sizeof(dhd_cmn_t)))) {
< 		DHD_ERROR(("%s: MALLOC failed\n", __FUNCTION__));
< 		return NULL;
< 	}
< 	memset(cmn, 0, sizeof(dhd_cmn_t));
< 	cmn->osh = osh;
213,214d209
< 	return cmn;
< }
216,234d210
< void
< dhd_common_deinit(dhd_pub_t *dhd_pub, dhd_cmn_t *sa_cmn)
< {
< 	osl_t *osh;
< 	dhd_cmn_t *cmn;
< 
< 	if (dhd_pub != NULL)
< 		cmn = dhd_pub->cmn;
< 	else
< 		cmn = sa_cmn;
< 
< 	if (!cmn)
< 		return;
< 
< 	osh = cmn->osh;
< 
< 	if (dhd_pub != NULL)
< 	dhd_pub->cmn = NULL;
< 	MFREE(osh, cmn, sizeof(dhd_cmn_t));
1053,1056c1029,1038
< 		dhd_wlfc_interface_event(dhd_pub->info,
< 			((ifevent->action == WLC_E_IF_ADD) ?
< 			eWLFC_MAC_ENTRY_ACTION_ADD : eWLFC_MAC_ENTRY_ACTION_DEL),
< 			ifevent->ifidx, ifevent->is_AP, ea);
---
> 		if (ifevent->action == WLC_E_IF_CHANGE)
> 			dhd_wlfc_interface_event(dhd_pub->info,
> 				eWLFC_MAC_ENTRY_ACTION_UPDATE,
> 				ifevent->ifidx, ifevent->is_AP, ea);
> 		else
> 			dhd_wlfc_interface_event(dhd_pub->info,
> 				((ifevent->action == WLC_E_IF_ADD) ?
> 				eWLFC_MAC_ENTRY_ACTION_ADD : eWLFC_MAC_ENTRY_ACTION_DEL),
> 				ifevent->ifidx, ifevent->is_AP, ea);
> 
1069c1051,1052
< 				if (ifevent->action == WLC_E_IF_ADD)
---
> 				if (ifevent->action == WLC_E_IF_ADD
> 					|| ifevent->action == WLC_E_IF_CHANGE)
1088c1071
< 			else
---
> 					else if (ifevent->action == WLC_E_IF_DEL)
1108a1092,1095
> #if defined(NDIS630)
> 	case WLC_E_NDIS_LINK:
> 		break;
> #else /* defined(NDIS630) && defined(BCMDONGLEHOST) */
1114a1102
> #endif
1846a1835,1836
> 	if (dhd_concurrent_fw(dhd))
> 		return FALSE;
1855c1845
< #ifdef PNO_SUPPORT
---
> #if defined(PNO_SUPPORT)
diff -r update5/drivers/net/wireless/bcmdhd/src/dhd/sys/dhd_custom_gpio.c update6/drivers/net/wireless/bcmdhd/src/dhd/sys/dhd_custom_gpio.c
3c3
< * Copyright (C) 1999-2011, Broadcom Corporation
---
> * Copyright (C) 1999-2012, Broadcom Corporation
201,244c201,258
< #ifdef EXAMPLE_TABLE
< 	{"",   "XY", 4},  /* Universal if Country code is unknown or empty */
< 	{"US", "US", 69}, /* input ISO "US" to : US regrev 69 */
< 	{"CA", "US", 69}, /* input ISO "CA" to : US regrev 69 */
< 	{"EU", "EU", 5},  /* European union countries to : EU regrev 05 */
< 	{"AT", "EU", 5},
< 	{"BE", "EU", 5},
< 	{"BG", "EU", 5},
< 	{"CY", "EU", 5},
< 	{"CZ", "EU", 5},
< 	{"DK", "EU", 5},
< 	{"EE", "EU", 5},
< 	{"FI", "EU", 5},
< 	{"FR", "EU", 5},
< 	{"DE", "EU", 5},
< 	{"GR", "EU", 5},
< 	{"HU", "EU", 5},
< 	{"IE", "EU", 5},
< 	{"IT", "EU", 5},
< 	{"LV", "EU", 5},
< 	{"LI", "EU", 5},
< 	{"LT", "EU", 5},
< 	{"LU", "EU", 5},
< 	{"MT", "EU", 5},
< 	{"NL", "EU", 5},
< 	{"PL", "EU", 5},
< 	{"PT", "EU", 5},
< 	{"RO", "EU", 5},
< 	{"SK", "EU", 5},
< 	{"SI", "EU", 5},
< 	{"ES", "EU", 5},
< 	{"SE", "EU", 5},
< 	{"GB", "EU", 5},
< 	{"KR", "XY", 3},
< 	{"AU", "XY", 3},
< 	{"CN", "XY", 3}, /* input ISO "CN" to : XY regrev 03 */
< 	{"TW", "XY", 3},
< 	{"AR", "XY", 3},
< 	{"MX", "XY", 3},
< 	{"IL", "IL", 0},
< 	{"CH", "CH", 0},
< 	{"TR", "TR", 0},
< 	{"NO", "NO", 0},
< #endif /* EXMAPLE_TABLE */
---
> #ifdef BCM4334_CHIP
> 	{"",   "XZ", 11},  /* Universal if Country code is unknown or empty */
> #endif
> 	{"AE", "AE", 1},
> 	{"AR", "AR", 1},
> 	{"AT", "AT", 1},
> 	{"AU", "AU", 2},
> 	{"BE", "BE", 1},
> 	{"BG", "BG", 1},
> 	{"BN", "BN", 1},
> 	{"CA", "CA", 2},
> 	{"CH", "CH", 1},
> 	{"CN", "CN", 0},
> 	{"CY", "CY", 1},
> 	{"CZ", "CZ", 1},
> 	{"DE", "DE", 3},
> 	{"DK", "DK", 1},
> 	{"EE", "EE", 1},
> 	{"ES", "ES", 1},
> 	{"FI", "FI", 1},
> 	{"FR", "FR", 1},
> 	{"GB", "GB", 1},
> 	{"GR", "GR", 1},
> 	{"HR", "HR", 1},
> 	{"HU", "HU", 1},
> 	{"IE", "IE", 1},
> 	{"IS", "IS", 1},
> 	{"IT", "IT", 1},
> 	{"JP", "JP", 5},
> 	{"KR", "KR", 24},
> 	{"KW", "KW", 1},
> 	{"LI", "LI", 1},
> 	{"LT", "LT", 1},
> 	{"LU", "LU", 1},
> 	{"LV", "LV", 1},
> 	{"MA", "MA", 1},
> 	{"MT", "MT", 1},
> 	{"MX", "MX", 1},
> 	{"NL", "NL", 1},
> 	{"NO", "NO", 1},
> 	{"PL", "PL", 1},
> 	{"PT", "PT", 1},
> 	{"PY", "PY", 1},
> 	{"RO", "RO", 1},
> 	{"SE", "SE", 1},
> 	{"SI", "SI", 1},
> 	{"SK", "SK", 1},
> 	{"TR", "TR", 7},
> 	{"TW", "TW", 2},
> #ifdef BCM4334_CHIP
> 	{"RU", "RU", 5},
> 	{"SG", "SG", 4},
> 	{"US", "US", 46}
> #endif
> #ifdef BCM4330_CHIP
> 	{"RU", "RU", 1},
> 	{"US", "US", 5}
> #endif
254,256c268
< #if (defined(CUSTOMER_HW2) || defined(CUSTOMER_HW_SAMSUNG)) \
< 	&& (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
< 
---
> #ifndef CUSTOMER_HW_SAMSUNG
293,294c305
< #endif /* (defined(CUSTOMER_HW2) || defined(CUSTOMER_HW_SAMSUNG)) \
< 	&& (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)) */
---
> #endif /* CUSTOMER_HW_SAMSUNG) */
diff -r update5/drivers/net/wireless/bcmdhd/src/dhd/sys/dhd_custom_sec.c update6/drivers/net/wireless/bcmdhd/src/dhd/sys/dhd_custom_sec.c
20a21
> #define MACINFO "/opt/etc/.mac.info"
30d30
< 	struct file *fpnv      = NULL;
41a42,45
> 	struct dentry *parent;
> 	struct dentry *dentry;
> 	struct inode *p_inode;
> 	struct inode *c_inode;
43,47d46
< 	/* MAC address copied from nvfile */
< 	fpnv = filp_open(nvfilepath, O_RDONLY, 0);
< 	if (IS_ERR(fpnv)) {
< start_readmac:
< 		fpnv = NULL;
49a49
> start_readmac:
53,54c53
< 				DHD_ERROR(("[WIFI] %s: File open error\n",
< 					filepath));
---
> 			DHD_ERROR(("[WIFI] %s: File open error\n", filepath));
57d55
< 
59a58,64
> 		/* set uid , gid of parent directory */
> 		dentry = fp->f_path.dentry;
> 		parent = dget_parent(dentry);
> 		c_inode = dentry->d_inode;
> 		p_inode = parent->d_inode;
> 		c_inode->i_uid = p_inode->i_uid;
> 		c_inode->i_gid = p_inode->i_gid;
61,63c66
< 			/* Generating the Random Bytes for
< 			 * 3 last octects of the MAC address
< 			 */
---
> 		/* Generating the Random Bytes for 3 last octects of the MAC address */
67,70c70,71
< 					0x60, 0xd0, 0xa9, randommac[0],
< 					randommac[1], randommac[2]);
< 			DHD_ERROR(("[WIFI] The Random Generated MAC ID : %s\n",
< 					macbuffer));
---
> 					0x00, 0x12, 0x34, randommac[0], randommac[1], randommac[2]);
> 		DHD_ERROR(("[WIFI]The Random Generated MAC ID: %s\n", macbuffer));
73,75c74
< 				ret = fp->f_op->write(fp,
< 					(const char *)macbuffer,
< 						sizeof(macbuffer), &fp->f_pos);
---
> 			ret = fp->f_op->write(fp, (const char *)macbuffer, sizeof(macbuffer), &fp->f_pos);
77,79c76
< 					DHD_ERROR(("[WIFI] Mac address [%s]"
< 						" Failed to write into File:"
< 						" %s\n", macbuffer, filepath));
---
> 				DHD_ERROR(("[WIFI]MAC address [%s] Failed to write into File: %s\n", macbuffer, filepath));
81,83c78
< 					DHD_INFO(("[WIFI] Mac address [%s]"
< 						" written into File: %s\n",
< 						macbuffer, filepath));
---
> 				DHD_ERROR(("[WIFI]MAC address [%s] written into File: %s\n", macbuffer, filepath));
86,89c81
< 		}
< 		/* Reading the MAC Address from .mac.info file
< 		 * (the existed file or just created file)
< 		 */
---
> 		/* Reading the MAC Address from .mac.info file( the existed file or just created file)*/
92,98c84,86
< 		/* Reading the MAC Address from .nvmac.info file
< 		 * (the existed file or just created file)
< 		 */
< 		ret = kernel_read(fpnv, 0, buf, 18);
< 		/* to prevent abnormal string display when
< 		 * mac address is displayed on the screen.
< 		 */
---
> 		/* Reading the MAC Address from .mac.info file( the existed file or just created file)*/
> 		ret = kernel_read(fp, 0, buf, 18);
> /* to prevent abnormal string display when mac address is displayed on the screen. */
100,104c88,91
< 
< 		DHD_ERROR(("Read MAC : [%s] [%d] \r\n", buf,
< 			strncmp(buf , "00:00:00:00:00:00", 17)));
< 		if (strncmp(buf , "00:00:00:00:00:00" , 17) == 0) {
< 			filp_close(fpnv, NULL);
---
> 		DHD_ERROR(("Read MAC : [%s] [%d] \r\n" , buf, strncmp(buf , "00:00:00:00:00:00" , 17)));
> 		if (strncmp(buf , "00:00:00:00:00:00" , 17) < 1) {
> 			DHD_ERROR(("goto start_readmac \r\n"));
> 			filp_close(fp, NULL);
107,134d93
< 
< 		/* File is always created. */
< 		fp = filp_open(filepath, O_RDWR | O_CREAT, 0666);
< 		if (IS_ERR(fp)) {
< 			DHD_ERROR(("[WIFI] %s: File open error\n", filepath));
< 			if (fpnv)
< 				filp_close(fpnv, NULL);
< 			return -1;
< 		} else {
< 			oldfs = get_fs();
< 			set_fs(get_ds());
< 
< 			if (fp->f_mode & FMODE_WRITE) {
< 				ret = fp->f_op->write(fp, (const char *)buf,
< 						sizeof(buf), &fp->f_pos);
< 				if (ret < 0)
< 					DHD_ERROR(("[WIFI] Mac address [%s]"
< 					" Failed to write into File: %s\n",
< 					buf, filepath));
< 				else
< 					DHD_INFO(("[WIFI] Mac address [%s]"
< 					" written into File: %s\n",
< 					buf, filepath));
< 			}
< 			set_fs(oldfs);
< 
< 			ret = kernel_read(fp, 0, buf, 18);
< 		}
139,144c98,100
< 			(unsigned int *)&(mac->octet[0]),
< 			(unsigned int *)&(mac->octet[1]),
< 			(unsigned int *)&(mac->octet[2]),
< 			(unsigned int *)&(mac->octet[3]),
< 			(unsigned int *)&(mac->octet[4]),
< 			(unsigned int *)&(mac->octet[5]));
---
> 			   (unsigned int *)&(mac->octet[0]), (unsigned int *)&(mac->octet[1]),
> 			   (unsigned int *)&(mac->octet[2]), (unsigned int *)&(mac->octet[3]),
> 			   (unsigned int *)&(mac->octet[4]), (unsigned int *)&(mac->octet[5]));
146,147c102
< 		DHD_ERROR(("dhd_bus_start: Reading from the"
< 			" '%s' returns 0 bytes\n", filepath));
---
> 		DHD_ERROR(("dhd_bus_start: Reading from the '%s' returns 0 bytes\n", filepath));
151,152d105
< 	if (fpnv)
< 		filp_close(fpnv, NULL);
162d114
< 
215a168
> 
299,300c252
< 				if (memcmp(cur_mac, mac->octet,
< 					ETHER_ADDR_LEN) == 0) {
---
> 				if(memcmp(cur_mac,mac->octet,ETHER_ADDR_LEN) == 0) {
303,304c255
< 					if (0 == _dhd_set_mac_address(dhd,
< 						0, mac)) {
---
> 					if (0 == _dhd_set_mac_address(dhd, 0, mac)) {
306c257
< 						" overwritten\n", __func__));
---
> 						" overwritten\n", __FUNCTION__));
311c262
< 						" failed\n", __func__));
---
> 						" failed\n", __FUNCTION__));
330c281,282
< 		if (buf[0] == 0 || strncmp(buf, "00:00:00:00:00:00", 17) == 0) {
---
> 		if ((buf[0] == '\0') ||
> 			(strncmp(buf, "00:00:00:00:00:00", 17) == 0)) {
343c295
< 					__func__));
---
> 					__FUNCTION__));
347c299
< 					" failed\n", __func__));
---
> 					" failed\n", __FUNCTION__));
369c321
< 			DHD_INFO(("%s: MACID is overwritten\n", __func__));
---
> 			DHD_INFO(("%s: MACID is overwritten\n", __FUNCTION__));
373c325
< 				__func__));
---
> 				__FUNCTION__));
380a333,415
> #ifdef RDWR_KORICS_MACADDR
> int dhd_write_rdwr_korics_macaddr(struct dhd_info *dhd, struct ether_addr *mac)
> {
> 	struct file *fp      = NULL;
> 	char macbuffer[18]   = {0};
> 	mm_segment_t oldfs   = {0};
> 	char randommac[3]    = {0};
> 	char buf[18]         = {0};
> 	char *filepath       = "/efs/wifi/.mac.info";
> 
> 	int ret = 0;
> 	/* MAC address copied from efs/wifi.mac.info */
> 	fp = filp_open(filepath, O_RDONLY, 0);
> 
> 	if (IS_ERR(fp)) {
> 		/* File Doesn't Exist. Create and write mac addr.*/
> 		fp = filp_open(filepath, O_RDWR | O_CREAT, 0666);
> 		if (IS_ERR(fp)) {
> 			DHD_ERROR(("[WIFI] %s: File open error\n",
> 				filepath));
> 			return -1;
> 		}
> 
> 		oldfs = get_fs();
> 		set_fs(get_ds());
> 
> 		/* Generating the Random Bytes for
> 		 * 3 last octects of the MAC address
> 		 */
> 		get_random_bytes(randommac, 3);
> 
> 		sprintf(macbuffer, "%02X:%02X:%02X:%02X:%02X:%02X\n",
> 				0x60, 0xd0, 0xa9, randommac[0],
> 				randommac[1], randommac[2]);
> 		DHD_ERROR(("[WIFI] The Random Generated MAC ID : %s\n",
> 				macbuffer));
> 
> 		if (fp->f_mode & FMODE_WRITE) {
> 			ret = fp->f_op->write(fp,
> 				(const char *)macbuffer,
> 					sizeof(macbuffer), &fp->f_pos);
> 			if (ret < 0)
> 				DHD_ERROR(("[WIFI] Mac address [%s]"
> 					" Failed to write into File:"
> 					" %s\n", macbuffer, filepath));
> 			else
> 				DHD_ERROR(("[WIFI] Mac address [%s]"
> 					" written into File: %s\n",
> 					macbuffer, filepath));
> 		}
> 		set_fs(oldfs);
> 	} else {
> 	/* Reading the MAC Address from .mac.info file
> 	 * (the existed file or just created file)
> 	 */
> 	    ret = kernel_read(fp, 0, buf, 18);
> 	}
> 
> 	if (ret)
> 		sscanf(buf, "%02X:%02X:%02X:%02X:%02X:%02X",
> 			(unsigned int *)&(mac->octet[0]),
> 			(unsigned int *)&(mac->octet[1]),
> 			(unsigned int *)&(mac->octet[2]),
> 			(unsigned int *)&(mac->octet[3]),
> 			(unsigned int *)&(mac->octet[4]),
> 			(unsigned int *)&(mac->octet[5]));
> 	else
> 		DHD_INFO(("dhd_bus_start: Reading from the"
> 			" '%s' returns 0 bytes\n", filepath));
> 
> 	if (fp)
> 		filp_close(fp, NULL);
> 
> 	/* Writing Newly generated MAC ID to the Dongle */
> 	if (0 == _dhd_set_mac_address(dhd, 0, mac))
> 		DHD_INFO(("dhd_bus_start: MACID is overwritten\n"));
> 	else
> 		DHD_ERROR(("dhd_bus_start: _dhd_set_mac_address() failed\n"));
> 
> 	return 0;
> }
> #endif /* RDWR_KORICS_MACADDR */
> 
382,383c417
< static int dhd_write_cid_file(const char *filepath, const char *buf,
< 	int buf_len)
---
> static int dhd_write_cid_file(const char *filepath, const char *buf, int buf_len)
420,421c454
< 		if ((i % 15) == 15)
< 			DHD_ERROR(("\n"));
---
> 		if ((i % 15) == 15) DHD_ERROR(("\n"));
427c460
< #ifdef CONFIG_BCM4334
---
> #ifdef BCM4334_CHIP
431c464
< #endif /* CONFIG_BCM4334 */
---
> #endif /* BCM4334_CHIP */
436c469
< #ifdef CONFIG_BCM4334
---
> #ifdef BCM4334_CHIP
455c488
< 			__func__, ret));
---
> 			__FUNCTION__, ret));
457c490
< #ifdef CONFIG_BCM4334
---
> #ifdef BCM4334_CHIP
458a492
> 		unsigned char semco_id_sh[4] = {0x00, 0x00, 0xFB, 0x50};	//for SHARP FEM(new)
460c494
< 			__func__, ret));
---
> 			__FUNCTION__, ret));
465,466c499,500
< 			DHD_ERROR(("CID MATCH FOUND : Semco, 0x%02X 0x%02X 0x%02X 0x%02X\n",
< 				cis_buf[CIS_CID_OFFSET],
---
> 			DHD_ERROR(("CID MATCH FOUND : Semco, 0x%02X 0x%02X \
> 			0x%02X 0x%02X\n", cis_buf[CIS_CID_OFFSET],
469a504,509
> 		} else if (memcmp(&cis_buf[CIS_CID_OFFSET], semco_id_sh, 4) == 0) {
> 			DHD_ERROR(("CIS MATCH FOUND : Semco_sh, 0x%02X 0x%02X \
> 			0x%02X 0x%02X\n", cis_buf[CIS_CID_OFFSET],
> 			cis_buf[CIS_CID_OFFSET+1], cis_buf[CIS_CID_OFFSET+2],
> 			cis_buf[CIS_CID_OFFSET+3]));
> 			dhd_write_cid_file(cidfilepath, "semcosh", 7);
471,472c511,512
< 			DHD_ERROR(("CID MATCH FOUND : Murata, 0x%02X 0x%02X 0x%02X 0x%02X\n",
< 				cis_buf[CIS_CID_OFFSET],
---
> 			DHD_ERROR(("CID MATCH FOUND : Murata, 0x%02X 0x%02X \
> 			0x%02X 0x%02X\n", cis_buf[CIS_CID_OFFSET],
478c518
< #else /* CONFIG_BCM4330 */
---
> #else /* BCM4330_CHIP */
500c540
< #endif /* CONFIG_BCM4334 */
---
> #endif /* BCM4334_CHIP */
502c542
< 			__func__, ret));
---
> 			__FUNCTION__, ret));
674c714
< 				__func__, __LINE__));
---
> 				__FUNCTION__, __LINE__));
676a717,724
> 			struct dentry *dentry;
> 			struct inode *c_inode;
> 			/* set uid , gid to system id(1000) */
> 			dentry = fp->f_path.dentry;
> 			c_inode = dentry->d_inode;
> 			c_inode->i_uid = (uid_t)1000;
> 			c_inode->i_gid = (uid_t)1000;
> 
705a754
> 			/* Roaming off of dongle */
718a768,826
> }
> #endif
> #ifdef GLOBALCONFIG_WLAN_COUNTRY_CODE
> int dhd_customer_set_country(dhd_pub_t *dhd)
> {
> 	struct file *fp = NULL;
> 	char *filepath = "/data/.ccode.info";
> 	char iovbuf[WL_EVENTING_MASK_LEN + 12] = {0};
> 	char buffer[10] = {0};
> 	int ret = 0;
> 	wl_country_t cspec;
> 	int buf_len = 0;
> 	char country_code[WLC_CNTRY_BUF_SZ];
> 	int country_rev;
> 	int country_offset;
> 	int country_code_size;
> 	char country_rev_buf[WLC_CNTRY_BUF_SZ];
> 	fp = filp_open(filepath, O_RDONLY, 0);
> 	if (IS_ERR(fp)) {
> 		DHD_ERROR(("%s: %s open failed\n", __FUNCTION__, filepath));
> 		return -1;
> 	} else {
> 		if (kernel_read(fp, 0, buffer, sizeof(buffer))) {
> 			memset(&cspec, 0, sizeof(cspec));
> 			memset(country_code, 0, sizeof(country_code));
> 			memset(country_rev_buf, 0, sizeof(country_rev_buf));
> 			country_offset = strcspn(buffer, " ");
> 			country_code_size = country_offset;
> 			if (country_offset != 0) {
> 				strncpy(country_code, buffer, country_offset);
> 				strncpy(country_rev_buf, buffer+country_offset+1, strlen(buffer) - country_code_size + 1);
> 				country_rev = bcm_atoi(country_rev_buf);
> 				buf_len = bcm_mkiovar("country", (char *)&cspec, sizeof(cspec), iovbuf, sizeof(iovbuf));
> 				ret = dhd_wl_ioctl_cmd(dhd, WLC_GET_VAR, iovbuf, buf_len, FALSE, 0);
> 				memcpy((void *)&cspec, iovbuf, sizeof(cspec));
> 				if (!ret) {
> 					DHD_ERROR(("%s: get country ccode:%s country_abrev:%s rev:%d  \n", __FUNCTION__, cspec.ccode, cspec.country_abbrev, cspec.rev));
> 					if ((strncmp(country_code, cspec.ccode, WLC_CNTRY_BUF_SZ) != 0) || (cspec.rev != country_rev)) {
> 						strncpy(cspec.country_abbrev, country_code, country_code_size);
> 						strncpy(cspec.ccode, country_code, country_code_size);
> 						cspec.rev = country_rev;
> 						DHD_ERROR(("%s: set country ccode:%s country_abrev:%s rev:%d  \n", __FUNCTION__, cspec.ccode, cspec.country_abbrev, cspec.rev));
> 						buf_len = bcm_mkiovar("country", (char *)&cspec, sizeof(cspec), iovbuf, sizeof(iovbuf));
> 						ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, buf_len, TRUE, 0);
> 					}
> 				}
> 			} else {
> 				DHD_ERROR(("%s: set country %s failed code \n", __FUNCTION__, country_code));
> 				ret = -1;
> 			}
> 		} else {
> 			DHD_ERROR(("%s: Reading from the '%s' returns 0 bytes \n", __FUNCTION__, filepath));
> 			ret = -1;
> 		}
> 	}
> 	if (fp)
> 		filp_close(fp, NULL);
> 
> 	return ret;
diff -r update5/drivers/net/wireless/bcmdhd/src/dhd/sys/dhd_dbg.h update6/drivers/net/wireless/bcmdhd/src/dhd/sys/dhd_dbg.h
32,33c32
< #define DHD_ERROR(args)	       do {if ((dhd_msg_level & DHD_ERROR_VAL) && (net_ratelimit())) \
< 								printf args;} while (0)
---
> #define DHD_ERROR(args)	       do {if (dhd_msg_level & DHD_ERROR_VAL)	printf args;} while (0)
102,105d100
< #if defined(DHD_DEBUG)
< extern void dhd_blog(char *cp, int size);
< #define DHD_BLOG(cp, size)		do { dhd_blog(cp, size);} while (0)
< #else
107d101
< #endif
diff -r update5/drivers/net/wireless/bcmdhd/src/dhd/sys/dhd.h update6/drivers/net/wireless/bcmdhd/src/dhd/sys/dhd.h
7c7
<  * Copyright (C) 1999-2011, Broadcom Corporation
---
>  * Copyright (C) 1999-2012, Broadcom Corporation
27c27
<  * $Id: dhd.h 304622 2011-12-22 19:51:18Z $
---
>  * $Id: dhd.h 309548 2012-01-20 01:13:08Z $
36a37
> #include "dhd_sec_feature.h"
60a62,63
> // For dual support of WCN3660 and BCM4334
> #undef CONFIG_WIRELESS_EXT
66d68
< struct dhd_cmn;
87a90,96
> #ifndef POWERUP_MAX_RETRY
> #define POWERUP_MAX_RETRY	(10) /* how many times we retry to power up the chip */
> #endif
> #ifndef POWERUP_WAIT_MS
> #define POWERUP_WAIT_MS		(2000) /* ms: time out in waiting wifi to come up */
> #endif
> 
108a118,122
> #if defined (CUSTOMER_HW_SAMSUNG) && defined (CONFIG_DHD_USE_STATIC_BUF)
> 	DHD_PREALLOC_OSL_BUF,
> 	DHD_PREALLOC_WIPHY_ESCAN0 = 5,
> 	DHD_PREALLOC_WIPHY_ESCAN1
> #else
109a124
> #endif
158d172
< 	struct dhd_cmn	*cmn;	/* dhd_common module handle */
208a223
> 	int pno_suspend;		/* pno suspend status : "1" is pno suspended */
250,255d264
< typedef struct dhd_cmn {
< 	osl_t *osh;		/* OSL handle */
< 	dhd_pub_t *dhd;
< } dhd_cmn_t;
< 
< 
261c270
< 			smp_mb(); \
---
> 			SMP_RD_BARRIER_DEPENDS(); \
263c272,273
< 				wait_event_interruptible_timeout(a, FALSE, HZ/100); \
---
> 				SMP_RD_BARRIER_DEPENDS(); \
> 				wait_event_interruptible_timeout(a, !dhd_mmc_suspend, HZ/100); \
333a344,369
> #ifdef DHD_DEBUG_WAKE_LOCK
> #define DHD_OS_WAKE_LOCK(pub) \
> 	do { \
> 		printf("call wake_lock: %s %d\n", \
> 			__FUNCTION__, __LINE__); \
> 		dhd_os_wake_lock(pub); \
> 	} while (0)
> #define DHD_OS_WAKE_UNLOCK(pub) \
> 	do { \
> 		printf("call wake_unlock: %s %d\n", \
> 			__FUNCTION__, __LINE__); \
> 		dhd_os_wake_unlock(pub); \
> 	} while (0)
> #define DHD_OS_WAKE_LOCK_TIMEOUT(pub) \
> 	do { \
> 		printf("call wake_lock_timeout: %s %d\n", \
> 			__FUNCTION__, __LINE__); \
> 		dhd_os_wake_lock_timeout(pub); \
> 	} while (0)
> #define DHD_OS_WAKE_LOCK_TIMEOUT_ENABLE(pub, val) \
> 	do { \
> 		printf("call wake_lock_timeout_enable[%d]: %s %d\n", \
> 			val, __FUNCTION__, __LINE__); \
> 		dhd_os_wake_lock_timeout_enable(pub, val); \
> 	} while (0)
> #else
338,339c374,376
< #define DHD_PACKET_TIMEOUT	1
< #define DHD_EVENT_TIMEOUT	2
---
> #endif /* DHD_DEBUG_WAKE_LOCK */
> #define DHD_PACKET_TIMEOUT_MS	1000
> #define DHD_EVENT_TIMEOUT_MS	1500
439a477
> extern bool dhd_os_check_hang(dhd_pub_t *dhdp, int ifidx, int ret);
463d500
< extern bool dhd_os_check_hang(dhd_pub_t *dhdp, int ifidx, int ret);
474d510
< 
496,497c532
< extern struct dhd_cmn *dhd_common_init(osl_t *osh);
< extern void dhd_common_deinit(dhd_pub_t *dhd_pub, dhd_cmn_t *sa_cmn);
---
> extern void dhd_common_init(osl_t *osh);
498a534
> extern int dhd_do_driver_init(struct net_device *net);
555a592,593
> extern uint dhd_slpauto;
> 
621a660,666
> #ifdef WL_CFG80211
> /* CSP#505233: Flags to indicate if we distingish power off policy when
>  * user set the memu "Keep Wi-Fi on during sleep" to "Never"
>  */
> extern bool suspend_power_off;
> #endif /* WL_CFG80211 */
> 
759a805,822
> #define IFLOCK_INIT(lock)       *lock = 0
> #define IFLOCK(lock)    while (InterlockedCompareExchange((lock), 1, 0))	\
> 	NdisStallExecution(1);
> #define IFUNLOCK(lock)  InterlockedExchange((lock), 0)
> #define IFLOCK_FREE(lock)
> 
> #ifdef PNO_SUPPORT
> extern int dhd_pno_enable(dhd_pub_t *dhd, int pfn_enabled);
> extern int dhd_pnoenable(dhd_pub_t *dhd, int pfn_enabled);
> extern int dhd_pno_clean(dhd_pub_t *dhd);
> extern int dhd_pno_set(dhd_pub_t *dhd, wlc_ssid_t* ssids_local, int nssid,
>                        ushort  scan_fr, int pno_repeat, int pno_freq_expo_max);
> extern int dhd_pno_get_status(dhd_pub_t *dhd);
> extern int dhd_pno_set_add(dhd_pub_t *dhd, wl_pfn_t *netinfo, int nssid, ushort scan_fr,
> 	ushort slowscan_fr, uint8 pno_repeat, uint8 pno_freq_expo_max, int16 flags);
> extern int dhd_pno_cfg(dhd_pub_t *dhd, wl_pfn_cfg_t *pcfg);
> extern int dhd_pno_suspend(dhd_pub_t *dhd, int pfn_suspend);
> #endif /* PNO_SUPPORT */
767a831,835
> 
> #ifdef RDWR_KORICS_MACADDR
> extern int
> dhd_write_rdwr_korics_macaddr(struct dhd_info *dhd, struct ether_addr *mac);
> #endif
diff -r update5/drivers/net/wireless/bcmdhd/src/dhd/sys/dhd_linux.c update6/drivers/net/wireless/bcmdhd/src/dhd/sys/dhd_linux.c
5c5
<  * Copyright (C) 1999-2011, Broadcom Corporation
---
>  * Copyright (C) 1999-2012, Broadcom Corporation
25c25
<  * $Id: dhd_linux.c 307329 2012-01-11 00:15:58Z $
---
>  * $Id: dhd_linux.c 309571 2012-01-20 01:45:10Z $
196a197,200
> #ifdef GLOBALCONFIG_WLAN_COUNTRY_CODE
> int dhd_customer_set_country(dhd_pub_t *dhd);
> #endif
> 
211a216
> 	bool			event2cfg80211;	/* To determine if pass event to cfg80211 */
241a247,256
> #if defined(PKT_FILTER_SUPPORT)
> #if defined(CUSTOMER_HW_SAMSUNG)
> #define HEX_PREF_STR	"0x"
> #define UNI_FILTER_STR	"010000000000"
> #define ZERO_ADDR_STR	"000000000000"
> #define ETHER_TYPE_STR	"0000"
> #define IPV6_FILTER_STR	"20"
> #define ZERO_TYPE_STR	"00"
> #endif /* CUSTOMER_HW_SAMSUNG */
> #endif /* PKT_FILTER_SUPPORT */
297c312
< 	bool set_macaddress;
---
> 	unsigned char set_macaddress;
323a339,340
> int op_mode = 0;
> module_param(op_mode, int, 0644);
327a345,347
> struct semaphore dhd_chipup_sem;
> int dhd_registration_check = FALSE;
> 
351a372,374
> uint dhd_slpauto = TRUE;
> module_param(dhd_slpauto, uint, 0);
> 
368a392,394
> #ifdef GAN_LITE_NAT_KEEPALIVE_FILTER
> uint dhd_master_mode = FALSE;
> #else
369a396
> #endif /* GAL_LITE_NAT_KEEPALIVE_FILTER */
454,455d480
< 
< 
528c553,554
< 
---
> #if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 39)) || \
> 	defined(CUSTOMER_HW_SAMSUNG)
541a568
> #endif
560a588
> #ifdef PASS_ALL_MCAST_PKTS
562c590,591
< 		uint32 allmultivar=!value;
---
> 		uint32 allmultivar = !value;
> #endif /* PASS_ALL_MCAST_PKTS */
568a598
> #ifdef PASS_ALL_MCAST_PKTS
570a601
> #endif /* PASS_ALL_MCAST_PKTS */
572c603
< #endif
---
> #endif /* PKT_FILTER_SUPPORT */
580d610
< #endif
584d613
< #ifndef CUSTOMER_HW_SAMSUNG
588c617
< 	DHD_TRACE(("%s: enter, value = %d in_suspend=%d\n",
---
> 	DHD_ERROR(("%s: enter, value = %d in_suspend=%d\n",
608a638
> #ifndef CUSTOMER_HW_SAMSUNG
618d647
< #ifndef CUSTOMER_HW_SAMSUNG
628a658
> 
630c660
< 			DHD_TRACE(("%s: Remove extra suspend setting \n", __FUNCTION__));
---
> 			DHD_ERROR(("%s: Remove extra suspend setting \n", __FUNCTION__));
640a671
> #ifndef CUSTOMER_HW_SAMSUNG
647d677
< #ifndef CUSTOMER_HW_SAMSUNG
852,853c882,894
< 	ASSERT(dhd && dhd->iflist[ifidx]);
< 	dev = dhd->iflist[ifidx]->net;
---
> #ifdef MCAST_LIST_ACCUMULATION
> 	int i;
> 	uint32 cnt_iface[DHD_MAX_IFS];
> 	cnt = 0;
> 	allmulti = 0;
> 
> 	for (i = 0; i < DHD_MAX_IFS; i++) {
> 		if (dhd->iflist[i]) {
> 			dev = dhd->iflist[i]->net;
> #else
> 			ASSERT(dhd && dhd->iflist[ifidx]);
> 			dev = dhd->iflist[ifidx]->net;
> #endif /* MCAST_LIST_ACCUMULATION */
855c896
< 	netif_addr_lock_bh(dev);
---
> 			netif_addr_lock_bh(dev);
858c899,901
< 	cnt = netdev_mc_count(dev);
---
> #ifdef MCAST_LIST_ACCUMULATION
> 			cnt_iface[i] = netdev_mc_count(dev);
> 			cnt += cnt_iface[i];
860,861c903,912
< 	cnt = dev->mc_count;
< #endif
---
> 			cnt = netdev_mc_count(dev);
> #endif /* MCAST_LIST_ACCUMULATION */
> #else
> #ifdef MCAST_LIST_ACCUMULATION
> 			cnt += dev->mc_count;
> #else
> 			cnt = dev->mc_count;
> #endif /* MCAST_LIST_ACCUMULATION */
> #endif /* LINUX_VERSION_CODE */
> 
863c914
< 	netif_addr_unlock_bh(dev);
---
> 			netif_addr_unlock_bh(dev);
866c917,926
< 	/* Determine initial value of allmulti flag */
---
> 			/* Determine initial value of allmulti flag */
> #ifdef MCAST_LIST_ACCUMULATION
> 			allmulti |= (dev->flags & IFF_ALLMULTI) ? TRUE : FALSE;
> 		}
> 	}
> #else
> 	allmulti = (dev->flags & IFF_ALLMULTI) ? TRUE : FALSE;
> #endif /* MCAST_LIST_ACCUMULATION */
> 
> #ifdef PASS_ALL_MCAST_PKTS
867a928
> #endif /* PASS_ALL_MCAST_PKTS */
885a947,953
> #ifdef MCAST_LIST_ACCUMULATION
> 	for (i = 0; i < DHD_MAX_IFS; i++) {
> 		if (dhd->iflist[i]) {
> 			DHD_TRACE(("_dhd_set_multicast_list: ifidx %d\n", i));		/* Shinuk */
> 			dev = dhd->iflist[i]->net;
> #endif /* MCAST_LIST_ACCUMULATION */
> 
887c955
< 	netif_addr_lock_bh(dev);
---
> 			netif_addr_lock_bh(dev);
890,896c958,960
< 	netdev_for_each_mc_addr(ha, dev) {
< 		if (!cnt)
< 			break;
< 		memcpy(bufp, ha->addr, ETHER_ADDR_LEN);
< 		bufp += ETHER_ADDR_LEN;
< 		cnt--;
< 	}
---
> 			netdev_for_each_mc_addr(ha, dev) {
> #ifdef MCAST_LIST_ACCUMULATION
> 				if (!cnt_iface[i])
898,902c962,988
< 	for (mclist = dev->mc_list; (mclist && (cnt > 0)); cnt--, mclist = mclist->next) {
< 		memcpy(bufp, (void *)mclist->dmi_addr, ETHER_ADDR_LEN);
< 		bufp += ETHER_ADDR_LEN;
< 	}
< #endif
---
> 				if (!cnt)
> #endif /* MCAST_LIST_ACCUMULATION */
> 					break;
> 				memcpy(bufp, ha->addr, ETHER_ADDR_LEN);
> 				bufp += ETHER_ADDR_LEN;
> #ifdef MCAST_LIST_ACCUMULATION
> 				DHD_TRACE(("_dhd_set_multicast_list: cnt %d %02x:%02x:%02x:%02x:%02x:%02x\n",
> 					cnt_iface[i],  ha->addr[0],  ha->addr[1],
> 					ha->addr[2],  ha->addr[3],  ha->addr[4],
> 					ha->addr[5]));	/* Shinuk */
> 				cnt_iface[i]--;
> #else
> 				cnt--;
> #endif /* MCAST_LIST_ACCUMULATION */
> 
> 			}
> #else
> #ifdef MCAST_LIST_ACCUMULATION
> 			for (mclist = dev->mc_list; (mclist && (cnt_iface[i] > 0)); cnt_iface[i]--, mclist = mclist->next) {
> #else
> 			for (mclist = dev->mc_list; (mclist && (cnt > 0)); cnt--, mclist = mclist->next) {
> #endif /* MCAST_LIST_ACCUMULATION */
> 				memcpy(bufp, (void *)mclist->dmi_addr, ETHER_ADDR_LEN);
> 				bufp += ETHER_ADDR_LEN;
> 			}
> #endif /* LINUX_VERSION_CODE */
> 
904c990
< 	netif_addr_unlock_bh(dev);
---
> 			netif_addr_unlock_bh(dev);
906a993,997
> #ifdef MCAST_LIST_ACCUMULATION
> 		}
> 	}
> #endif /* MCAST_LIST_ACCUMULATION */
> 
957a1049,1057
> #ifdef MCAST_LIST_ACCUMULATION
> 	allmulti = 0;
> 	for (i = 0; i < DHD_MAX_IFS; i++) {
> 		if (dhd->iflist[i]) {
> 			dev = dhd->iflist[i]->net;
> 			allmulti |= (dev->flags & IFF_PROMISC) ? TRUE : FALSE;
> 		}
> 	}
> #else
958a1059,1060
> #endif /* MCAST_LIST_ACCUMULATION */
> 
1058a1161
> 					ifp->event2cfg80211 = TRUE;
1143a1247,1249
> #ifdef MCAST_LIST_ACCUMULATION
> 		bool set_multicast = FALSE;
> #endif /* MCAST_LIST_ACCUMULATION */
1170c1276
< 				if (in_ap && dhd->set_macaddress)  {
---
> 				if (in_ap && dhd->set_macaddress == i+1)  {
1173c1279
< 					dhd->set_macaddress = FALSE;
---
> 					dhd->set_macaddress = 0;
1183a1290,1291
> 				if (dhd->pub.up == 0)
> 					continue;
1185a1294,1296
> #ifdef MCAST_LIST_ACCUMULATION
> 					set_multicast = TRUE;
> #else
1186a1298,1299
> #endif /* MCAST_LIST_ACCUMULATION */
> 
1188,1189c1301,1302
< 				if (dhd->set_macaddress) {
< 					dhd->set_macaddress = FALSE;
---
> 				if (dhd->set_macaddress == i+1) {
> 					dhd->set_macaddress = 0;
1193a1307,1310
> #ifdef MCAST_LIST_ACCUMULATION
> 		if (set_multicast)
> 			_dhd_set_multicast_list(dhd, 0);
> #endif /* MCAST_LIST_ACCUMULATION */
1217c1334
< 	dhd->set_macaddress = TRUE;
---
> 	dhd->set_macaddress = ifidx+1;
1359a1477,1495
> #ifdef CUSTOMER_HW_SAMSUNG
> 	/*
> 	 * CSP #506108
> 	 *   kernel panic issue when first bootup time,
> 	 *   rmmod without interface down make unnecessary hang event.
> 	 */
> 	if (dhd->pub.busstate == DHD_BUS_DOWN) {
> 		DHD_ERROR(("%s: xmit rejected pub.up=%d busstate=%d \n",
> 			__FUNCTION__, dhd->pub.up, dhd->pub.busstate));
> 		netif_stop_queue(net);
> 		/* Send Event when bus down detected during data session */
> 		if (dhd->pub.up) {
> 			DHD_ERROR(("%s: Event HANG sent up\n", __FUNCTION__));
> 			net_os_send_hang_message(net);
> 		}
> 		DHD_OS_WAKE_UNLOCK(&dhd->pub);
> 		return -ENODEV;
> 	}
> #else
1371a1508
> #endif
1470a1608,1636
> #ifdef DHD_RX_DUMP
> typedef struct {
> 	uint16 type;
> 	const char *str;
> } PKTTYPE_INFO;
> 
> static const PKTTYPE_INFO packet_type_info[] =
> {
> 	{ ETHER_TYPE_IP, "IP" },
> 	{ ETHER_TYPE_ARP, "ARP" },
> 	{ ETHER_TYPE_BRCM, "BRCM" },
> 	{ ETHER_TYPE_802_1X, "802.1X" },
> 	{ ETHER_TYPE_WAI, "WAPI" },
> 	{ 0, ""}
> };
> 
> static const char *_get_packet_type_str(uint16 type)
> {
> 	int i;
> 	int n = sizeof(packet_type_info)/sizeof(packet_type_info[1]) - 1;
> 	for (i = 0; i < n; i++) {
> 		if (packet_type_info[i].type == type)
> 			return packet_type_info[i].str;
> 	}
> 
> 	return packet_type_info[n].str;
> }
> #endif /* DHD_RX_DUMP */
> 
1482c1648,1655
< 	int tout = DHD_PACKET_TIMEOUT;
---
> 	int tout = DHD_PACKET_TIMEOUT_MS;
> #ifdef DHD_RX_DUMP
> #ifdef DHD_RX_FULL_DUMP
> 	int k;
> #endif /* DHD_RX_FULL_DUMP */
> 	char *dump_data;
> 	uint16 protocol;
> #endif /* DHD_RX_DUMP */
1553a1727,1768
> #ifdef DHD_RX_DUMP
> 		dump_data = skb->data;
> 		protocol = (dump_data[12] << 8) | dump_data[13];
> 		DHD_ERROR(("RX DUMP - %s\n", _get_packet_type_str(protocol)));
> #ifdef DHD_RX_FULL_DUMP
> 		if (protocol != ETHER_TYPE_BRCM) {
> 			for (k = 0; k < skb->len; k++) {
> 				DHD_ERROR(("%02X ", dump_data[k]));
> 				if ((k & 15) == 15)
> 					DHD_ERROR(("\n"));
> 			}
> 			DHD_ERROR(("\n"));
> 		}
> #endif /* DHD_RX_FULL_DUMP */
> 		if (protocol != ETHER_TYPE_BRCM) {
> 			if (dump_data[0] == 0xFF) {
> 				DHD_ERROR(("%s: BROADCAST\n", __FUNCTION__));
> 
> 				if ((dump_data[12] == 8) &&
> 					(dump_data[13] == 6)) {
> 					DHD_ERROR(("%s: ARP %d\n",
> 						__FUNCTION__, dump_data[0x15]));
> 				}
> 			} else if (dump_data[0] & 1) {
> 				DHD_ERROR(("%s: MULTICAST: "
> 					"%02X:%02X:%02X:%02X:%02X:%02X\n",
> 					__FUNCTION__, dump_data[0],
> 					dump_data[1], dump_data[2],
> 					dump_data[3], dump_data[4],
> 					dump_data[5]));
> 			}
> 
> 			if (protocol == ETHER_TYPE_802_1X) {
> 				DHD_ERROR(("ETHER_TYPE_802_1X: "
> 					"ver %d, type %d, replay %d\n",
> 					dump_data[14], dump_data[15],
> 					dump_data[30]));
> 			}
> 		}
> 
> #endif /* DHD_RX_DUMP */
> 
1591c1806
< 			tout = DHD_EVENT_TIMEOUT;
---
> 			tout = DHD_EVENT_TIMEOUT_MS;
1599d1813
< 		/* FIX: fix crash for now; can net be NULL?? */
1771a1986,1989
> 	/* To avoid kernel panic */
> 	if (!dhd->wd_timer_valid)
> 		return;
> 
2127c2345
< 		DHD_OS_WAKE_LOCK_TIMEOUT_ENABLE(&dhd->pub, DHD_EVENT_TIMEOUT);
---
> 		DHD_OS_WAKE_LOCK_TIMEOUT_ENABLE(&dhd->pub, DHD_EVENT_TIMEOUT_MS);
2182c2400
< 			DHD_TRACE(("%s: ioc.len=0, returns BCME_BADARG \n", __func__));
---
> 			DHD_TRACE(("%s: ioc.len=0, returns BCME_BADARG \n", __FUNCTION__));
2374c2592
< 	DHD_TRACE(("%s: Enter\n", __FUNCTION__));
---
> 	DHD_TRACE(("%s: Enter %p\n", __FUNCTION__, net));
2407c2625,2627
< 	if (ifidx == 0 && !dhd_download_fw_on_driverload)
---
> 	if (ifidx == 0 &&
> 		(!dhd_download_fw_on_driverload ||
> 		(suspend_power_off && dhd->pub.busstate != DHD_BUS_DOWN)))
2409c2629
< #endif
---
> #endif /* WL_CFG80211 */
2423c2643,2645
< 
---
> #ifdef PROP_TXSTATUS
> 	uint up = 0;
> #endif
2434c2656
< 	if ((firmware_path != NULL) && (firmware_path[0] != '\0')) {
---
> 	if ((strlen(firmware_path) != 0) && (firmware_path[0] != '\0')) {
2438,2443c2660,2666
< 		if (dhd_download_fw_on_driverload &&
< 			strcmp(fw_path, firmware_path)) {
< 			DHD_ERROR(("firmware path changed:%s --> %s\n",
< 				fw_path, firmware_path));
< 			fw_changed = TRUE;
< 		}
---
> 				if (dhd_download_fw_on_driverload &&
> 					strcmp(fw_path, firmware_path))
> 				{
> 					DHD_ERROR(("firmware path changed:%s --> %s\n",
> 						fw_path, firmware_path));
> 					fw_changed = TRUE;
> 				}
2445c2668
< 		strcpy(fw_path, firmware_path);
---
> 			strcpy(fw_path, firmware_path);
2447,2448c2670,2671
< 		strcpy(fw_down_path, fw_path);
< 		strcat(fw_down_path, chipver_tag);
---
> 			strcpy(fw_down_path, fw_path);
> 			strcat(fw_down_path, chipver_tag);
2482c2705,2709
< 			wl_android_wifi_on(net);
---
> 			ret = wl_android_wifi_on(net);
> 			if (ret != 0) {
> 				DHD_ERROR(("wl_android_wifi_on failed (%d)\n", ret));
> 				goto exit;
> 			}
2484c2711
< 			if (fw_changed) {
---
> 			if (fw_changed || suspend_power_off) {
2487c2714,2718
< 				wl_android_wifi_on(net);
---
> 				ret = wl_android_wifi_on(net);
> 				if (ret != 0) {
> 					DHD_ERROR(("wl_android_wifi_on failed (%d)\n", ret));
> 					goto exit;
> 				}
2490c2721
< #endif
---
> #endif /* WL_CFG80211 */
2519a2751,2756
> 
> 		/* CSP#505233: Flags to indicate if we distingish power off policy when
> 		 * user set the memu "Keep Wi-Fi on during sleep" to "Never"
> 		 */
> 		if (!suspend_power_off)
> 			suspend_power_off = TRUE;
2536a2774,2799
> int dhd_do_driver_init(struct net_device *net)
> {
> 	dhd_info_t *dhd = NULL;
> 
> 	if (!net) {
> 		DHD_ERROR(("Primary Interface not initialized \n"));
> 		return -EINVAL;
> 	}
> 
> 	dhd = *(dhd_info_t **)netdev_priv(net);
> 
> 	/* If driver is already initialized, do nothing
> 	 */
> 	if (dhd->pub.busstate == DHD_BUS_DATA) {
> 		DHD_TRACE(("Driver already Inititalized. Nothing to do"));
> 		return 0;
> 	}
> 
> 	if (dhd_open(net) < 0) {
> 		DHD_ERROR(("Driver Init Failed \n"));
> 		return -1;
> 	}
> 
> 	return 0;
> }
> 
2550a2814
> 	dhd_registration_check = FALSE;
2551a2816
> 	up(&dhd_chipup_sem);
2578a2844
> 	ifp->event2cfg80211 = FALSE;
2593a2860,2862
> 	if (ifidx == 0) {
> 		ifp->event2cfg80211 = TRUE;
> 	}
2658c2927,2928
< 	} else {
---
> 		}
> 		else {
2665c2935
< 	if ((firmware_path != NULL) && (firmware_path[0] != '\0'))
---
> 	if ((strlen(firmware_path) != 0) && (firmware_path[0] != '\0'))
2667c2937
< 	if ((nvram_path != NULL) && (nvram_path[0] != '\0'))
---
> 	if ((strlen(nvram_path) != 0) && (nvram_path[0] != '\0'))
2731d3000
< 	dhd->pub.wlfc_enabled = TRUE;
2901c3170
< 				__func__, down_path, nv_path));
---
> 			           __FUNCTION__, down_path, nv_path));
2980c3249
< 	dhd_read_macaddr(dhd);
---
> 	dhd_read_macaddr(dhd, &dhd->pub.mac);
2999a3269,3272
> #ifdef RDWR_KORICS_MACADDR
> dhd_write_rdwr_korics_macaddr(dhd, &dhd->pub.mac);
> #endif
> 
3011a3285,3320
> #if !defined(AP) && defined(WLP2P)
> /* For Android ICS MR2 release, the concurrent mode is enabled by default and the firmware
>  * name would be fw_bcmdhd.bin. So we need to determine whether P2P is enabled in the STA
>  * firmware and accordingly enable concurrent mode (Apply P2P settings). SoftAP firmware
>  * would still be named as fw_bcmdhd_apsta.
>  */
> bool
> dhd_concurrent_fw(dhd_pub_t *dhd)
> {
> 	int i, ret = 0;
> 	char buf[WLC_IOCTL_SMLEN];
> 	char *cap[] = {"p2p", "mchan", "dsta", NULL};
> 	if ((!op_mode) && (strstr(fw_path, "_p2p") == NULL) &&
> 		(strstr(fw_path, "_apsta") == NULL)) {
> 		/* Given path is for the STA firmware. Check whether VSDB + P2P support
> 		 * is present in  the firmware. If so, set mode as P2P (concurrent support).
> 		 */
> 		for (i = 0; cap[i] != NULL; ) {
> 			memset(buf, 0, sizeof(buf));
> 			bcm_mkiovar(cap[i++], 0, 0, buf, sizeof(buf));
> 			if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_GET_VAR, buf, sizeof(buf),
> 				FALSE, 0)) < 0) {
> 				DHD_TRACE(("%s: Get VSDB Capability(%s) failed (error=%d)\n",
> 					__FUNCTION__, cap[i-1], ret));
> 				return 0;
> 			} else if (buf[0] != 1) {
> 				DHD_TRACE(("VSDB(%s) is not supported , ret : %d\n",
> 					cap[i-1], buf[0]));
> 				return 0;
> 			}
> 		}
> 		return 1;
> 	}
> 	return 0;
> }
> #endif /* !defined(AP) && defined(WLP2P) */
3021a3331,3335
> #if defined(BCM4334_CHIP)
> 	uint32 glom = 5; /* 2012.02.21 for perfomance */
> #elif defined(BCM43241_CHIP)
> 	uint32 glom = 1;
> #else
3022a3337,3340
> #endif
> #if defined(VSDB) || defined(ROAM_ENABLE)
> 	uint bcn_timeout = 8;
> #else
3023a3342
> #endif
3047c3366
< #endif
---
> #endif /* ROAM_ENABLE */
3055d3373
< 
3064a3383
> 	struct ether_addr p2p_ea;
3068a3388,3390
> #ifdef OKC_SUPPORT
> 	uint32 okc = 1;
> #endif /* OKC_SUPPORT */
3072a3395,3405
> #ifdef BCM43241_CHIP
> 	int mimo_bw_cap = 1;
> #endif /* BCM43241_CHIP */
> 
> #ifdef PROP_TXSTATUS
> 	dhd->wlfc_enabled = FALSE;
> 	/* enable WLFC only if the firmware is VSDB */
> #endif /* PROP_TXSTATUS */
> #ifdef AUTOCOUNTRY
> 	int autocountry = 1;
> #endif
3104c3437
< 	if (strstr(fw_path, "_apsta") != NULL) {
---
> 	if ((!op_mode && strstr(fw_path, "_apsta") != NULL) || (op_mode == 0x02)) {
3128c3461,3462
< 	if (strstr(fw_path, "_p2p") != NULL) {
---
> 	if ((!op_mode && strstr(fw_path, "_p2p") != NULL) || (op_mode == 0x04) ||
> 		(dhd_concurrent_fw(dhd))) {
3133c3467
< 		} else {
---
> 		} else if (!dhd_concurrent_fw(dhd)) {
3139a3474,3484
> 
> 		memcpy(&p2p_ea, &dhd->mac, ETHER_ADDR_LEN);
> 		ETHER_SET_LOCALADDR(&p2p_ea);
> 		bcm_mkiovar("p2p_da_override", (char *)&p2p_ea,
> 			ETHER_ADDR_LEN, iovbuf, sizeof(iovbuf));
> 		if ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR,
> 			iovbuf, sizeof(iovbuf), TRUE, 0)) < 0) {
> 			DHD_ERROR(("%s p2p_da_override ret= %d\n", __FUNCTION__, ret));
> 		} else {
> 			DHD_INFO(("dhd_preinit_ioctls: p2p_da_override succeeded\n"));
> 		}
3141c3486
< #endif
---
> #endif /* (ARP_OFFLOAD_SUPPORT) */
3145c3490
< 	if (strstr(fw_path, "_apsta") != NULL) {
---
> 	if ((!op_mode && strstr(fw_path, "_apsta") != NULL) || (op_mode == 0x02)) {
3167c3512
< #endif
---
> #endif /* CUSTOMER_HW_SAMSUNG */
3181c3526
< #endif
---
> #endif /* (ARP_OFFLOAD_SUPPORT) */
3186a3532,3534
> 		if (dhd_concurrent_fw(dhd)) {
> 			dhd->op_mode |= WFD_MASK;
> 		}
3188,3194c3536,3538
< /*
< 	DHD_ERROR(("Firmware up: op_mode=%d, "
< 			"Broadcom Dongle Host Driver mac=%.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
< 			dhd->op_mode,
< 			dhd->mac.octet[0], dhd->mac.octet[1], dhd->mac.octet[2],
< 			dhd->mac.octet[3], dhd->mac.octet[4], dhd->mac.octet[5]));
< */
---
> 
> 	DHD_ERROR(("Firmware up: op_mode=%d", dhd->op_mode));
> 
3209c3553
< /* Disable built-in roaming to allowed ext supplicant to take care of roaming */
---
> 	/* Disable built-in roaming to allowed ext supplicant to take care of roaming */
3211a3556
> 
3213,3214c3558
< 	dhd_wl_ioctl_cmd(dhd, WLC_SET_ROAM_TRIGGER, roam_trigger,
< 			sizeof(roam_trigger), TRUE, 0);
---
> 	dhd_wl_ioctl_cmd(dhd, WLC_SET_ROAM_TRIGGER, roam_trigger, sizeof(roam_trigger), TRUE, 0);
3216,3220c3560,3562
< 			sizeof(roam_scan_period), TRUE, 0);
< 	dhd_wl_ioctl_cmd(dhd, WLC_SET_ROAM_DELTA, roam_delta,
< 			sizeof(roam_delta), TRUE, 0);
< 	bcm_mkiovar("fullroamperiod", (char *)&roam_fullscan_period, 4, iovbuf,
< 			sizeof(iovbuf));
---
> 		sizeof(roam_scan_period), TRUE, 0);
> 	dhd_wl_ioctl_cmd(dhd, WLC_SET_ROAM_DELTA, roam_delta, sizeof(roam_delta), TRUE, 0);
> 	bcm_mkiovar("fullroamperiod", (char *)&roam_fullscan_period, 4, iovbuf, sizeof(iovbuf));
3222a3565,3568
> 
> #ifdef OKC_SUPPORT
> 	bcm_mkiovar("okc_enable", (char *)&okc, 4, iovbuf, sizeof(iovbuf));
> 	dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
3224a3571,3577
> #ifdef AUTOCOUNTRY
> 	bcm_mkiovar("autocountry", (char *)&autocountry, 4, iovbuf, sizeof(iovbuf));
> 	dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
> #endif
> 
> #endif /* CUSTOMER_HW_SAMSUNG */
> 
3253a3607,3611
> #ifdef BCM43241_CHIP
> 	bcm_mkiovar("mimo_bw_cap", (char *)&mimo_bw_cap, 4, iovbuf, sizeof(iovbuf));
> 	dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);
> #endif
> 
3267a3626
> 	if ((dhd->op_mode & HOSTAPD_MASK) != HOSTAPD_MASK) {
3270a3630
> 		}
3321a3682,3684
> #ifdef OKC_DEBUG
> 	setbit(eventmask, WLC_E_ROAM_START);
> #endif /* OKC_DEBUG */
3344d3706
< 		dhd_arp_offload_set(dhd, dhd_arp_mode);
3345a3708
> 		dhd_arp_offload_set(dhd, dhd_arp_mode);
3347d3709
< 		dhd_arp_offload_set(dhd, 0);
3348a3711
> 		dhd_arp_offload_set(dhd, 0);
3354a3718,3724
> #ifdef GAN_LITE_NAT_KEEPALIVE_FILTER
> 	/* Setup filter to block broadcast and NAT Keepalive packets */
> 	dhd->pktfilter[0] = "100 0 0 0 0xffffff 0xffffff"; /* discard all broadcast packets */
> 	dhd->pktfilter[1] = "102 0 0 36 0xffffffff 0x11940009"; /* discard NAT Keepalive packets */
> 	dhd->pktfilter[2] = "104 0 0 38 0xffffffff 0x11940009"; /* discard NAT Keepalive packets */
> 	dhd->pktfilter[3] = NULL;
> #else
3355a3726,3732
> #if defined(CUSTOMER_HW_SAMSUNG)
> 	dhd->pktfilter[0] = "100 0 0 0 "
> 		HEX_PREF_STR UNI_FILTER_STR ZERO_ADDR_STR ETHER_TYPE_STR IPV6_FILTER_STR
> 		" "
> 		HEX_PREF_STR ZERO_ADDR_STR ZERO_ADDR_STR ETHER_TYPE_STR ZERO_TYPE_STR;
> #else
> #error Customer want to filter out all IPV6 packets
3356a3734
> #endif
3359a3738
> #endif /* GAN_LITE_NAT_KEEPALIVE_FILTER */
3374a3754,3758
> #ifdef GLOBALCONFIG_WLAN_COUNTRY_CODE
> 	if (dhd_customer_set_country(dhd) < 0)
> 		DHD_ERROR(("%s: can't set country \n", __FUNCTION__));
> #endif
> 
3654,3660c4038,4039
< 	/*
< 	printf("Broadcom Dongle Host Driver: register interface [%s]"
< 		" MAC: %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
< 		net->name,
< 		net->dev_addr[0], net->dev_addr[1], net->dev_addr[2],
< 		net->dev_addr[3], net->dev_addr[4], net->dev_addr[5]);
< 		*/
---
> 	printf("Broadcom Dongle Host Driver: register interface [%s]",
> 		net->name);
3668c4047,4048
< 	up(&dhd_registration_sem);
---
> 		dhd_registration_check = TRUE;
> 		up(&dhd_registration_sem);
3727a4108,4116
> #ifdef CUSTOMER_HW_SAMSUNG
> 	/*
> 	 * CSP #506108
> 	 *   kernel panic issue when first bootup time,
> 	 *   rmmod without interface down make unnecessary hang event.
> 	 */
> 	dhd->pub.up = 0;
> #endif
> 
3733a4123,4133
> #ifdef CUSTOMER_HW_SAMSUNG
> 	/* CSP#482857: Change the location of dhd_bus_detach()
> 	 * to avoid Kernel panic problem
> 	 */
> 	if (dhd->dhd_state & DHD_ATTACH_STATE_PROT_ATTACH) {
> 		dhd_bus_detach(dhdp);
> 
> 		if (dhdp->prot)
> 			dhd_prot_detach(dhdp);
> 	}
> #endif /* CUSTOMER_HW_SAMSUNG */
3754c4154
< 	if (dhd->thr_sysioc_ctl.thr_pid >= 0)
---
> 	if (dhd->thr_sysioc_ctl.thr_pid >= 0) {
3755a4156
> 	}
3772a4174,4177
> 		ASSERT(ifp->net);
> 		if (ifp && ifp->net)
> 		{
> 
3774c4179
< 		if (ifp->net->open)
---
> 			if (ifp->net->open)
3776c4181
< 		if (ifp->net->netdev_ops == &dhd_ops_pri)
---
> 			if (ifp->net->netdev_ops == &dhd_ops_pri)
3778,3779c4183
< 		{
< 			if (ifp->net) {
---
> 			{
3782a4187,4188
> 				MFREE(dhd->pub.osh, ifp, sizeof(*ifp));
> 				dhd->iflist[0] = NULL;
3784,3785d4189
< 			MFREE(dhd->pub.osh, ifp, sizeof(*ifp));
< 			dhd->iflist[0] = NULL;
3809a4214
> #ifndef CUSTOMER_HW_SAMSUNG
3815a4221
> #endif /* CUSTOMER_HW_SAMSUNG */
3891a4298,4302
> #if 1 && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
> 	int retry = POWERUP_MAX_RETRY;
> 	int chip_up = 0;
> #endif
> 
3896c4307
< #ifdef DHDTHREAD
---
> #if defined(DHDTHREAD)
3910c4321
< #endif /* DHDTHREAD */
---
> #endif
3912c4323,4353
< 	/* Call customer gpio to turn on power with WL_REG_ON signal */
---
> #if 1 && defined(BCMLXSDMMC) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
> 	do {
> 		sema_init(&dhd_chipup_sem, 0);
> 		dhd_bus_reg_sdio_notify(&dhd_chipup_sem);
> 		dhd_customer_gpio_wlan_ctrl(WLAN_POWER_ON);
> #if defined(CONFIG_WIFI_CONTROL_FUNC)
> 		if (wl_android_wifictrl_func_add() < 0) {
> 			dhd_bus_unreg_sdio_notify();
> 			goto fail_1;
> 		}
> #endif /* defined(CONFIG_WIFI_CONTROL_FUNC) */
> 		if (down_timeout(&dhd_chipup_sem,
> 			msecs_to_jiffies(POWERUP_WAIT_MS)) == 0) {
> 			dhd_bus_unreg_sdio_notify();
> 			chip_up = 1;
> 			break;
> 		}
> 		DHD_ERROR(("\nfailed to power up wifi chip, retry again (%d left) **\n\n",
> 			retry+1));
> 		dhd_bus_unreg_sdio_notify();
> #if defined(CONFIG_WIFI_CONTROL_FUNC)
> 		wl_android_wifictrl_func_del();
> #endif /* defined(CONFIG_WIFI_CONTROL_FUNC) */
> 		dhd_customer_gpio_wlan_ctrl(WLAN_POWER_OFF);
> 	} while (retry-- > 0);
> 
> 	if (!chip_up) {
> 		DHD_ERROR(("\nfailed to power up wifi chip, max retry reached, exits **\n\n"));
> 		return -ENODEV;
> 	}
> #else
3913a4355,4359
> #if defined(CONFIG_WIFI_CONTROL_FUNC)
> 	if (wl_android_wifictrl_func_add() < 0)
> 		goto fail_1;
> #endif /* defined(CONFIG_WIFI_CONTROL_FUNC) */
> #endif /* BCMLXSDMMC */
3915c4361
< #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
---
> #if 1 && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
3921c4367
< 		printf("\n%s\n", dhd_version);
---
> 		DHD_TRACE(("%s: \n%s\n", __FUNCTION__, dhd_version));
3927,3931d4372
< #if defined(CONFIG_WIFI_CONTROL_FUNC)
< 	if (wl_android_wifictrl_func_add() < 0)
< 		goto fail_1;
< #endif
< 
3939c4380
< 		error = -EINVAL;
---
> 		error = -ENODEV;
3943c4384,4390
< #endif
---
> 	if (dhd_registration_check != TRUE)
> 	{
> 		error = -ENODEV;
> 		DHD_ERROR(("%s: sdio_register_driver fail\n", __FUNCTION__));
> 		goto fail_2;
> 	}
> #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
3946c4393
< #endif
---
> #endif /* defined(WL_CFG80211) */
3949c4396,4397
< #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && 1
---
> 
> #if 1 && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
3952a4401
> 
3953a4403
> 
3968a4419
> 
4269c4720,4726
< 
---
> 	if ((ntoh32(event->event_type) == WLC_E_IF) &&
> 		(((dhd_if_event_t *)*data)->action == WLC_E_IF_ADD))
> 		/* If ADD_IF has been called directly by wl utility then we
> 		 * should not report this. In case if ADD_IF was called from
> 		 * CFG stack, then too this event need not be reported back
> 		 */
> 		return (BCME_OK);
4281c4738
< 	if (dhd->iflist[*ifidx]->net) {
---
> 	if (dhd->iflist[*ifidx]->event2cfg80211 && dhd->iflist[*ifidx]->net) {
4469a4927
> #ifndef GAN_LITE_NAT_KEEPALIVE_FILTER
4486a4945,4948
> #if defined(CUSTOMER_HW_SAMSUNG)
> /* customer want to use NO IPV6 packets only */
> 			return ret;
> #endif
4494a4957,4959
> #else
> 	return 0;
> #endif /* GAN_LITE_NAT_KEEPALIVE_FILTER */
4520a4986,4988
> 	 /* Writing STA's MAC ID to the Dongle for SOFTAP */
> 	 if (_dhd_set_mac_address(dhd, 0, &dhd->pub.mac) == 0)
> 		 DHD_INFO(("dhd_bus_start: MAC ID is overwritten\n"));
4579a5048,5051
> #if !defined(CUSTOMER_HW_SAMSUNG)
> #error do not use these it cause kernel panic
> 			dev_close(dev);
> 			dev_open(dev);
4580a5053
> #endif /* WL_CFG80211 */
4718c5191
< 				dhd->wakelock_timeout_enable * HZ);
---
> 				msecs_to_jiffies(dhd->wakelock_timeout_enable));
4810a5284,5298
> int dhd_os_check_wakelock(void *dhdp)
> {
> #ifdef CONFIG_HAS_WAKELOCK
> 	dhd_pub_t *pub = (dhd_pub_t *)dhdp;
> 	dhd_info_t *dhd;
> 
> 	if (!pub)
> 		return 0;
> 	dhd = (dhd_info_t *)(pub->info);
> 
> 	if (dhd && wake_lock_active(&dhd->wl_wifi))
> 		return 1;
> #endif
> 	return 0;
> }
4869,4870c5357
<        ewlfc_mac_entry_action_t action, uint8 ifid, uint8 iftype,
< 	uint8* ea)
---
> 	ewlfc_mac_entry_action_t action, uint8 ifid, uint8 iftype, uint8* ea)
diff -r update5/drivers/net/wireless/bcmdhd/src/dhd/sys/dhd_proto.h update6/drivers/net/wireless/bcmdhd/src/dhd/sys/dhd_proto.h
56a57,60
> #ifdef PROP_TXSTATUS
> extern int dhd_wlfc_init(dhd_pub_t *dhd);
> extern void dhd_wlfc_deinit(dhd_pub_t *dhd);
> #endif
diff -r update5/drivers/net/wireless/bcmdhd/src/dhd/sys/dhd_sdio.c update6/drivers/net/wireless/bcmdhd/src/dhd/sys/dhd_sdio.c
2c2
<  * DHD Bus Module for SDIO (Linux)
---
>  * DHD Bus Module for SDIO
4c4
<  * Copyright (C) 1999-2011, Broadcom Corporation
---
>  * Copyright (C) 1999-2012, Broadcom Corporation
24c24
<  * $Id: dhd_sdio.c 306660 2012-01-06 22:39:46Z $
---
>  * $Id: dhd_sdio.c 309548 2012-01-20 01:13:08Z $
147a148,151
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
> DEFINE_MUTEX(_dhd_sdio_mutex_lock_);
> #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
> 
172c176,187
< #define CC_PLL_CHIPCTRL_AOS_PMU_WAKEUP	(1  << 2)
---
> #define	SR_ENAB(bus)			((bus)->_srenab)
> #define	SLPAUTO_ENAB(bus)		((SR_ENAB(bus)) && ((bus)->_slpauto))
> #define	MIN_RSRC_ADDR			(SI_ENUM_BASE + 0x618)
> #define	MIN_RSRC_SR			0x3
> #define	CORE_CAPEXT_ADDR		(SI_ENUM_BASE + 0x64c)
> #define	CORE_CAPEXT_SR_SUPPORTED_MASK	(1 << 1)
> 
> #define	OOB_WAKEUP_ENAB(bus)		((bus)->_oobwakeup)
> #define	GPIO_DEV_SRSTATE		16	/* Host gpio17 mapped to device gpio0 SR state */
> #define	GPIO_DEV_SRSTATE_TIMEOUT	320000	/* 320ms */
> #define	GPIO_DEV_WAKEUP			17	/* Host gpio17 mapped to device gpio1 wakeup */
> #define	CC_CHIPCTRL2_GPIO1_WAKEUP	(1  << 0)
190a206
> 	uint32		srmemsize;		/* Size of SRMEM */
251a268,270
> #ifdef DHD_USE_IDLECOUNT
> 	int32		dhd_idlecount;		/* DHD idle count */
> #endif /* DHD_USE_IDLECOUNT */
321a341,343
> 	bool		_slpauto;
> 	bool		_oobwakeup;
> 	bool		_srenab;
493a516
> static int dhdsdio_devcap_set(dhd_bus_t *bus, uint8 cap);
559a583,679
> #ifdef USE_OOB_GPIO1
> static int
> dhdsdio_oobwakeup_init(dhd_bus_t *bus)
> {
> 	uint32 val, addr, data;
> 
> 	bcmsdh_gpioouten(bus->sdh, GPIO_DEV_WAKEUP);
> 
> 	addr = SI_ENUM_BASE + OFFSETOF(chipcregs_t, chipcontrol_addr);
> 	data = SI_ENUM_BASE + OFFSETOF(chipcregs_t, chipcontrol_data);
> 
> 	/* Set device for gpio1 wakeup */
> 	bcmsdh_reg_write(bus->sdh, addr, 4, 2);
> 	val = bcmsdh_reg_read(bus->sdh, data, 4);
> 	val |= CC_CHIPCTRL2_GPIO1_WAKEUP;
> 	bcmsdh_reg_write(bus->sdh, data, 4, val);
> 
> 	bus->_oobwakeup = TRUE;
> 
> 	return 0;
> }
> #endif /* USE_OOB_GPIO1 */
> 
> #ifdef BCM4334_CHIP
> /*
>  * Query if FW is in SR mode
>  */
> static bool
> dhdsdio_sr_cap(dhd_bus_t *bus)
> {
> 	bool cap = FALSE;
> 	uint32 min = 0, core_capext;
> 
> 	core_capext = bcmsdh_reg_read(bus->sdh, CORE_CAPEXT_ADDR, 4);
> 	if (!(core_capext & CORE_CAPEXT_SR_SUPPORTED_MASK))
> 		return FALSE;
> 
> 	min = bcmsdh_reg_read(bus->sdh, MIN_RSRC_ADDR, 4);
> 	if (min == MIN_RSRC_SR) {
> 		cap = TRUE;
> 
> 		if ((bus->sih->chip == BCM4334_CHIP_ID) && (bus->sih->chiprev < 3)) {
> 			cap = FALSE;
> 
> 			DHD_ERROR(("Only 4334 >= B2 supports SR: curr rev %d\n",
> 				bus->sih->chiprev));
> 		}
> 	}
> 
> 	return cap;
> }
> 
> static int
> dhdsdio_srwar_init(dhd_bus_t *bus)
> {
> 
> 	bcmsdh_gpio_init(bus->sdh);
> 
> #ifdef USE_OOB_GPIO1
> 	dhdsdio_oobwakeup_init(bus);
> #endif
> 
> 
> 	return 0;
> }
> 
> static int
> dhdsdio_sr_init(dhd_bus_t *bus)
> {
> 	uint8 val;
> 	int err = 0;
> 
> 	if ((bus->sih->chip == BCM4334_CHIP_ID) && (bus->sih->chiprev == 2))
> 		dhdsdio_srwar_init(bus);
> 
> 
> 	val = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_WAKEUPCTRL, NULL);
> 	val |= 1 << SBSDIO_FUNC1_WCTRL_HTWAIT_SHIFT;
> 	bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_WAKEUPCTRL,
> 		1 << SBSDIO_FUNC1_WCTRL_HTWAIT_SHIFT, &err);
> 	val = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_WAKEUPCTRL, NULL);
> 
> 	/* Add CMD14 Support */
> 	dhdsdio_devcap_set(bus,
> 		(SDIOD_CCCR_BRCM_CARDCAP_CMD14_SUPPORT | SDIOD_CCCR_BRCM_CARDCAP_CMD14_EXT));
> 
> 	bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1,
> 		SBSDIO_FUNC1_CHIPCLKCSR, SBSDIO_FORCE_HT, &err);
> 
> 	bus->_slpauto = dhd_slpauto ? TRUE : FALSE;
> 
> 	bus->_srenab = TRUE;
> 
> 	return 0;
> }
> #endif /* BCM4334_CHIP */
> 
568,569d687
< 	int int_val;
< 	uint32 addr, data;
577c695
< 	 * Default is 0 so set it.
---
> 	 * Default is 0 (4334A0) so set it. Fixed in B0.
580,603c698,703
< 	if (val & SBSDIO_FUNC1_SLEEPCSR_KSO_MASK)
< 		return 0;
< 
< 	val |= (SBSDIO_FUNC1_SLEEPCSR_KSO_EN << SBSDIO_FUNC1_SLEEPCSR_KSO_SHIFT);
< 	bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_SLEEPCSR, val, &err);
< 	if (err)
< 		DHD_ERROR(("%s: SBSDIO_FUNC1_SLEEPCSR err: 0x%x\n", __FUNCTION__, err));
< 
< 	/* Set PMU wake-up signal for SDIO AOS */
< 	addr = SI_ENUM_BASE + OFFSETOF(chipcregs_t, chipcontrol_addr);
< 	data = SI_ENUM_BASE + OFFSETOF(chipcregs_t, chipcontrol_data);
< 
< 	bcmsdh_reg_write(bus->sdh, addr, 4, 2);
< 	if (bcmsdh_regfail(bus->sdh))
< 		return BCME_SDIO_ERROR;
< 
< 	int_val = bcmsdh_reg_read(bus->sdh, data, 4);
< 	if (bcmsdh_regfail(bus->sdh))
< 		return BCME_SDIO_ERROR;
< 
< 	int_val |= CC_PLL_CHIPCTRL_AOS_PMU_WAKEUP;
< 	bcmsdh_reg_write(bus->sdh, data, 4, int_val);
< 	if (bcmsdh_regfail(bus->sdh))
< 		return BCME_SDIO_ERROR;
---
> 	if (!(val & SBSDIO_FUNC1_SLEEPCSR_KSO_MASK)) {
> 		val |= (SBSDIO_FUNC1_SLEEPCSR_KSO_EN << SBSDIO_FUNC1_SLEEPCSR_KSO_SHIFT);
> 		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_SLEEPCSR, val, &err);
> 		if (err)
> 			DHD_ERROR(("%s: SBSDIO_FUNC1_SLEEPCSR err: 0x%x\n", __FUNCTION__, err));
> 	}
617a718,719
> 	if (err)
> 		DHD_TRACE(("%s: KSO toggle %d failed: %d\n", __FUNCTION__, on, err));
631d732
< 		err = 0;
654c755
< 			(PMU_MAX_TRANSITION_DLY));
---
> 			(10000));
668c769,776
< 	return bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_SLEEPCSR, NULL);
---
> 	int err = 0;
> 	uint8 val = 0;
> 
> 	val = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_SLEEPCSR, &err);
> 	if (err)
> 		DHD_TRACE(("Failed to read SLEEPCSR: %d\n", err));
> 
> 	return val;
670a779,783
> uint8
> dhdsdio_devcap_get(dhd_bus_t *bus)
> {
> 	return bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_0, SDIOD_CCCR_BRCM_CARDCAP, NULL);
> }
673c786
< dhdsdio_clk_devsleep_iovar(dhd_bus_t *bus, bool on)
---
> dhdsdio_devcap_set(dhd_bus_t *bus, uint8 cap)
676d788
< 	uint8 cur_kso;
677a790,803
> 	bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_0, SDIOD_CCCR_BRCM_CARDCAP, cap, &err);
> 	if (err)
> 		DHD_ERROR(("%s: devcap set err: 0x%x\n", __FUNCTION__, err));
> 
> 	return 0;
> }
> 
> static int
> dhdsdio_clk_devsleep_iovar(dhd_bus_t *bus, bool on)
> {
> 	int err = 0, retry;
> 	uint8 val;
> 
> 	retry = 0;
679,685c805
< 		BUS_WAKE(bus);
< 		cur_kso = dhdsdio_sleepcsr_get(bus);
< 		if (!(cur_kso & SBSDIO_FUNC1_SLEEPCSR_KSO_MASK)) {
< 			DHD_ERROR(("%s: KSO off! 0x%x\n", __FUNCTION__, cur_kso));
< 			bus->kso = FALSE;
< 			return -1;
< 		}
---
> 		/* Enter Sleep */
687c807,817
< 		dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
---
> 		/* Be sure we request clk before going to sleep
> 		 * so we can wake-up with clk request already set
> 		 * else device can go back to sleep immediately
> 		 */
> 		if (!SLPAUTO_ENAB(bus))
> 			dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
> 		else {
> 			val = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, &err);
> 			if ((val & SBSDIO_CSR_MASK) == 0) {
> 				DHD_ERROR(("%s: No clock before enter sleep:0x%x\n",
> 					__FUNCTION__, val));
689c819,828
< 		DHD_ERROR(("%s: clk before sleep: 0x%x\n", __FUNCTION__,
---
> 				/* Reset clock request */
> 				bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
> 					SBSDIO_ALP_AVAIL_REQ, &err);
> 				DHD_ERROR(("%s: clock before sleep:0x%x\n", __FUNCTION__,
> 					bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1,
> 					SBSDIO_FUNC1_CHIPCLKCSR, &err)));
> 			}
> 		}
> 
> 		DHD_TRACE(("%s: clk before sleep: 0x%x\n", __FUNCTION__,
691a831
> #ifdef USE_CMD14
692a833,837
> #else
> 		err = dhdsdio_clk_kso_enab(bus, FALSE);
> 		if (OOB_WAKEUP_ENAB(bus))
> 			err = bcmsdh_gpioout(bus->sdh, GPIO_DEV_WAKEUP, FALSE);  /* GPIO_1 is off */
> #endif
693a839
> 		/* Exit Sleep */
699a846,854
> 		if ((bus->sih->chip == BCM4334_CHIP_ID) && (bus->sih->chiprev == 2)) {
> 			SPINWAIT((bcmsdh_gpioin(bus->sdh, GPIO_DEV_SRSTATE) != TRUE),
> 				GPIO_DEV_SRSTATE_TIMEOUT);
> 
> 			if (bcmsdh_gpioin(bus->sdh, GPIO_DEV_SRSTATE) == FALSE) {
> 				DHD_ERROR(("ERROR: GPIO_DEV_SRSTATE still low!\n"));
> 			}
> 		}
> #ifdef USE_CMD14
700a856,895
> 		if (SLPAUTO_ENAB(bus) && (err != 0)) {
> 			OSL_DELAY(10000);
> 			DHD_TRACE(("%s: Resync device sleep\n", __FUNCTION__));
> 
> 			/* Toggle sleep to resync with host and device */
> 			err = bcmsdh_sleep(bus->sdh, TRUE);
> 			OSL_DELAY(10000);
> 			err = bcmsdh_sleep(bus->sdh, FALSE);
> 
> 			if (err) {
> 				OSL_DELAY(10000);
> 				DHD_ERROR(("%s: CMD14 exit failed again!\n", __FUNCTION__));
> 
> 				/* Toggle sleep to resync with host and device */
> 				err = bcmsdh_sleep(bus->sdh, TRUE);
> 				OSL_DELAY(10000);
> 				err = bcmsdh_sleep(bus->sdh, FALSE);
> 				if (err) {
> 					DHD_ERROR(("%s: CMD14 exit failed twice!\n", __FUNCTION__));
> 					DHD_ERROR(("%s: FATAL: Device non-response!\n",
> 						__FUNCTION__));
> 					err = 0;
> 				}
> 			}
> 		}
> #else
> 		if (OOB_WAKEUP_ENAB(bus))
> 			err = bcmsdh_gpioout(bus->sdh, GPIO_DEV_WAKEUP, TRUE);  /* GPIO_1 is on */
> 
> 		do {
> 			err = dhdsdio_clk_kso_enab(bus, TRUE);
> 			OSL_DELAY(10000);
> 		} while ((err != 0) && (++retry < 3));
> 
> 		if (err != 0) {
> 			DHD_ERROR(("ERROR: kso set failed retry: %d\n", retry));
> 			err = 0; /* continue anyway */
> 		}
> #endif /* !USE_CMD14 */
> 
701a897,898
> 			uint8 csr;
> 
703,706c900,902
< 			SPINWAIT(((dhdsdio_sleepcsr_get(bus)) !=
< 				(SBSDIO_FUNC1_SLEEPCSR_KSO_MASK |
< 				SBSDIO_FUNC1_SLEEPCSR_DEVON_MASK)),
< 				(PMU_MAX_TRANSITION_DLY));
---
> 			SPINWAIT((((csr = dhdsdio_sleepcsr_get(bus)) &
> 				SBSDIO_FUNC1_SLEEPCSR_DEVON_MASK) !=
> 				(SBSDIO_FUNC1_SLEEPCSR_DEVON_MASK)), (10000));
708,709c904,914
< 			DHD_ERROR(("%s: sleepcsr: 0x%x\n", __FUNCTION__,
< 				dhdsdio_sleepcsr_get(bus)));
---
> 			DHD_TRACE(("%s: ExitSleep sleepcsr: 0x%x\n", __FUNCTION__, csr));
> 
> 			if (!(csr & SBSDIO_FUNC1_SLEEPCSR_DEVON_MASK)) {
> 				DHD_ERROR(("%s:ERROR: ExitSleep device NOT Ready! 0x%x\n",
> 					__FUNCTION__, csr));
> 				err = BCME_NODEVICE;
> 			}
> 
> 			SPINWAIT((((csr = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1,
> 				SBSDIO_FUNC1_CHIPCLKCSR, &err)) & SBSDIO_HT_AVAIL) !=
> 				(SBSDIO_HT_AVAIL)), (10000));
711,713d915
< 			/* Request clk after sleep */
< 			BUS_WAKE(bus);
< 			dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
719a922,924
> 	else {
> 		DHD_ERROR(("%s: Sleep request failed: on:%d err:%d\n", __FUNCTION__, on, err));
> 	}
721c926
< 	return 0;
---
> 	return err;
743a949,953
> 	if (SLPAUTO_ENAB(bus)) {
> 		bus->clkstate = (on ? CLK_AVAIL : CLK_SDONLY);
> 		return BCME_OK;
> 	}
> 
747,749d956
< 
< 
< 
827a1035,1037
> #ifdef DHD_USE_IDLECOUNT
> 		bus->dhd_idlecount = 0;
> #endif /* DHD_USE_IDLECOUNT */
837a1048
> 		if (!SR_ENAB(bus)) {
844a1056
> 		}
950a1163,1165
> #ifdef DHD_USE_IDLECOUNT
> 			bus->dhd_idlecount = 0;
> #endif /* DHD_USE_IDLECOUNT */
964c1179,1182
< 		bus->activity = TRUE;
---
> 			bus->activity = TRUE;
> #ifdef DHD_USE_IDLECOUNT
> 			bus->dhd_idlecount = 0;
> #endif /* DHD_USE_IDLECOUNT */
1003a1222
> 	int err = 0;
1016,1020d1234
< 	if (!KSO_ENAB(bus)) {
< 		DHD_ERROR(("%s: KSO off\n", __FUNCTION__));
< 		return BCME_OK;
< 	}
< 
1028,1029c1242,1244
< 		/* Disable SDIO interrupts (no longer interested) */
< 		bcmsdh_intr_disable(bus->sdh);
---
> 		if (!SLPAUTO_ENAB(bus)) {
> 			/* Disable SDIO interrupts (no longer interested) */
> 			bcmsdh_intr_disable(bus->sdh);
1031,1032c1246,1247
< 		/* Make sure the controller has the bus up */
< 		dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
---
> 			/* Make sure the controller has the bus up */
> 			dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
1034,1037c1249,1252
< 		/* Tell device to start using OOB wakeup */
< 		W_SDREG(SMB_USE_OOB, &regs->tosbmailbox, retries);
< 		if (retries > retry_limit)
< 			DHD_ERROR(("CANNOT SIGNAL CHIP, WILL NOT WAKE UP!!\n"));
---
> 			/* Tell device to start using OOB wakeup */
> 			W_SDREG(SMB_USE_OOB, &regs->tosbmailbox, retries);
> 			if (retries > retry_limit)
> 				DHD_ERROR(("CANNOT SIGNAL CHIP, WILL NOT WAKE UP!!\n"));
1039,1040c1254,1255
< 		/* Turn off our contribution to the HT clock request */
< 		dhdsdio_clkctl(bus, CLK_SDONLY, FALSE);
---
> 			/* Turn off our contribution to the HT clock request */
> 			dhdsdio_clkctl(bus, CLK_SDONLY, FALSE);
1042,1043c1257,1258
< 		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
< 		                 SBSDIO_FORCE_HW_CLKREQ_OFF, NULL);
---
> 			bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
> 				SBSDIO_FORCE_HW_CLKREQ_OFF, NULL);
1045,1048c1260,1270
< 		/* Isolate the bus */
< 		if (bus->sih->chip != BCM4329_CHIP_ID && bus->sih->chip != BCM4319_CHIP_ID) {
< 		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL,
< 		                 SBSDIO_DEVCTL_PADS_ISO, NULL);
---
> 			/* Isolate the bus */
> 			if (bus->sih->chip != BCM4329_CHIP_ID &&
> 				bus->sih->chip != BCM4319_CHIP_ID) {
> 				bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL,
> 					SBSDIO_DEVCTL_PADS_ISO, NULL);
> 			}
> 		} else {
> 			/* Leave interrupts enabled since device can exit sleep and
> 			 * interrupt host
> 			 */
> 			err = dhdsdio_clk_devsleep_iovar(bus, TRUE /* sleep */);
1057,1058c1279,1280
< 		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
< 		                 0, NULL);
---
> 		if (!SLPAUTO_ENAB(bus)) {
> 			bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, 0, &err);
1060,1061c1282,1283
< 		/* Force pad isolation off if possible (in case power never toggled) */
< 		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL, 0, NULL);
---
> 			/* Force pad isolation off if possible (in case power never toggled) */
> 			bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL, 0, NULL);
1064,1065c1286,1287
< 		/* Make sure the controller has the bus up */
< 		dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
---
> 			/* Make sure the controller has the bus up */
> 			dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
1067,1070c1289,1292
< 		/* Send misc interrupt to indicate OOB not needed */
< 		W_SDREG(0, &regs->tosbmailboxdata, retries);
< 		if (retries <= retry_limit)
< 			W_SDREG(SMB_DEV_INT, &regs->tosbmailbox, retries);
---
> 			/* Send misc interrupt to indicate OOB not needed */
> 			W_SDREG(0, &regs->tosbmailboxdata, retries);
> 			if (retries <= retry_limit)
> 				W_SDREG(SMB_DEV_INT, &regs->tosbmailbox, retries);
1072,1073c1294,1295
< 		if (retries > retry_limit)
< 			DHD_ERROR(("CANNOT SIGNAL CHIP TO CLEAR OOB!!\n"));
---
> 			if (retries > retry_limit)
> 				DHD_ERROR(("CANNOT SIGNAL CHIP TO CLEAR OOB!!\n"));
1075,1076c1297,1298
< 		/* Make sure we have SD bus access */
< 		dhdsdio_clkctl(bus, CLK_SDONLY, FALSE);
---
> 			/* Make sure we have SD bus access */
> 			dhdsdio_clkctl(bus, CLK_SDONLY, FALSE);
1078,1079c1300,1307
< 		/* Change state */
< 		bus->sleeping = FALSE;
---
> 			/* Enable interrupts again */
> 			if (bus->intr && (bus->dhd->busstate == DHD_BUS_DATA)) {
> 				bus->intdis = FALSE;
> 				bcmsdh_intr_enable(bus->sdh);
> 			}
> 		} else {
> 			err = dhdsdio_clk_devsleep_iovar(bus, FALSE /* wake */);
> 		}
1081,1084c1309,1311
< 		/* Enable interrupts again */
< 		if (bus->intr && (bus->dhd->busstate == DHD_BUS_DATA)) {
< 			bus->intdis = FALSE;
< 			bcmsdh_intr_enable(bus->sdh);
---
> 		if (err == 0) {
> 			/* Change state */
> 			bus->sleeping = FALSE;
1088c1315
< 	return BCME_OK;
---
> 	return err;
1261c1488,1490
< 		if (ret < 0) {
---
> 		if (ret == BCME_NODEVICE) {
> 			DHD_ERROR(("%s: Device asleep already\n", __FUNCTION__));
> 		} else if (ret < 0) {
1314c1543,1549
< 
---
> #ifdef DHD_TX_DUMP
> 	uint8 *dump_data;
> 	uint16 protocol;
> #ifdef DHD_TX_FULL_DUMP
> 	int i;
> #endif /* DHD_TX_FULL_DUMP */
> #endif /* DHD_TX_DUMP */
1332a1568,1587
> #ifdef DHD_TX_DUMP
> 	dump_data = PKTDATA(osh, pkt);
> 	dump_data += 4; /* skip 4 bytes header */
> 	protocol = (dump_data[12] << 8) | dump_data[13];
> #ifdef DHD_TX_FULL_DUMP
> 	DHD_ERROR(("TX DUMP\n"));
> 
> 	for (i = 0; i < (datalen - 4); i++) {
> 		DHD_ERROR(("%02X ", dump_data[i]));
> 		if ((i & 15) == 15)
> 			printk("\n");
> 	}
> 	DHD_ERROR(("\n"));
> 
> #endif /* DHD_TX_FULL_DUMP */
> 	if (protocol == ETHER_TYPE_802_1X) {
> 		DHD_ERROR(("ETHER_TYPE_802_1X: ver %d, type %d, replay %d\n",
> 			dump_data[14], dump_data[15], dump_data[30]));
> 	}
> #endif /* DHD_TX_DUMP */
1453,1454c1708,1709
< 		DHD_ERROR(("%s: KSO off\n", __FUNCTION__));
< 		return 0;
---
> 		DHD_ERROR(("%s: Device asleep\n", __FUNCTION__));
> 		return BCME_NODEVICE;
1608c1863,1865
< 			if (ret < 0) {
---
> 			if (ret == BCME_NODEVICE) {
> 				DHD_ERROR(("%s: Device asleep already\n", __FUNCTION__));
> 			} else if (ret < 0) {
1683,1685c1940,1949
< 		dhd_os_sdlock(bus->dhd);
< 		dhdsdio_checkdied(bus, NULL, 0);
< 		dhd_os_sdunlock(bus->dhd);
---
> #if !defined(CUSTOMER_HW_SAMSUNG)
> #error need debug message if dongle trap occured
> 		if (!SLPAUTO_ENAB(bus)) {
> #endif
> 			dhd_os_sdlock(bus->dhd);
> 			dhdsdio_checkdied(bus, NULL, 0);
> 			dhd_os_sdunlock(bus->dhd);
> #if !defined(CUSTOMER_HW_SAMSUNG)
> 		}
> #endif
1753a2018
> 	IOV_DEVCAP,
1795a2061
> 	{"devcap", IOV_DEVCAP,	0,	IOVT_UINT32,	0 },
2050c2316,2317
< 	int rv;
---
> 	int rv, i;
> 	uint32 shaddr = 0;
2052,2054c2319,2325
< 	/* Read last word in memory to determine address of sdpcm_shared structure */
< 	if ((rv = dhdsdio_membytes(bus, FALSE, bus->ramsize - 4, (uint8 *)&addr, 4)) < 0)
< 		return rv;
---
> 	shaddr = bus->ramsize - 4;
> 
> 	i = 0;
> 	do {
> 		/* Read last word in memory to determine address of sdpcm_shared structure */
> 		if ((rv = dhdsdio_membytes(bus, FALSE, shaddr, (uint8 *)&addr, 4)) < 0)
> 			return rv;
2060,2067c2331,2345
< 	/*
< 	 * Check if addr is valid.
< 	 * NVRAM length at the end of memory should have been overwritten.
< 	 */
< 	if (addr == 0 || ((~addr >> 16) & 0xffff) == (addr & 0xffff)) {
< 		DHD_ERROR(("%s: address (0x%08x) of sdpcm_shared invalid\n", __FUNCTION__, addr));
< 		return BCME_ERROR;
< 	}
---
> 		/*
> 		 * Check if addr is valid.
> 		 * NVRAM length at the end of memory should have been overwritten.
> 		 */
> 		if (addr == 0 || ((~addr >> 16) & 0xffff) == (addr & 0xffff)) {
> 			if ((bus->srmemsize > 0) && (i++ == 0)) {
> 				shaddr -= bus->srmemsize;
> 			} else {
> 				DHD_ERROR(("%s: address (0x%08x) of sdpcm_shared invalid\n",
> 					__FUNCTION__, addr));
> 				return BCME_ERROR;
> 			}
> 		} else
> 			break;
> 	} while (i < 2);
2452c2730
< #endif
---
> #endif /* DHD_DEBUG */
2491c2769,2779
< 		dhdsdio_clk_devsleep_iovar(bus, bool_val);
---
> 		{
> 			dhdsdio_clk_devsleep_iovar(bus, bool_val);
> 			if (!SLPAUTO_ENAB(bus) && (bool_val == FALSE) && (bus->ipend)) {
> 				DHD_ERROR(("INT pending in devsleep 1, dpc_sched: %d\n",
> 					bus->dpc_sched));
> 				if (!bus->dpc_sched) {
> 					bus->dpc_sched = TRUE;
> 					dhd_sched_dpc(bus->dhd);
> 				}
> 			}
> 		}
2848,2850d3135
< 
< 
< 
2941a3227,3239
> 	case IOV_GVAL(IOV_KSO):
> 		int_val = dhdsdio_sleepcsr_get(bus);
> 		bcopy(&int_val, arg, val_size);
> 		break;
> 
> 	case IOV_GVAL(IOV_DEVCAP):
> 		int_val = dhdsdio_devcap_get(bus);
> 		bcopy(&int_val, arg, val_size);
> 		break;
> 
> 	case IOV_SVAL(IOV_DEVCAP):
> 		dhdsdio_devcap_set(bus, (uint8) int_val);
> 		break;
3292,3293c3590
< 	/* Enable clock for device interrupts */
< 	dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
---
> 	if (KSO_ENAB(bus)) {
3295,3298c3592,3593
< 	/* Disable and clear interrupts at the chip level also */
< 	W_SDREG(0, &bus->regs->hostintmask, retries);
< 	local_hostintmask = bus->hostintmask;
< 	bus->hostintmask = 0;
---
> 		/* Enable clock for device interrupts */
> 		dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
3300,3308c3595,3608
< 	/* Force clocks on backplane to be sure F2 interrupt propagates */
< 	saveclk = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, &err);
< 	if (!err) {
< 		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
< 		                 (saveclk | SBSDIO_FORCE_HT), &err);
< 	}
< 	if (err) {
< 		DHD_ERROR(("%s: Failed to force clock for F2: err %d\n", __FUNCTION__, err));
< 	}
---
> 		/* Disable and clear interrupts at the chip level also */
> 		W_SDREG(0, &bus->regs->hostintmask, retries);
> 		local_hostintmask = bus->hostintmask;
> 		bus->hostintmask = 0;
> 
> 		/* Force clocks on backplane to be sure F2 interrupt propagates */
> 		saveclk = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, &err);
> 		if (!err) {
> 			bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
> 			                 (saveclk | SBSDIO_FORCE_HT), &err);
> 		}
> 		if (err) {
> 			DHD_ERROR(("%s: Failed to force clock for F2: err %d\n", __FUNCTION__, err));
> 		}
3310,3313c3610,3613
< 	/* Turn off the bus (F2), free any pending packets */
< 	DHD_INTR(("%s: disable SDIO interrupts\n", __FUNCTION__));
< 	bcmsdh_intr_disable(bus->sdh);
< 	bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_0, SDIOD_CCCR_IOEN, SDIO_FUNC_ENABLE_1, NULL);
---
> 		/* Turn off the bus (F2), free any pending packets */
> 		DHD_INTR(("%s: disable SDIO interrupts\n", __FUNCTION__));
> 		bcmsdh_intr_disable(bus->sdh);
> 		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_0, SDIOD_CCCR_IOEN, SDIO_FUNC_ENABLE_1, NULL);
3315,3316c3615,3617
< 	/* Clear any pending interrupts now that F2 is disabled */
< 	W_SDREG(local_hostintmask, &bus->regs->intstatus, retries);
---
> 		/* Clear any pending interrupts now that F2 is disabled */
> 		W_SDREG(local_hostintmask, &bus->regs->intstatus, retries);
> 	}
3444,3445c3745,3751
< 	/* Restore previous clock setting */
< 	bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR, saveclk, &err);
---
> #ifdef BCM4334_CHIP
> 	if (dhdsdio_sr_cap(bus))
> 		dhdsdio_sr_init(bus);
> 	else
> #endif /* BCM4334_CHIP */
> 		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1,
> 			SBSDIO_FUNC1_CHIPCLKCSR, saveclk, &err);
3472c3778
< 		DHD_ERROR(("%s: KSO off\n", __FUNCTION__));
---
> 		DHD_ERROR(("%s: Device asleep\n", __FUNCTION__));
4021,4025c4327,4331
< 			/* this packet will go up, link back into chain and count it */
< 			PKTSETNEXT(osh, pfirst, pnext);
< 			plast = pfirst;
< 			num++;
< 		}
---
> 				/* this packet will go up, link back into chain and count it */
> 				PKTSETNEXT(osh, pfirst, pnext);
> 				plast = pfirst;
> 				num++;
> 			}
4106a4413,4420
> #ifdef DHDTHREAD
> 		/* tx more to improve rx performance */
> 		if ((bus->clkstate == CLK_AVAIL) && !bus->fcstate &&
> 			pktq_mlen(&bus->txq, ~bus->flowcontrol) && DATAOK(bus)) {
> 			dhdsdio_sendfromq(bus, dhd_txbound);
> 		}
> #endif /* DHDTHREAD */
> 
4626a4941
> 
4773,4774c5088,5089
< 	if (!KSO_ENAB(bus)) {
< 		DHD_ERROR(("%s: KSO off\n", __FUNCTION__));
---
> 	if (!SLPAUTO_ENAB(bus) && !KSO_ENAB(bus)) {
> 		DHD_ERROR(("%s: Device asleep\n", __FUNCTION__));
4779c5094
< 	if (bus->clkstate == CLK_PENDING) {
---
> 	if (!SLPAUTO_ENAB(bus) && (bus->clkstate == CLK_PENDING)) {
4938,4939c5253,5255
< 
< 		if (ret < 0) {
---
> 		if (ret == BCME_NODEVICE) {
> 			DHD_ERROR(("%s: Device asleep already\n", __FUNCTION__));
> 		} else if (ret < 0) {
5053,5055c5369,5375
< 	if (bus->sleeping) {
< 		DHD_ERROR(("INTERRUPT WHILE SLEEPING??\n"));
< 		return;
---
> 	if (!SLPAUTO_ENAB(bus)) {
> 		if (bus->sleeping) {
> 			DHD_ERROR(("INTERRUPT WHILE SLEEPING??\n"));
> 			return;
> 		} else if (!KSO_ENAB(bus)) {
> 			DHD_ERROR(("ISR in devsleep 1\n"));
> 		}
5351a5672,5675
> #ifdef DHD_USE_IDLECOUNT
> #define DHD_IDLE_TIMEOUT_MS (50)
> #endif /* DHD_USE_IDLECOUNT */
> 
5365c5689
< 	if (bus->sleeping)
---
> 	if (!SLPAUTO_ENAB(bus) && bus->sleeping)
5372c5696
< 	if (bus->poll && (++bus->polltick >= bus->pollrate)) {
---
> 	if (!SLPAUTO_ENAB(bus) && (bus->poll && (++bus->polltick >= bus->pollrate))) {
5411a5736,5738
> 			if (SLPAUTO_ENAB(bus))
> 				dhdsdio_bussleep(bus, FALSE);
> 			else
5429d5755
< #ifndef CONFIG_MACH_MIDAS
5431a5758,5780
> #ifdef DHD_USE_IDLECOUNT
> 		if (++bus->idlecount >= bus->idletime) {
> 			bus->idlecount = 0;
> 
> 			if (bus->activity)
> 				bus->activity = FALSE;
> 			else {
> 				bus->dhd_idlecount++;
> 
> 				if (bus->dhd_idlecount >= (DHD_IDLE_TIMEOUT_MS/dhd_watchdog_ms)) {
> 					DHD_TIMER(("%s: DHD Idle state!!\n", __FUNCTION__));
> 
> 					if (SLPAUTO_ENAB(bus)) {
> 						if (dhdsdio_bussleep(bus, TRUE) != BCME_BUSY)
> 							dhd_os_wd_timer(bus->dhd, 0);
> 					} else
> 						dhdsdio_clkctl(bus, CLK_NONE, FALSE);
> 
> 					bus->dhd_idlecount = 0;
> 				}
> 			}
> 		}
> #else
5436c5785,5788
< 				dhdsdio_clkctl(bus, CLK_NONE, FALSE);
---
> 				if (SLPAUTO_ENAB(bus))
> 					dhdsdio_bussleep(bus, TRUE);
> 				else
> 					dhdsdio_clkctl(bus, CLK_NONE, FALSE);
5438a5791
> #endif /* DHD_USE_IDLECOUNT */
5440d5792
< #endif
5573d5924
< 	dhd_cmn_t *cmn;
5577,5579c5928,5938
< #ifdef PROP_TXSTATUS
< 	uint up = 0;
< #endif
---
> 
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
> 
> 	if (mutex_is_locked(&_dhd_sdio_mutex_lock_) == 0) {
> 		DHD_ERROR(("%s : no mutex held. set lock\n", __FUNCTION__));
> 	}
> 	else {
> 		DHD_ERROR(("%s : mutex is locked!. wait for unlocking\n", __FUNCTION__));
> 	}
> 	mutex_lock(&_dhd_sdio_mutex_lock_);
> #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
5617c5976
< 			return NULL;
---
> 			goto forcereturn;
5651c6010
< 			return NULL;
---
> 			goto forcereturn;
5658c6017
< 			return NULL;
---
> 			goto forcereturn;
5675,5678c6034
< 	if (!(cmn = dhd_common_init(osh))) {
< 		DHD_ERROR(("%s: dhd_common_init failed\n", __FUNCTION__));
< 		goto fail;
< 	}
---
> 	dhd_common_init(osh);
5683d6038
< 		dhd_common_deinit(NULL, cmn);
5693,5694d6047
< 	bus->dhd->cmn = cmn;
< 	cmn->dhd = bus->dhd;
5745,5748c6098,6102
< #ifdef PROP_TXSTATUS
< 	if (dhd_download_fw_on_driverload)
< 		dhd_wl_ioctl_cmd(bus->dhd, WLC_UP, (char *)&up, sizeof(up), TRUE, 0);
< #endif
---
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
> 	mutex_unlock(&_dhd_sdio_mutex_lock_);
> 	DHD_ERROR(("%s : the lock is released.\n", __FUNCTION__));
> #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
> 
5752a6107,6113
> 
> forcereturn:
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
> 	mutex_unlock(&_dhd_sdio_mutex_lock_);
> 	DHD_ERROR(("%s : the lock is released.\n", __FUNCTION__));
> #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
> 
5768a6130
> 	bus->sih = NULL;
5783,5785d6144
< 
< 
< 
5894a6254
> 
5900a6261,6262
> 
> 		bus->srmemsize = si_socram_srmem_size(bus->sih);
6071d6432
< 	/* Download the firmware */
6072a6434,6435
> 
> 	/* Download the firmware */
6077a6441
> 
6091a6456,6460
> 		if (bus->dhd) {
> 			dongle_isolation = bus->dhd->dongle_isolation;
> 			dhd_detach(bus->dhd);
> 		}
> 
6097,6099d6465
< 			dhd_common_deinit(bus->dhd, NULL);
< 			dongle_isolation = bus->dhd->dongle_isolation;
< 			dhd_detach(bus->dhd);
6166c6532
< 		if (dongle_isolation == FALSE)
---
> 		if (KSO_ENAB(bus) && (dongle_isolation == FALSE))
6185a6552,6562
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
> 
> 	if (mutex_is_locked(&_dhd_sdio_mutex_lock_) == 0) {
> 		DHD_ERROR(("%s : no mutex held. set lock\n", __FUNCTION__));
> 	}
> 	else {
> 		DHD_ERROR(("%s : mutex is locked!. wait for unlocking\n", __FUNCTION__));
> 	}
> 	mutex_lock(&_dhd_sdio_mutex_lock_);
> #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
> 
6193a6571,6576
> 
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1
> 	mutex_unlock(&_dhd_sdio_mutex_lock_);
> 	DHD_ERROR(("%s : the lock is released.\n", __FUNCTION__));
> #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
> 
6222a6606,6618
> #if defined(BCMLXSDMMC)
> /* Register a dummy SDIO client driver in order to be notified of new SDIO device */
> int dhd_bus_reg_sdio_notify(void* semaphore)
> {
> 	return bcmsdh_reg_sdio_notify(semaphore);
> }
> 
> void dhd_bus_unreg_sdio_notify(void)
> {
> 	bcmsdh_unreg_sdio_notify();
> }
> #endif /* defined(BCMLXSDMMC) */
> 
6381,6384c6777,6778
< 	if (!nvram_file_exists && (bus->nvram_params == NULL)) {
< 		DHD_ERROR(("%s: Cannot find nvram file", __FUNCTION__));
< 		return BCME_ERROR;
< 	}
---
> 	if (!nvram_file_exists && (bus->nvram_params == NULL))
> 		return (0);
6525,6526c6919,6920
< 		DHD_ERROR(("%s: KSO off\n", __FUNCTION__));
< 		return 0;
---
> 		DHD_ERROR(("%s: Device asleep\n", __FUNCTION__));
> 		return BCME_NODEVICE;
6539,6540c6933,6934
< 		DHD_ERROR(("%s: KSO off\n", __FUNCTION__));
< 		return 0;
---
> 		DHD_ERROR(("%s: Device asleep\n", __FUNCTION__));
> 		return BCME_NODEVICE;
6587,6594d6980
< /* Devin - Useless code for now... Why? */
< #if 0
< 			/* save country settinng if was pre-setup with priv ioctl */
< 			dhd_os_proto_block(dhdp);
< 			dhd_wl_ioctl_cmd(bus->dhd, WLC_GET_COUNTRY,
< 				bus->dhd->country_code, sizeof(bus->dhd->country_code), FALSE, 0);
< 			dhd_os_proto_unblock(dhdp);
< #endif
Nur in update6/drivers/net/wireless/bcmdhd/src/dhd/sys: dhd_sec_feature.h.
diff -r update5/drivers/net/wireless/bcmdhd/src/dhd/sys/dhd_wlfc.h update6/drivers/net/wireless/bcmdhd/src/dhd/sys/dhd_wlfc.h
64a65
> 	eWLFC_MAC_ENTRY_ACTION_UPDATE,
diff -r update5/drivers/net/wireless/bcmdhd/src/include/bcmcdc.h update6/drivers/net/wireless/bcmdhd/src/include/bcmcdc.h
73c73,78
< #define	BDC_HEADER_LEN		4
---
> struct bdc_header {
> 	uint8	flags;
> 	uint8	priority;
> 	uint8	flags2;
> 	uint8	dataOffset;
> };
75,76c80
< #define BDC_PROTO_VER_1		1
< #define BDC_PROTO_VER		2
---
> #define	BDC_HEADER_LEN		4
78,79d81
< #define BDC_FLAG_VER_MASK	0xf0
< #define BDC_FLAG_VER_SHIFT	4
81c83
< #define BDC_FLAG__UNUSED	0x03
---
> #define BDC_FLAG_80211_PKT	0x01
83a86,87
> #define BDC_FLAG_VER_MASK	0xf0
> #define BDC_FLAG_VER_SHIFT	4
85,87d88
< #define BDC_PRIORITY_MASK	0x7
< 
< #define BDC_FLAG2_FC_FLAG	0x10
88a90,91
> #define BDC_PRIORITY_MASK	0x07
> #define BDC_PRIORITY_FC_MASK	0xf0
90a94
> 
92a97,109
> #define BDC_FLAG2_FC_FLAG	0x10
> 
> 
> 
> #define BDC_PROTO_VER_1		1
> #define BDC_PROTO_VER		2
> 
> 
> #define BDC_GET_IF_IDX(hdr) \
> 	((int)((((hdr)->flags2) & BDC_FLAG2_IF_MASK) >> BDC_FLAG2_IF_SHIFT))
> #define BDC_SET_IF_IDX(hdr, idx) \
> 	((hdr)->flags2 = (((hdr)->flags2 & ~BDC_FLAG2_IF_MASK) | ((idx) << BDC_FLAG2_IF_SHIFT)))
> 
107,120d123
< 
< #define BDC_GET_IF_IDX(hdr) \
< 	((int)((((hdr)->flags2) & BDC_FLAG2_IF_MASK) >> BDC_FLAG2_IF_SHIFT))
< #define BDC_SET_IF_IDX(hdr, idx) \
< 	((hdr)->flags2 = (((hdr)->flags2 & ~BDC_FLAG2_IF_MASK) | ((idx) << BDC_FLAG2_IF_SHIFT)))
< 
< struct bdc_header {
< 	uint8	flags;
< 	uint8	priority;
< 	uint8	flags2;
< 	uint8	dataOffset;
< };
< 
< #define BDC_PROTO_VER_1		1
diff -r update5/drivers/net/wireless/bcmdhd/src/include/bcmdefs.h update6/drivers/net/wireless/bcmdhd/src/include/bcmdefs.h
30,32d29
< 
< 
< 
43,44d39
< 
< 
60,61d54
< 
< 
96,97d88
< 
< 
156c147
< #endif
---
> #endif  /* BCMDMA64OSL */
174,176d164
< 
< 
< 
195a184,187
> #if defined(NO_BCMDBG_ASSERT)
> # undef BCMDBG_ASSERT
> # undef BCMASSERT_LOG
> #endif
220a213,217
> #ifdef DL_NVRAM
> #define NVRAM_ARRAY_MAXSIZE	DL_NVRAM
> #else
> #define NVRAM_ARRAY_MAXSIZE	MAXSZ_NVRAM_VARS
> #endif
221a219,220
> #ifdef BCMUSBDEV_ENABLED
> extern uint32 gFWID;
222a222,223
> 
> #endif  /* _bcmdefs_h_ */
diff -r update5/drivers/net/wireless/bcmdhd/src/include/bcmdevs.h update6/drivers/net/wireless/bcmdhd/src/include/bcmdevs.h
151a152,154
> #define BCM4360_D11AC_ID	0x43a0
> #define BCM4360_D11AC2G_ID	0x43a1
> #define BCM4360_D11AC5G_ID	0x43a2
242a246
> #define	BCM43460_CHIP_ID	43460
253a258
> #define	BCM43242_CHIP_ID	43242
255a261
> 
460,468c466,475
< #define MUXENAB_I2S			0x00000020
< #define MUXENAB_SFLASH		0x00000040
< #define MUXENAB_RFSWCTRL0	0x00000080
< #define MUXENAB_RFSWCTRL1	0x00000100
< #define MUXENAB_RFSWCTRL2	0x00000200
< #define MUXENAB_SECI		0x00000400
< #define MUXENAB_BT_LEGACY	0x00000800
< #define MUXENAB_HOST_WAKE1	0x00001000
< #define MUXENAB_DEV_WAKE	0x00002000
---
> #define MUXENAB_I2S_EN		0x00000020
> #define MUXENAB_I2S_MASTER	0x00000040
> #define MUXENAB_I2S_FULL	0x00000080
> #define MUXENAB_SFLASH		0x00000100
> #define MUXENAB_RFSWCTRL0	0x00000200
> #define MUXENAB_RFSWCTRL1	0x00000400
> #define MUXENAB_RFSWCTRL2	0x00000800
> #define MUXENAB_SECI		0x00001000
> #define MUXENAB_BT_LEGACY	0x00002000
> #define MUXENAB_HOST_WAKE1	0x00004000
diff -r update5/drivers/net/wireless/bcmdhd/src/include/bcmsdh.h update6/drivers/net/wireless/bcmdhd/src/include/bcmsdh.h
57a58,62
> 
> #if defined(NDIS630)
> extern bcmsdh_info_t *bcmsdh_attach(osl_t *osh, void *cfghdl,
> 	void **regsva, uint irq, shared_info_t *sh);
> #else
58a64
> #endif
72a79,80
> /* Enable/disable SD card interrupt forward */
> extern void bcmsdh_intr_forward(void *sdh, bool pass);
201a210,212
> 
> extern int bcmsdh_reg_sdio_notify(void* semaphore);
> extern void bcmsdh_unreg_sdio_notify(void);
diff -r update5/drivers/net/wireless/bcmdhd/src/include/bcmsdh_sdmmc.h update6/drivers/net/wireless/bcmdhd/src/include/bcmsdh_sdmmc.h
4c4
<  * Copyright (C) 1999-2011, Broadcom Corporation
---
>  * Copyright (C) 1999-2012, Broadcom Corporation
85,87c85,88
< 	uint		max_dma_len;
< 	uint		max_dma_descriptors;	/* DMA Descriptors supported by this controller. */
< //	SDDMA_DESCRIPTOR	SGList[32];	/* Scatter/Gather DMA List */
---
> 
> #define SDIOH_SDMMC_MAX_SG_ENTRIES	32
> 	struct scatterlist sg_list[SDIOH_SDMMC_MAX_SG_ENTRIES];
> 	bool		use_rxchain;
diff -r update5/drivers/net/wireless/bcmdhd/src/include/bcmutils.h update6/drivers/net/wireless/bcmdhd/src/include/bcmutils.h
337a338
> extern uint8 *pktoffset(osl_t *osh, void *p,  uint offset);
Nur in update5/drivers/net/wireless/bcmdhd/src/include: bcmwifi.h.
diff -r update5/drivers/net/wireless/bcmdhd/src/include/dhdioctl.h update6/drivers/net/wireless/bcmdhd/src/include/dhdioctl.h
87a88,90
> #if defined(NDIS630)
> #define DHD_SCAN_VAL	0x2000
> #else
88a92
> #endif
diff -r update5/drivers/net/wireless/bcmdhd/src/include/epivers.h update6/drivers/net/wireless/bcmdhd/src/include/epivers.h
31c31
< #define	EPI_MINOR_VERSION	6
---
> #define	EPI_MINOR_VERSION	15
33c33
< #define	EPI_RC_NUMBER		1
---
> #define	EPI_RC_NUMBER		3
39c39
< #define	EPI_VERSION		1, 6, 1, 0
---
> #define	EPI_VERSION		1, 15, 3, 1
41c41
< #define	EPI_VERSION_NUM		0x01060100
---
> #define	EPI_VERSION_NUM		0x010f0301
43c43
< #define EPI_VERSION_DEV		1.6.1
---
> #define EPI_VERSION_DEV		1.15.3.1
46c46
< #define	EPI_VERSION_STR		"1.6.1"
---
> #define	EPI_VERSION_STR		"1.15.3.camp.1 (r315426)"
48c48
< #endif
---
> #endif /* _epivers_h_ */
diff -r update5/drivers/net/wireless/bcmdhd/src/include/hndsoc.h update6/drivers/net/wireless/bcmdhd/src/include/hndsoc.h
137c137,138
< #define	PCIE2_CORE_ID		0x83c		/* pci express core */
---
> #define ACPHY_CORE_ID		0x83b		/* Dot11 ACPHY */
> #define PCIE2_CORE_ID		0x83c		/* pci express Gen2 core */
139c140
< #define	ARMCR4_CORE_ID		0x83e		/* ARM Cortex M3 core */
---
> #define ARMCR4_CORE_ID		0x83e		/* ARM CR4 CPU */
diff -r update5/drivers/net/wireless/bcmdhd/src/include/linux_osl.h update6/drivers/net/wireless/bcmdhd/src/include/linux_osl.h
4c4
<  * Copyright (C) 1999-2011, Broadcom Corporation
---
>  * Copyright (C) 1999-2012, Broadcom Corporation
24c24
<  * $Id: linux_osl.h 301833 2011-12-08 22:34:00Z $
---
>  * $Id: linux_osl.h 309193 2012-01-19 00:03:57Z $
60d59
< 
63,65c62,63
< 	#endif
< #endif
< 
---
> 	#endif /* __GNUC__ */
> #endif /* BCMASSERT_LOG */
89a88
> extern struct pci_dev *osl_pci_device(osl_t *osh);
107,108d105
< 
< 
134d130
< 
163d158
< 
177,178d171
< 
< 
307c300
< #endif
---
> #endif  /* LINUX_VERSION_CODE */
317c310
< #endif
---
> #endif  /* CTFPOOL */
336c329
< #endif
---
> #endif /* HNDCTF */
364,365d356
< 
< 
368d358
< 
383c373
< #endif
---
> #endif /* BCMDRIVER */
385c375
< #endif
---
> #endif /* _linux_osl_h_ */
diff -r update5/drivers/net/wireless/bcmdhd/src/include/linuxver.h update6/drivers/net/wireless/bcmdhd/src/include/linuxver.h
40c40
< #endif
---
> #endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0) */
50c50
< #endif
---
> #endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 0)) */
103a104,105
> #if !(LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 18) && defined(RHEL_MAJOR) && \
> 	(RHEL_MAJOR == 5))
105a108
> #endif
582,583c585,586
< #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 29)
< #define WL_DEV_IF(dev)          ((wl_if_t*)netdev_priv(dev))
---
> #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24))
> #define DEV_PRIV(dev)	(dev->priv)
585c588
< #define WL_DEV_IF(dev)          ((wl_if_t*)(dev)->priv)
---
> #define DEV_PRIV(dev)	netdev_priv(dev)
diff -r update5/drivers/net/wireless/bcmdhd/src/include/pcicfg.h update6/drivers/net/wireless/bcmdhd/src/include/pcicfg.h
76a77,81
> 
> #define PCIE2_BAR0_WIN2		0x70
> #define PCIE2_BAR0_CORE2_WIN	0x74
> #define PCIE2_BAR0_CORE2_WIN2	0x78
> 
diff -r update5/drivers/net/wireless/bcmdhd/src/include/proto/802.11.h update6/drivers/net/wireless/bcmdhd/src/include/proto/802.11.h
1070,1072c1070
< #ifdef BCMWAPI_WAI
< #define DOT11_MNG_WAPI_ID           68  /* d11 management WAPI id */
< #endif
---
> #define DOT11_MNG_WAPI_ID			68
1091a1090,1092
> #define	DOT11_MNG_VHT_CAP_ID		191
> #define	DOT11_MNG_VHT_OPERATION_ID	192
> 
1631a1633,1673
> 
> typedef int vht_group_id_t;
> 
> 
> 
> #define VHT_SIGA1_CONST_MASK		0x800004
> 
> #define VHT_SIGA1_20MHZ_VAL		0x000000
> #define VHT_SIGA1_40MHZ_VAL		0x000001
> #define VHT_SIGA1_80MHZ_VAL		0x000002
> #define VHT_SIGA1_160MHZ_VAL		0x000003
> 
> #define VHT_SIGA1_STBC			0x000008
> 
> #define VHT_SIGA1_GID_MAX_GID		0x3f
> #define VHT_SIGA1_GID_SHIFT		4
> #define VHT_SIGA1_GID_TO_AP		0x00
> #define VHT_SIGA1_GID_NOT_TO_AP		0x3f
> 
> #define VHT_SIGA1_NSTS_SHIFT		10
> #define VHT_SIGA1_NSTS_SHIFT_MASK_USER0 0x001C00
> 
> #define VHT_SIGA1_PARTIAL_AID_SHIFT 13
> 
> 
> #define VHT_SIGA2_GI_NONE               0x000000
> #define VHT_SIGA2_GI_SHORT              0x000001
> #define VHT_SIGA2_GI_W_MOD10            0x000002
> #define VHT_SIGA2_CODING_LDPC           0x000004
> #define VHT_SIGA2_BEAMFORM_ENABLE       0x000100
> #define VHT_SIGA2_MCS_SHIFT             4
> 
> #define VHT_SIGA2_B9_RESERVED           0x000200
> #define VHT_SIGA2_TAIL_MASK             0xfc0000
> #define VHT_SIGA2_TAIL_VALUE            0x000000
> 
> #define VHT_SIGA2_SVC_BITS              16
> #define VHT_SIGA2_TAIL_BITS             6
> 
> 
> 
1740a1783
> 
1750a1794,1798
> #define VHT_MAX_MPDU		11454
> #define VHT_MPDU_MSDU_DELTA	56
> 
> #define VHT_MAX_AMSDU		(VHT_MAX_MPDU - VHT_MPDU_MSDU_DELTA)
> 
1897a1946,2037
> BWL_PRE_PACKED_STRUCT struct vht_cap_ie {
> 	uint32  vht_cap_info;
> 
> 	uint16	rx_mcs_map;
> 	uint16  rx_max_rate;
> 	uint16  tx_mcs_map;
> 	uint16	tx_max_rate;
> } BWL_POST_PACKED_STRUCT;
> typedef struct vht_cap_ie vht_cap_ie_t;
> 
> #define VHT_CAP_IE_LEN 12
> 
> #define VHT_CAP_INFO_MAX_MPDU_LEN_MASK			0x00000003
> #define VHT_CAP_INFO_SUPP_CHAN_WIDTH_MASK       0x0000000c
> #define VHT_CAP_INFO_LDPC                       0x00000010
> #define VHT_CAP_INFO_SGI_80MHZ                  0x00000020
> #define VHT_CAP_INFO_SGI_160MHZ                 0x00000040
> #define VHT_CAP_INFO_TX_STBC                    0x00000080
> 
> #define VHT_CAP_INFO_RX_STBC_MASK               0x00000700
> #define VHT_CAP_INFO_RX_STBC_SHIFT              8
> #define VHT_CAP_INFO_SU_BEAMFMR                 0x00000800
> #define VHT_CAP_INFO_SU_BEAMFMEE                0x00001000
> #define VHT_CAP_INFO_NUM_BMFMR_ANT_MASK         0x0000e000
> #define VHT_CAP_INFO_NUM_BMFMR_ANT_SHIFT        13
> 
> #define VHT_CAP_INFO_NUM_SOUNDING_DIM_MASK      0x00070000
> #define VHT_CAP_INFO_NUM_SOUNDING_DIM_SHIFT     16
> #define VHT_CAP_INFO_MU_BEAMFMR                 0x00080000
> #define VHT_CAP_INFO_MU_BEAMFMEE                0x00100000
> #define VHT_CAP_INFO_TXOPPS                     0x00200000
> #define VHT_CAP_INFO_HTCVHT                     0x00400000
> #define VHT_CAP_INFO_AMPDU_MAXLEN_EXP_MASK      0x03800000
> #define VHT_CAP_INFO_AMPDU_MAXLEN_EXP_SHIFT     23
> 
> #define VHT_CAP_INFO_LINK_ADAPT_CAP_MASK        0x0c000000
> #define VHT_CAP_INFO_LINK_ADAPT_CAP_SHIFT       26
> 
> 
> #define VHT_CAP_SUPP_MCS_RX_HIGHEST_RATE_MASK	0x1fff
> #define VHT_CAP_SUPP_MCS_RX_HIGHEST_RATE_SHIFT	0
> 
> #define VHT_CAP_SUPP_MCS_TX_HIGHEST_RATE_MASK	0x1fff
> #define VHT_CAP_SUPP_MCS_TX_HIGHEST_RATE_SHIFT	0
> 
> #define VHT_CAP_MCS_MAP_0_7						0
> #define VHT_CAP_MCS_MAP_0_8						1
> #define VHT_CAP_MCS_MAP_0_9						2
> #define VHT_CAP_MCS_MAP_NONE					3
> 
> #define VHT_CAP_MCS_MAP_NSS_MAX					8
> 
> 
> typedef enum vht_cap_chan_width {
> 	VHT_CAP_CHAN_WIDTH_20_40  = 0x00,
> 	VHT_CAP_CHAN_WIDTH_80	  = 0x04,
> 	VHT_CAP_CHAN_WIDTH_160	  = 0x08
> } vht_cap_chan_width_t;
> 
> 
> typedef enum vht_cap_max_mpdu_len {
> 	VHT_CAP_MPDU_MAX_4K		= 0x00,
> 	VHT_CAP_MPDU_MAX_8K		= 0x01,
> 	VHT_CAP_MPDU_MAX_11K	= 0x02
> } vht_cap_max_mpdu_len_t;
> 
> 
> BWL_PRE_PACKED_STRUCT struct vht_op_ie {
> 	uint8	chan_width;
> 	uint8	chan1;
> 	uint8	chan2;
> 	uint16	supp_mcs;
> } BWL_POST_PACKED_STRUCT;
> typedef struct vht_op_ie vht_op_ie_t;
> 
> #define VHT_OP_IE_LEN 5
> 
> typedef enum vht_op_chan_width {
> 	VHT_OP_CHAN_WIDTH_20_40	= 0,
> 	VHT_OP_CHAN_WIDTH_80	= 1,
> 	VHT_OP_CHAN_WIDTH_160	= 2,
> 	VHT_OP_CHAN_WIDTH_80_80	= 3
> } vht_op_chan_width_t;
> 
> 
> #define VHT_MCS_MAP_GET_SS_IDX(numSpatialStreams) ((numSpatialStreams-1)*2)
> #define VHT_MCS_MAP_GET_MCS_PER_SS(numSpatialStreams, mcsMap) \
> 			((mcsMap >> VHT_MCS_MAP_GET_SS_IDX(numSpatialStreams)) & 0x3)
> #define VHT_MCS_MAP_SET_MCS_PER_SS(numSpatialStreams, numMcs, mcsMap) \
> 			(mcsMap |= ((numMcs & 0x3) << VHT_MCS_MAP_GET_SS_IDX(numSpatialStreams)))
> 
> 
1973d2112
< 
2021a2161,2167
> #ifdef BCMWAPI_WAI
> #define WAPI_IE_MIN_LEN		20
> #define WAPI_VERSION		1
> #define WAPI_VERSION_LEN	2
> #define WAPI_OUI		"\x00\x14\x72"
> #define WAPI_OUI_LEN		DOT11_OUI_LEN
> #endif
2091,2097d2236
< #ifdef BCMWAPI_WAI
< #define WAPI_IE_MIN_LEN     20  /* WAPI IE min length */
< #define WAPI_VERSION        1   /* WAPI version */
< #define WAPI_VERSION_LEN    2   /* WAPI version length */
< #define WAPI_OUI        "\x00\x14\x72"  /* WAPI OUI */
< #define WAPI_OUI_LEN        DOT11_OUI_LEN   /* WAPI OUI length */
< #endif /* BCMWAPI_WAI */
diff -r update5/drivers/net/wireless/bcmdhd/src/include/proto/bcmevent.h update6/drivers/net/wireless/bcmdhd/src/include/proto/bcmevent.h
30,31d29
< 
< 
39d36
< 
52,54d48
< 
< 
< 
89d82
< 
186,187c179,182
< 
< #define WLC_E_LAST			89
---
> #define WLC_E_ASSOC_RECREATED		89
> #define WLC_E_ACTION_FRAME_RX_NDIS	90
> #define WLC_E_AUTH_REQ			91
> #define WLC_E_LAST			92
268,269d262
< 
< 
318c311
< #endif
---
> #endif /* _BCMEVENT_H_ */
diff -r update5/drivers/net/wireless/bcmdhd/src/include/proto/ethernet.h update6/drivers/net/wireless/bcmdhd/src/include/proto/ethernet.h
71d70
< #ifdef BCMWAPI_WPI
73d71
< #endif
75a74
> #define ETHER_TYPE_IPV6		0x86dd
diff -r update5/drivers/net/wireless/bcmdhd/src/include/proto/p2p.h update6/drivers/net/wireless/bcmdhd/src/include/proto/p2p.h
61a62,63
> #define P2P_ATTR_ID_LEN		1
> #define P2P_ATTR_LEN_LEN	2
81a84,85
> #define P2P_SEID_OP_CHANNEL		17
> #define P2P_SEID_INVITE_FLAGS		18
84c88
< #define P2P_SE_VS_ID_SERVICES   0x1b /* BRCM proprietary subel: L2 Services */
---
> #define P2P_SE_VS_ID_SERVICES   0x1b /* BRCM subel: L2 Services */
132c136,164
< /* WiFi P2P IE subelement: Status */
---
> BWL_PRE_PACKED_STRUCT struct wifi_p2p_listen_channel_se_s {
> 	uint8	eltId;
> 	uint8	len[2];
> 	uint8	country[3];
> 	uint8	op_class;
> 	uint8	channel;
> } BWL_POST_PACKED_STRUCT;
> typedef struct wifi_p2p_listen_channel_se_s wifi_p2p_listen_channel_se_t;
> BWL_PRE_PACKED_STRUCT struct wifi_p2p_grp_bssid_se_s {
> 	uint8	eltId;
> 	uint8	len[2];
> 	uint8	mac[6];
> } BWL_POST_PACKED_STRUCT;
> typedef struct wifi_p2p_grp_bssid_se_s wifi_p2p_grp_bssid_se_t;
> BWL_PRE_PACKED_STRUCT struct wifi_p2p_grp_id_se_s {
> 	uint8	eltId;
> 	uint8	len[2];
> 	uint8	mac[6];
> 	uint8	ssid[1];
> } BWL_POST_PACKED_STRUCT;
> typedef struct wifi_p2p_grp_id_se_s wifi_p2p_grp_id_se_t;
> BWL_PRE_PACKED_STRUCT struct wifi_p2p_intf_se_s {
> 	uint8	eltId;
> 	uint8	len[2];
> 	uint8	mac[6];
> 	uint8	ifaddrs;
> 	uint8	ifaddr[1][6];
> } BWL_POST_PACKED_STRUCT;
> typedef struct wifi_p2p_intf_se_s wifi_p2p_intf_se_t;
217a250,256
> BWL_PRE_PACKED_STRUCT struct wifi_p2p_pri_devtype_s {
> 	uint16	cat_id;
> 	uint8	OUI[3];
> 	uint8	oui_type;
> 	uint16	sub_cat_id;
> } BWL_POST_PACKED_STRUCT;
> typedef struct wifi_p2p_pri_devtype_s wifi_p2p_pri_devtype_t;
267c306,319
< /* WiFi P2P Action Frame */
---
> BWL_PRE_PACKED_STRUCT struct wifi_p2p_op_channel_se_s {
> 	uint8	eltId;
> 	uint8	len[2];
> 	uint8	country[3];
> 	uint8	op_class;
> 	uint8	channel;
> } BWL_POST_PACKED_STRUCT;
> typedef struct wifi_p2p_op_channel_se_s wifi_p2p_op_channel_se_t;
> BWL_PRE_PACKED_STRUCT struct wifi_p2p_invite_flags_se_s {
> 	uint8	eltId;
> 	uint8	len[2];
> 	uint8	flags;
> } BWL_POST_PACKED_STRUCT;
> typedef struct wifi_p2p_invite_flags_se_s wifi_p2p_invite_flags_se_t;
diff -r update5/drivers/net/wireless/bcmdhd/src/include/proto/wpa.h update6/drivers/net/wireless/bcmdhd/src/include/proto/wpa.h
37c37
< 
---
> #include <dhd_sec_feature.h>
119c119,120
< #ifdef BCMWAPI_WPI
---
> 
> #ifdef BCMWAPI_WAI
124c125,126
< #endif /* BCMWAPI_WPI */
---
> #endif /* BCMWAPI_WAI */
> 
131a134
> 
diff -r update5/drivers/net/wireless/bcmdhd/src/include/sbchipc.h update6/drivers/net/wireless/bcmdhd/src/include/sbchipc.h
1380a1381,1393
> #define PMU17_PLLCTL2_NDIVTYPE_MASK		0x00000070
> #define PMU17_PLLCTL2_NDIVTYPE_SHIFT		4
> 
> #define PMU17_PLLCTL2_NDIV_MODE_INT		0
> #define PMU17_PLLCTL2_NDIV_MODE_INT1B8		1
> #define PMU17_PLLCTL2_NDIV_MODE_MASH111		2
> #define PMU17_PLLCTL2_NDIV_MODE_MASH111B8	3
> 
> #define PMU17_PLLCTL0_BBPLL_PWRDWN		0
> #define PMU17_PLLCTL0_BBPLL_DRST		3
> #define PMU17_PLLCTL0_BBPLL_DISBL_CLK		8
> 
> 
1970a1984,1986
> #define CCTRL1_4324_GPIO_SEL            (1 << 0)
> #define CCTRL1_4324_SDIO_HOST_WAKE (1 << 2)
> 
2069a2086,2091
> 
> #define CCTRL4360_SECI_MODE			(1 << 2)
> #define CCTRL4360_BTSWCTRL_MODE			(1 << 3)
> #define CCTRL4360_EXTRA_FEMCTRL_MODE		(1 << 8)
> #define CCTRL4360_BT_LGCY_MODE			(1 << 9)
> #define CCTRL4360_CORE2FEMCTRL4_ON		(1 << 21)
diff -r update5/drivers/net/wireless/bcmdhd/src/include/sbhnddma.h update6/drivers/net/wireless/bcmdhd/src/include/sbhnddma.h
73a74,75
> #define XC_MR_MASK	0x000000C0
> #define XC_MR_SHIFT	6
78a81,89
> #define XC_PC_MASK	0x00E00000
> #define XC_PC_SHIFT	21
> #define XC_PT_MASK	0x03000000
> #define XC_PT_SHIFT	24
> 
> 
> #define DMA_MR_1	0
> #define DMA_MR_2	1
> 
85a97,111
> #define DMA_BL_512	5
> #define DMA_BL_1024	6
> 
> 
> #define DMA_PC_0	0
> #define DMA_PC_4	1
> #define DMA_PC_8	2
> #define DMA_PC_16	3
> 
> 
> 
> #define DMA_PT_1	0
> #define DMA_PT_2	1
> #define DMA_PT_4	2
> #define DMA_PT_8	3
120a147,150
> #define RC_PC_MASK	0x00E00000
> #define RC_PC_SHIFT	21
> #define RC_PT_MASK	0x03000000
> #define RC_PT_SHIFT	24
214a245,246
> #define D64_XC_MR_MASK		0x000000C0
> #define D64_XC_MR_SHIFT		6
219a252,255
> #define D64_XC_PC_MASK		0x00E00000
> #define D64_XC_PC_SHIFT		21
> #define D64_XC_PT_MASK		0x03000000
> #define D64_XC_PT_SHIFT		24
255a292,295
> #define D64_RC_PC_MASK		0x00E00000
> #define D64_RC_PC_SHIFT		21
> #define D64_RC_PT_MASK		0x03000000
> #define D64_RC_PT_SHIFT		24
diff -r update5/drivers/net/wireless/bcmdhd/src/include/sbsdio.h update6/drivers/net/wireless/bcmdhd/src/include/sbsdio.h
64a65,68
> #define SBSDIO_FUNC1_WCTRL_ALPWAIT_MASK		0x1
> #define SBSDIO_FUNC1_WCTRL_ALPWAIT_SHIFT	0
> #define SBSDIO_FUNC1_WCTRL_HTWAIT_MASK		0x2
> #define SBSDIO_FUNC1_WCTRL_HTWAIT_SHIFT		1
132a137
> #define SBSDIO_CSR_MASK			0x1F
diff -r update5/drivers/net/wireless/bcmdhd/src/include/sdio.h update6/drivers/net/wireless/bcmdhd/src/include/sdio.h
86a87,91
> #define SDIOD_CCCR_BRCM_CARDCAP			0xf0
> #define SDIOD_CCCR_BRCM_CARDCAP_CMD14_SUPPORT	0x02
> #define SDIOD_CCCR_BRCM_CARDCAP_CMD14_EXT	0x04
> #define SDIOD_CCCR_BRCM_CARDCAP_CMD_NODEC	0x08
> #define SDIOD_CCCR_BRCM_CARDCTL			0xf1
diff -r update5/drivers/net/wireless/bcmdhd/src/include/siutils.h update6/drivers/net/wireless/bcmdhd/src/include/siutils.h
183a184
> extern uint32 si_socram_srmem_size(si_t *sih);
279,280c280,281
< extern void si_chipcontrl_epa4331_restore(si_t *sih, uint32 val);
< extern uint32 si_chipcontrl_epa4331_read(si_t *sih);
---
> extern void si_chipcontrl_restore(si_t *sih, uint32 val);
> extern uint32 si_chipcontrl_read(si_t *sih);
282a284
> extern void si_chipcontrl_srom4360(si_t *sih, bool on);
diff -r update5/drivers/net/wireless/bcmdhd/src/include/wlfc_proto.h update6/drivers/net/wireless/bcmdhd/src/include/wlfc_proto.h
180,181c180,181
< #define WLFC_D11_STATUS_INTERPRET(txs)	((((txs)->status & TX_STATUS_SUPR_MASK) >> \
< 		TX_STATUS_SUPR_SHIFT)) ? WLFC_CTL_PKTFLAG_D11SUPPRESS : WLFC_CTL_PKTFLAG_DISCARD
---
> #define WLFC_D11_STATUS_INTERPRET(txs)	\
> 	(((txs)->status.suppr_ind != 0) ? WLFC_CTL_PKTFLAG_D11SUPPRESS : WLFC_CTL_PKTFLAG_DISCARD)
diff -r update5/drivers/net/wireless/bcmdhd/src/include/wlioctl.h update6/drivers/net/wireless/bcmdhd/src/include/wlioctl.h
7c7
<  * Copyright (C) 1999-2011, Broadcom Corporation
---
>  * Copyright (C) 1999-2012, Broadcom Corporation
27c27
<  * $Id: wlioctl.h 307928 2012-01-13 01:39:09Z $
---
>  * $Id: wlioctl.h 310294 2012-01-24 06:17:47Z $
38c38
< #include <bcmwifi.h>
---
> #include <bcmwifi_channels.h>
198c198,200
< 	uint32		reserved32[1];		/* Reserved for expansion of BSS properties */
---
> 	uint8		padding1[3];		/* explicit struct alignment padding */
> 	uint16		vht_rxmcsmap;		/* VHT rx mcs map */
> 	uint16		vht_txmcsmap;		/* VHT tx mcs map */
200c202,203
< 	uint8		reserved[3];		/* Reserved for expansion of BSS properties */
---
> 	uint8		vht_cap;		/* BSS is vht capable */
> 	uint8		reserved[2];		/* Reserved for expansion of BSS properties */
218a222,224
> 	uint32  targetbss_wpa2_flags;
> 	uint32 assoc_type;
> 	uint32 assoc_state;
900a907,911
> #ifdef MFP
> #define MFP_CAPABLE		0x0200
> #define MFP_REQUIRED	0x0400
> #define MFP_SHA256		0x0800 /* a special configuration for STA for WIFI test tool */
> #endif /* MFP */
905a917,922
> 
> #if defined(BCMCCX) || defined(BCMEXTCCX)
> #define WPA_AUTH_CCKM       0x0008  /* CCKM */
> #define WPA2_AUTH_CCKM      0x0010  /* CCKM2 */
> #endif  /* BCMCCX || BCMEXTCCX */
> 
1660c1677,1682
< #define WL_AUTH_OPEN_SHARED		2   /* try open, then shared if open failed w/rc 13 */
---
> #ifdef BCM4330_CHIP
> #define WL_AUTH_OPEN_SHARED		2	/* try open, then shared if open failed w/rc 13 */
> #else
> /* BCM4334(Phoenex branch) value changed to 3 */
> #define WL_AUTH_OPEN_SHARED		3	/* try open, then shared if open failed w/rc 13 */
> #endif
1676c1698
< #define WL_PHY_PAVARS_LEN	6	/* Phy type, Band range, chain, a1, b0, b1 */
---
> #define WL_PHY_PAVARS_LEN	32	/* Phy type, Band range, chain, a1[0], b0[0], b1[0] ... */
1700a1723
> #define WL_DIAG_LOOPBACK_EXT			8	/* enhenced d11 loopback data test */
1733a1757,1758
> #define WL_CHAN_FREQ_RANGE_5G_4BAND     5
> 
2073a2099,2100
> #define WL_NUM_RATES_EXTRA_VHT		2 /* Additional VHT 11AC rates */
> #define WL_NUM_RATES_VHT			10
2074a2102
> 
2092c2120
< 	uint8 b20_1x1ofdm[WL_NUM_RATES_OFDM];		/* 20 MHz Legacy OFDM transmission */
---
> 	uint8 b20_1x1ofdm[WL_NUM_RATES_OFDM];		/* Legacy OFDM transmission */
2096c2124
< 	uint8 b20_1x2cdd_ofdm[WL_NUM_RATES_OFDM];	/* 20 MHz Legacy OFDM CDD transmission */
---
> 	uint8 b20_1x2cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
2098c2126
< 	uint8 b20_2x2stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 - NEW for HT */
---
> 	uint8 b20_2x2stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
2102,2105c2130,2133
< 	uint8 b20_1x3cdd_ofdm[WL_NUM_RATES_OFDM];	/* 20 MHz Legacy OFDM CDD transmission# */
< 	uint8 b20_1x3cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* 20 MHz 1 Nsts to 3 Tx Chain */
< 	uint8 b20_2x3stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 - NEW# */
< 	uint8 b20_2x3sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* 20 MHz 2 Nsts to 3 Tx Chain */
---
> 	uint8 b20_1x3cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
> 	uint8 b20_1x3cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* 1 Nsts to 3 Tx Chain */
> 	uint8 b20_2x3stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
> 	uint8 b20_2x3sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* 2 Nsts to 3 Tx Chain */
2107a2136,2144
> 	uint8 b20_1x1vht[WL_NUM_RATES_EXTRA_VHT];		/* VHT8_9SS1 */
> 	uint8 b20_1x2cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD1 */
> 	uint8 b20_2x2stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC */
> 	uint8 b20_2x2sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2 */
> 	uint8 b20_1x3cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD2 */
> 	uint8 b20_2x3stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC_SPEXP1 */
> 	uint8 b20_2x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2_SPEXP1 */
> 	uint8 b20_3x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS3 */
> 
2109,2110c2146,2147
< 	uint8 b40_dummy1x1dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS# */
< 	uint8 b40_1x1ofdm[WL_NUM_RATES_OFDM];		/* 20 MHz Legacy OFDM transmission */
---
> 	uint8 b40_dummy1x1dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
> 	uint8 b40_1x1ofdm[WL_NUM_RATES_OFDM];		/* Legacy OFDM transmission */
2113,2114c2150,2151
< 	uint8 b40_dummy1x2dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS# */
< 	uint8 b40_1x2cdd_ofdm[WL_NUM_RATES_OFDM];	/* 20 MHz Legacy OFDM CDD transmission */
---
> 	uint8 b40_dummy1x2dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
> 	uint8 b40_1x2cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
2116c2153
< 	uint8 b40_2x2stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 - NEW */
---
> 	uint8 b40_2x2stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
2119,2123c2156,2160
< 	uint8 b40_dummy1x3dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS# */
< 	uint8 b40_1x3cdd_ofdm[WL_NUM_RATES_OFDM];	/* 40 MHz Legacy OFDM CDD transmission# */
< 	uint8 b40_1x3cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* 20 MHz 1 Nsts to 3 Tx Chain */
< 	uint8 b40_2x3stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 - NEW# */
< 	uint8 b40_2x3sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* 20 MHz 2 Nsts to 3 Tx Chain */
---
> 	uint8 b40_dummy1x3dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
> 	uint8 b40_1x3cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
> 	uint8 b40_1x3cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* 1 Nsts to 3 Tx Chain */
> 	uint8 b40_2x3stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
> 	uint8 b40_2x3sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* 2 Nsts to 3 Tx Chain */
2125a2163,2171
> 	uint8 b40_1x1vht[WL_NUM_RATES_EXTRA_VHT];		/* VHT8_9SS1 */
> 	uint8 b40_1x2cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD1 */
> 	uint8 b40_2x2stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC */
> 	uint8 b40_2x2sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2 */
> 	uint8 b40_1x3cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD2 */
> 	uint8 b40_2x3stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC_SPEXP1 */
> 	uint8 b40_2x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2_SPEXP1 */
> 	uint8 b40_3x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS3 */
> 
2128c2174
< 	uint8 b20in40_1x1ofdm[WL_NUM_RATES_OFDM];	/* 20 MHz Legacy OFDM transmission */
---
> 	uint8 b20in40_1x1ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM transmission */
2132c2178
< 	uint8 b20in40_1x2cdd_ofdm[WL_NUM_RATES_OFDM];	/* 20 MHz Legacy OFDM CDD transmission */
---
> 	uint8 b20in40_1x2cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
2134c2180
< 	uint8 b20in40_2x2stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 - NEW# */
---
> 	uint8 b20in40_2x2stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
2138,2141c2184,2187
< 	uint8 b20in40_1x3cdd_ofdm[WL_NUM_RATES_OFDM];	/* 20 in 40 MHz Legacy OFDM CDD# */
< 	uint8 b20in40_1x3cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* 20 MHz 1 Nsts to 3 Tx Chain */
< 	uint8 b20in40_2x3stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 - NEW# */
< 	uint8 b20in40_2x3sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* 20 MHz 2 Nsts to 3 Tx Chain */
---
> 	uint8 b20in40_1x3cdd_ofdm[WL_NUM_RATES_OFDM];	/* 20 in 40 MHz Legacy OFDM CDD */
> 	uint8 b20in40_1x3cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* 1 Nsts to 3 Tx Chain */
> 	uint8 b20in40_2x3stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
> 	uint8 b20in40_2x3sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* 2 Nsts to 3 Tx Chain */
2144,2145c2190,2278
< 	uint8 mcs32; /* C_CHECK THIS NEEDS TO BE REMOVED EVENTUALLY */
< } txppr_t;
---
> 	uint8 b20in40_1x1vht[WL_NUM_RATES_EXTRA_VHT];		/* VHT8_9SS1 */
> 	uint8 b20in40_1x2cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD1 */
> 	uint8 b20in40_2x2stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC */
> 	uint8 b20in40_2x2sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2 */
> 	uint8 b20in40_1x3cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD2 */
> 	uint8 b20in40_2x3stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC_SPEXP1 */
> 	uint8 b20in40_2x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2_SPEXP1 */
> 	uint8 b20in40_3x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS3 */
> 
> 	/* start of 80MHz tx power limits */
> 	uint8 b80_dummy1x1dsss[WL_NUM_RATES_CCK];		/* Legacy CCK/DSSS */
> 	uint8 b80_1x1ofdm[WL_NUM_RATES_OFDM];			/* Legacy OFDM transmission */
> 	uint8 b80_1x1mcs0[WL_NUM_RATES_MCS_1STREAM];	/* SISO MCS 0-7 */
> 
> 	uint8 b80_dummy1x2dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
> 	uint8 b80_1x2cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
> 	uint8 b80_1x2cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* CDD MCS 0-7 */
> 	uint8 b80_2x2stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
> 	uint8 b80_2x2sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* MCS 8-15 */
> 
> 	uint8 b80_dummy1x3dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
> 	uint8 b80_1x3cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
> 	uint8 b80_1x3cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* 1 Nsts to 3 Tx Chain */
> 	uint8 b80_2x3stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
> 	uint8 b80_2x3sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* 2 Nsts to 3 Tx Chain */
> 	uint8 b80_3x3sdm_mcs16[WL_NUM_RATES_MCS_1STREAM];	/* 3 Nsts to 3 Tx Chain */
> 
> 	uint8 b80_1x1vht[WL_NUM_RATES_EXTRA_VHT];		/* VHT8_9SS1 */
> 	uint8 b80_1x2cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD1 */
> 	uint8 b80_2x2stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC */
> 	uint8 b80_2x2sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2 */
> 	uint8 b80_1x3cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD2 */
> 	uint8 b80_2x3stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC_SPEXP1 */
> 	uint8 b80_2x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2_SPEXP1 */
> 	uint8 b80_3x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS3 */
> 
> 	/* start of 20in80MHz tx power limits */
> 	uint8 b20in80_1x1dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
> 	uint8 b20in80_1x1ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM transmission */
> 	uint8 b20in80_1x1mcs0[WL_NUM_RATES_MCS_1STREAM];	/* SISO MCS 0-7 */
> 
> 	uint8 b20in80_1x2dsss[WL_NUM_RATES_CCK];		/* Legacy CCK/DSSS */
> 	uint8 b20in80_1x2cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
> 	uint8 b20in80_1x2cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* CDD MCS 0-7 */
> 	uint8 b20in80_2x2stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
> 	uint8 b20in80_2x2sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* MCS 8-15 */
> 
> 	uint8 b20in80_1x3dsss[WL_NUM_RATES_CCK];		/* Legacy CCK/DSSS */
> 	uint8 b20in80_1x3cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
> 	uint8 b20in80_1x3cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* 1 Nsts to 3 Tx Chain */
> 	uint8 b20in80_2x3stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
> 	uint8 b20in80_2x3sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* 2 Nsts to 3 Tx Chain */
> 	uint8 b20in80_3x3sdm_mcs16[WL_NUM_RATES_MCS_1STREAM];	/* 3 Nsts to 3 Tx Chain */
> 
> 	uint8 b20in80_1x1vht[WL_NUM_RATES_EXTRA_VHT];		/* VHT8_9SS1 */
> 	uint8 b20in80_1x2cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD1 */
> 	uint8 b20in80_2x2stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC */
> 	uint8 b20in80_2x2sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2 */
> 	uint8 b20in80_1x3cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD2 */
> 	uint8 b20in80_2x3stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC_SPEXP1 */
> 	uint8 b20in80_2x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2_SPEXP1 */
> 	uint8 b20in80_3x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS3 */
> 
> 	/* start of 40in80MHz tx power limits */
> 	uint8 b40in80_dummy1x1dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
> 	uint8 b40in80_1x1ofdm[WL_NUM_RATES_OFDM];		/* Legacy OFDM transmission */
> 	uint8 b40in80_1x1mcs0[WL_NUM_RATES_MCS_1STREAM];	/* SISO MCS 0-7 */
> 
> 	uint8 b40in80_dummy1x2dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
> 	uint8 b40in80_1x2cdd_ofdm[WL_NUM_RATES_OFDM];	/* Legacy OFDM CDD transmission */
> 	uint8 b40in80_1x2cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* CDD MCS 0-7 */
> 	uint8 b40in80_2x2stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
> 	uint8 b40in80_2x2sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* MCS 8-15 */
> 
> 	uint8 b40in80_dummy1x3dsss[WL_NUM_RATES_CCK];	/* Legacy CCK/DSSS */
> 	uint8 b40in80_1x3cdd_ofdm[WL_NUM_RATES_OFDM];	/* MHz Legacy OFDM CDD */
> 	uint8 b40in80_1x3cdd_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* 1 Nsts to 3 Tx Chain */
> 	uint8 b40in80_2x3stbc_mcs0[WL_NUM_RATES_MCS_1STREAM];	/* STBC MCS 0-7 */
> 	uint8 b40in80_2x3sdm_mcs8[WL_NUM_RATES_MCS_1STREAM];	/* 2 Nsts to 3 Tx Chain */
> 	uint8 b40in80_3x3sdm_mcs16[WL_NUM_RATES_MCS_1STREAM];	/* 3 Nsts to 3 Tx Chain */
> 
> 	uint8 b40in80_1x1vht[WL_NUM_RATES_EXTRA_VHT];		/* VHT8_9SS1 */
> 	uint8 b40in80_1x2cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD1 */
> 	uint8 b40in80_2x2stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC */
> 	uint8 b40in80_2x2sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2 */
> 	uint8 b40in80_1x3cdd_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_CDD2 */
> 	uint8 b40in80_2x3stbc_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS1_STBC_SPEXP1 */
> 	uint8 b40in80_2x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS2_SPEXP1 */
> 	uint8 b40in80_3x3sdm_vht[WL_NUM_RATES_EXTRA_VHT];	/* VHT8_9SS3 */
2146a2280,2281
> 	uint8 mcs32; /* C_CHECK - THIS NEEDS TO BE REMOVED THROUGHOUT THE CODE */
> } txppr_t;
2168a2304,2312
> #define WL_TX_POWER_20_S1X1_VHT					OFFSETOF(txppr_t, b20_1x1vht)
> #define WL_TX_POWER_20_S1X2_CDD_VHT				OFFSETOF(txppr_t, b20_1x2cdd_vht)
> #define WL_TX_POWER_20_S2X2_STBC_VHT			OFFSETOF(txppr_t, b20_2x2stbc_vht)
> #define WL_TX_POWER_20_S2X2_VHT					OFFSETOF(txppr_t, b20_2x2sdm_vht)
> #define WL_TX_POWER_20_S1X3_CDD_VHT				OFFSETOF(txppr_t, b20_1x3cdd_vht)
> #define WL_TX_POWER_20_S2X3_STBC_VHT			OFFSETOF(txppr_t, b20_2x3stbc_vht)
> #define WL_TX_POWER_20_S2X3_VHT					OFFSETOF(txppr_t, b20_2x3sdm_vht)
> #define WL_TX_POWER_20_S3X3_VHT					OFFSETOF(txppr_t, b20_3x3sdm_vht)
> 
2189a2334,2342
> #define WL_TX_POWER_40_S1X1_VHT					OFFSETOF(txppr_t, b40_1x1vht)
> #define WL_TX_POWER_40_S1X2_CDD_VHT				OFFSETOF(txppr_t, b40_1x2cdd_vht)
> #define WL_TX_POWER_40_S2X2_STBC_VHT			OFFSETOF(txppr_t, b40_2x2stbc_vht)
> #define WL_TX_POWER_40_S2X2_VHT					OFFSETOF(txppr_t, b40_2x2sdm_vht)
> #define WL_TX_POWER_40_S1X3_CDD_VHT				OFFSETOF(txppr_t, b40_1x3cdd_vht)
> #define WL_TX_POWER_40_S2X3_STBC_VHT			OFFSETOF(txppr_t, b40_2x3stbc_vht)
> #define WL_TX_POWER_40_S2X3_VHT					OFFSETOF(txppr_t, b40_2x3sdm_vht)
> #define WL_TX_POWER_40_S3X3_VHT					OFFSETOF(txppr_t, b40_3x3sdm_vht)
> 
2207a2361,2453
> #define WL_TX_POWER_20UL_S1X1_VHT			OFFSETOF(txppr_t, b20in40_1x1vht)
> #define WL_TX_POWER_20UL_S1X2_CDD_VHT		OFFSETOF(txppr_t, b20in40_1x2cdd_vht)
> #define WL_TX_POWER_20UL_S2X2_STBC_VHT		OFFSETOF(txppr_t, b20in40_2x2stbc_vht)
> #define WL_TX_POWER_20UL_S2X2_VHT			OFFSETOF(txppr_t, b20in40_2x2sdm_vht)
> #define WL_TX_POWER_20UL_S1X3_CDD_VHT		OFFSETOF(txppr_t, b20in40_1x3cdd_vht)
> #define WL_TX_POWER_20UL_S2X3_STBC_VHT		OFFSETOF(txppr_t, b20in40_2x3stbc_vht)
> #define WL_TX_POWER_20UL_S2X3_VHT			OFFSETOF(txppr_t, b20in40_2x3sdm_vht)
> #define WL_TX_POWER_20UL_S3X3_VHT			OFFSETOF(txppr_t, b20in40_3x3sdm_vht)
> 
> /* 80MHz */
> #define WL_TX_POWER_80_DUMMY_CCK_FIRST		OFFSETOF(txppr_t, b80_dummy1x1dsss)
> #define WL_TX_POWER_OFDM80_FIRST			OFFSETOF(txppr_t, b80_1x1ofdm)
> #define WL_TX_POWER_MCS80_SISO_FIRST		OFFSETOF(txppr_t, b80_1x1mcs0)
> #define WL_TX_POWER_80_S1x1_FIRST			OFFSETOF(txppr_t, b80_1x1mcs0)
> 
> #define WL_TX_POWER_80_DUMMY_CCK_CDD_S1x2_FIRST	OFFSETOF(txppr_t, b80_dummy1x2dsss)
> #define WL_TX_POWER_OFDM80_CDD_FIRST			OFFSETOF(txppr_t, b80_1x2cdd_ofdm)
> #define WL_TX_POWER_MCS80_CDD_FIRST				OFFSETOF(txppr_t, b80_1x2cdd_mcs0)
> #define WL_TX_POWER_80_S1x2_FIRST				OFFSETOF(txppr_t, b80_1x2cdd_mcs0)
> #define WL_TX_POWER_MCS80_STBC_FIRST			OFFSETOF(txppr_t, b80_2x2stbc_mcs0)
> #define WL_TX_POWER_MCS80_SDM_FIRST				OFFSETOF(txppr_t, b80_2x2sdm_mcs8)
> #define WL_TX_POWER_80_S2x2_FIRST				OFFSETOF(txppr_t, b80_2x2sdm_mcs8)
> 
> #define WL_TX_POWER_80_DUMMY_CCK_CDD_S1x3_FIRST	OFFSETOF(txppr_t, b80_dummy1x3dsss)
> #define WL_TX_POWER_OFDM80_CDD_S1x3_FIRST		OFFSETOF(txppr_t, b80_1x3cdd_ofdm)
> #define WL_TX_POWER_80_S1x3_FIRST				OFFSETOF(txppr_t, b80_1x3cdd_mcs0)
> #define WL_TX_POWER_80_STBC_S2x3_FIRST			OFFSETOF(txppr_t, b80_2x3stbc_mcs0)
> #define WL_TX_POWER_80_S2x3_FIRST				OFFSETOF(txppr_t, b80_2x3sdm_mcs8)
> #define WL_TX_POWER_80_S3x3_FIRST				OFFSETOF(txppr_t, b80_3x3sdm_mcs16)
> 
> #define WL_TX_POWER_80_S1X1_VHT					OFFSETOF(txppr_t, b80_1x1vht)
> #define WL_TX_POWER_80_S1X2_CDD_VHT				OFFSETOF(txppr_t, b80_1x2cdd_vht)
> #define WL_TX_POWER_80_S2X2_STBC_VHT			OFFSETOF(txppr_t, b80_2x2stbc_vht)
> #define WL_TX_POWER_80_S2X2_VHT					OFFSETOF(txppr_t, b80_2x2sdm_vht)
> #define WL_TX_POWER_80_S1X3_CDD_VHT				OFFSETOF(txppr_t, b80_1x3cdd_vht)
> #define WL_TX_POWER_80_S2X3_STBC_VHT			OFFSETOF(txppr_t, b80_2x3stbc_vht)
> #define WL_TX_POWER_80_S2X3_VHT					OFFSETOF(txppr_t, b80_2x3sdm_vht)
> #define WL_TX_POWER_80_S3X3_VHT					OFFSETOF(txppr_t, b80_3x3sdm_vht)
> 
> /* 20 in 80MHz */
> #define WL_TX_POWER_20UUL_CCK_FIRST				OFFSETOF(txppr_t, b20in80_1x1dsss)
> #define WL_TX_POWER_20UUL_OFDM_FIRST			OFFSETOF(txppr_t, b20in80_1x1ofdm)
> #define WL_TX_POWER_20UUL_S1x1_FIRST			OFFSETOF(txppr_t, b20in80_1x1mcs0)
> 
> #define WL_TX_POWER_CCK_20UU_CDD_S1x2_FIRST		OFFSETOF(txppr_t, b20in80_1x2dsss)
> #define WL_TX_POWER_20UUL_OFDM_CDD_FIRST		OFFSETOF(txppr_t, b20in80_1x2cdd_ofdm)
> #define WL_TX_POWER_20UUL_S1x2_FIRST			OFFSETOF(txppr_t, b20in80_1x2cdd_mcs0)
> #define WL_TX_POWER_20UUL_STBC_S2x2_FIRST		OFFSETOF(txppr_t, b20in80_2x2stbc_mcs0)
> #define WL_TX_POWER_20UUL_S2x2_FIRST			OFFSETOF(txppr_t, b20in80_2x2sdm_mcs8)
> 
> #define WL_TX_POWER_CCK_20UU_CDD_S1x3_FIRST		OFFSETOF(txppr_t, b20in80_1x3dsss)
> #define WL_TX_POWER_20UUL_OFDM_CDD_S1x3_FIRST	OFFSETOF(txppr_t, b20in80_1x3cdd_ofdm)
> #define WL_TX_POWER_20UUL_S1x3_FIRST			OFFSETOF(txppr_t, b20in80_1x3cdd_mcs0)
> #define WL_TX_POWER_20UUL_STBC_S2x3_FIRST		OFFSETOF(txppr_t, b20in80_2x3stbc_mcs0)
> #define WL_TX_POWER_20UUL_S2x3_FIRST			OFFSETOF(txppr_t, b20in80_2x3sdm_mcs8)
> #define WL_TX_POWER_20UUL_S3x3_FIRST			OFFSETOF(txppr_t, b20in80_3x3sdm_mcs16)
> 
> #define WL_TX_POWER_20UUL_S1X1_VHT			OFFSETOF(txppr_t, b20in80_1x1vht)
> #define WL_TX_POWER_20UUL_S1X2_CDD_VHT		OFFSETOF(txppr_t, b20in80_1x2cdd_vht)
> #define WL_TX_POWER_20UUL_S2X2_STBC_VHT		OFFSETOF(txppr_t, b20in80_2x2stbc_vht)
> #define WL_TX_POWER_20UUL_S2X2_VHT			OFFSETOF(txppr_t, b20in80_2x2sdm_vht)
> #define WL_TX_POWER_20UUL_S1X3_CDD_VHT		OFFSETOF(txppr_t, b20in80_1x3cdd_vht)
> #define WL_TX_POWER_20UUL_S2X3_STBC_VHT		OFFSETOF(txppr_t, b20in80_2x3stbc_vht)
> #define WL_TX_POWER_20UUL_S2X3_VHT			OFFSETOF(txppr_t, b20in80_2x3sdm_vht)
> #define WL_TX_POWER_20UUL_S3X3_VHT			OFFSETOF(txppr_t, b20in80_3x3sdm_vht)
> 
> /* 40 in 80MHz */
> #define WL_TX_POWER_40UUL_DUMMY_CCK_FIRST		OFFSETOF(txppr_t, b40in80_dummy1x1dsss)
> #define WL_TX_POWER_40UUL_OFDM_FIRST			OFFSETOF(txppr_t, b40in80_1x1ofdm)
> #define WL_TX_POWER_40UUL_S1x1_FIRST			OFFSETOF(txppr_t, b40in80_1x1mcs0)
> 
> #define WL_TX_POWER_CCK_40UU_DUMMY_CDD_S1x2_FIRST OFFSETOF(txppr_t, b40in80_dummy1x2dsss)
> #define WL_TX_POWER_40UUL_OFDM_CDD_FIRST		OFFSETOF(txppr_t, b40in80_1x2cdd_ofdm)
> #define WL_TX_POWER_40UUL_S1x2_FIRST			OFFSETOF(txppr_t, b40in80_1x2cdd_mcs0)
> #define WL_TX_POWER_40UUL_STBC_S2x2_FIRST		OFFSETOF(txppr_t, b40in80_2x2stbc_mcs0)
> #define WL_TX_POWER_40UUL_S2x2_FIRST			OFFSETOF(txppr_t, b40in80_2x2sdm_mcs8)
> 
> #define WL_TX_POWER_CCK_40UU_DUMMY_CDD_S1x3_FIRST OFFSETOF(txppr_t, b40in80_dummy1x3dsss)
> #define WL_TX_POWER_40UUL_OFDM_CDD_S1x3_FIRST	OFFSETOF(txppr_t, b40in80_1x3cdd_ofdm)
> #define WL_TX_POWER_40UUL_S1x3_FIRST			OFFSETOF(txppr_t, b40in80_1x3cdd_mcs0)
> #define WL_TX_POWER_40UUL_STBC_S2x3_FIRST		OFFSETOF(txppr_t, b40in80_2x3stbc_mcs0)
> #define WL_TX_POWER_40UUL_S2x3_FIRST			OFFSETOF(txppr_t, b40in80_2x3sdm_mcs8)
> #define WL_TX_POWER_40UUL_S3x3_FIRST			OFFSETOF(txppr_t, b40in80_3x3sdm_mcs16)
> 
> #define WL_TX_POWER_40UUL_S1X1_VHT			OFFSETOF(txppr_t, b40in80_1x1vht)
> #define WL_TX_POWER_40UUL_S1X2_CDD_VHT		OFFSETOF(txppr_t, b40in80_1x2cdd_vht)
> #define WL_TX_POWER_40UUL_S2X2_STBC_VHT		OFFSETOF(txppr_t, b40in80_2x2stbc_vht)
> #define WL_TX_POWER_40UUL_S2X2_VHT			OFFSETOF(txppr_t, b40in80_2x2sdm_vht)
> #define WL_TX_POWER_40UUL_S1X3_CDD_VHT		OFFSETOF(txppr_t, b40in80_1x3cdd_vht)
> #define WL_TX_POWER_40UUL_S2X3_STBC_VHT		OFFSETOF(txppr_t, b40in80_2x3stbc_vht)
> #define WL_TX_POWER_40UUL_S2X3_VHT			OFFSETOF(txppr_t, b40in80_2x3sdm_vht)
> #define WL_TX_POWER_40UUL_S3X3_VHT			OFFSETOF(txppr_t, b40in80_3x3sdm_vht)
> 
2235c2481,2486
< #define TX_POWER_T_VERSION	42
---
> #define TX_POWER_T_VERSION	43
> 
> /* Defines used with channel_bandwidth for curpower */
> #define WL_BW_20MHZ		0
> #define WL_BW_40MHZ		1
> #define WL_BW_80MHZ		2
2255,2256c2506,2508
< 	int8 clm_limits[WL_CLM_NUM_RATES];		/* regulatory limits - 20 or 40MHz */
< 	int8 clm_limits20in40[WL_CLM_NUM_RATES];	/* regulatory limits - 20in40MHz */
---
> 	int8 clm_limits[WL_CLM_NUM_RATES];		/* regulatory limits - 20, 40 or 80MHz */
> 	int8 clm_limits_subchan1[WL_CLM_NUM_RATES];	/* regulatory limits - 20in40 or 40in80 */
> 	int8 clm_limits_subchan2[WL_CLM_NUM_RATES];	/* regulatory limits - 20in80MHz */
2258c2510
< 	bool bandwidth_is_20MHz;				/* 20 or 40MHz bandwidth? */
---
> 	int8 channel_bandwidth;			/* 20, 40 or 80 MHz bandwidth? */
2750a3003,3004
> 
> 	uint32  cso_passthrough; /* hw cso required but passthrough */
3253a3508,3509
> #define WL_WOWL_KEEPALIVE_MAX_PACKET_SIZE  80
> #define WLC_WOWL_MAX_KEEPALIVE	2
3649a3906,3910
> #define WL_WOWL_NEEDTKIP1   (1 << 9)    /* need tkip phase 1 key to be updated by the driver */
> #define WL_WOWL_GTK_FAILURE (1 << 10)   /* enable wakeup if GTK fails */
> #define WL_WOWL_EXTMAGPAT   (1 << 11)   /* support extended magic packets */
> #define WL_WOWL_ARPOFFLOAD  (1 << 12)   /* support ARP/NS/keepalive offloading */
> #define WL_WOWL_WPA2        (1 << 13)   /* read protocol version for EAPOL frames */
3654a3916,3917
> #define WOWL_PATTEN_TYPE_ARP	(1 << 0)	/* ARP offload Pattern */
> #define WOWL_PATTEN_TYPE_NA		(1 << 1)	/* NA offload Pattern */
3656,3661c3919,3925
< 	uint masksize;		/* Size of the mask in #of bytes */
< 	uint offset;		/* Offset to start looking for the packet in # of bytes */
< 	uint patternoffset;	/* Offset of start of pattern in the structure */
< 	uint patternsize;	/* Size of the pattern itself in #of bytes */
< 	ulong id;		/* id */
< 	uint reasonsize;	/* Size of the wakeup reason code */
---
> 	uint32 masksize;		/* Size of the mask in #of bytes */
> 	uint32 offset;			/* Offset to start looking for the packet in # of bytes */
> 	uint32 patternoffset;	/* Offset of start of pattern in the structure */
> 	uint32 patternsize;		/* Size of the pattern itself in #of bytes */
> 	uint32 id;				/* id */
> 	uint32 reasonsize;		/* Size of the wakeup reason code */
> 	uint32 flags;			/* Flags to tell the pattern type and other properties */
3683,3684d3946
< 
< 
4056,4057c4318,4320
< #define IV_LEN 16 /* XXX, same as SMS4_WPI_PN_LEN */
< struct wapi_sta_msg_t {
---
> #define IV_LEN 16
> struct wapi_sta_msg_t
> {
4155a4419,4423
> #define	AP_TPC_OFF		0
> #define	AP_TPC_BSS_PWR		1	/* BSS power control */
> #define AP_TPC_AP_PWR		2	/* AP power control */
> #define	AP_TPC_AP_BSS_PWR	3	/* Both AP and BSS power control */
> #define AP_TPC_MAX_LINK_MARGIN	127
4338a4607,4670
> #ifdef WLNIC
> /* nic_cnx iovar */
> typedef struct wl_nic_cnx {
> 	uint8 opcode;
> 	struct ether_addr addr;
> 	/* the following are valid for WL_NIC_CNX_CONN */
> 	uint8 SSID_len;
> 	uint8 SSID[32];
> 	struct ether_addr abssid;
> 	uint8 join_period;
> } wl_nic_cnx_t;
> 
> /* opcode */
> #define WL_NIC_CNX_ADD	0	/* add NIC connection */
> #define WL_NIC_CNX_DEL	1	/* delete NIC connection */
> #define WL_NIC_CNX_IDX	2	/* query NIC connection index */
> #define WL_NIC_CNX_CONN	3	/* join/create network */
> #define WL_NIC_CNX_DIS	4	/* disconnect from network */
> 
> /* nic_cfg iovar */
> typedef struct wl_nic_cfg {
> 	uint8 version;
> 	uint8 beacon_mode;
> 	uint16 beacon_interval;
> 	uint8 diluted_beacon_period;
> 	uint8 repeat_EQC;
> 	uint8 scan_length;
> 	uint8 scan_interval;
> 	uint8 scan_probability;
> 	uint8 awake_window_length;
> 	int8 TSF_correction;
> 	uint8 ASID;
> 	uint8 channel_usage_mode;
> } wl_nic_cfg_t;
> 
> /* version */
> #define WL_NIC_CFG_VER	1
> 
> /* beacon_mode */
> #define WL_NIC_BCN_NORM		0
> #define WL_NIC_BCN_DILUTED	1
> 
> /* channel_usage_mode */
> #define WL_NIC_CHAN_STATIC	0
> #define WL_NIC_CHAN_CYCLE	1
> 
> /* nic_cfg iovar */
> typedef struct wl_nic_frm {
> 	uint8 type;
> 	struct ether_addr da;
> 	uint8 body[1];
> } wl_nic_frm_t;
> 
> /* type */
> #define WL_NIC_FRM_MYNET	1
> #define WL_NIC_FRM_ACTION	2
> 
> /* i/f query */
> typedef struct wl_nic_ifq {
> 	uint bsscfgidx;
> 	char ifname[BCM_MSG_IFNAME_MAX];
> } wl_nic_ifq_t;
> #endif /* WLNIC */
> 
4486a4819,4836
> 
> #define IPV4_ARP_FILTER		0x0001
> #define IPV4_NETBT_FILTER	0x0002
> #define IPV4_LLMNR_FILTER	0x0004
> #define IPV4_SSDP_FILTER	0x0008
> #define IPV4_WSD_FILTER		0x0010
> #define IPV6_NETBT_FILTER	0x0200
> #define IPV6_LLMNR_FILTER	0x0400
> #define IPV6_SSDP_FILTER	0x0800
> #define IPV6_WSD_FILTER		0x1000
> /* Network Offload Engine */
> #define NWOE_OL_ENABLE		0x00000001
> 
> typedef struct {
> 	uint32 ipaddr;
> 	uint32 ipaddr_netmask;
> 	uint32 ipaddr_gateway;
> } nwoe_ifconfig_t;
diff -r update5/drivers/net/wireless/bcmdhd/src/shared/bcmevent.c update6/drivers/net/wireless/bcmdhd/src/shared/bcmevent.c
32c32
< #if WLC_E_LAST != 89
---
> #if WLC_E_LAST != 92
129c129,130
< 	{ WLC_E_ASSOC_RESP_IE, "ASSOC_RESP_IE" }
---
> 	{ WLC_E_ASSOC_RESP_IE, "ASSOC_RESP_IE" },
> 	{ WLC_E_ACTION_FRAME_RX_NDIS, "WLC_E_ACTION_FRAME_RX_NDIS" }
diff -r update5/drivers/net/wireless/bcmdhd/src/shared/bcmutils.c update6/drivers/net/wireless/bcmdhd/src/shared/bcmutils.c
57,59d56
< #ifdef BCMDRIVER
< 
< 
60a58
> #ifdef BCMDRIVER
122,123d119
< 
< 
175a172,175
> 			/* Check for page boundary straddle (2048B) */
> 			if (((uintptr)pktdata & ~0x7ff) != ((uintptr)(pktdata+len) & ~0x7ff))
> 				cnt++;
> 
188a189,207
> uint8 * BCMFASTPATH
> pktoffset(osl_t *osh, void *p,  uint offset)
> {
> 	uint total = pkttotlen(osh, p);
> 	uint pkt_off = 0, len = 0;
> 	uint8 *pdata = (uint8 *) PKTDATA(osh, p);
> 
> 	if (offset > total)
> 		return NULL;
> 
> 	for (; p; p = PKTNEXT(osh, p)) {
> 		pdata = (uint8 *) PKTDATA(osh, p);
> 		pkt_off = offset - len;
> 		len += PKTLEN(osh, p);
> 		if (len > offset)
> 			break;
> 	}
> 	return (uint8*) (pdata+pkt_off);
> }
607c626
< 	while ((prec_bmp & (1 << prec)) == 0 || pq->q[prec].head == NULL)
---
> 	while ((pq->q[prec].head == NULL) || ((prec_bmp & (1 << prec)) == 0))
1020,1023d1038
< 
< 
< 
< 
1126,1127d1140
< 
< 
1601d1613
< 		len -= slen;
1628c1640
< #endif
---
> #endif /* defined(WLMSG_PRHDRS) || defined(WLMSG_PRPKT) || ... */
2013c2025
< #endif
---
> #endif /* defined(WLTINYDUMP) || defined(WLMSG_INFORM) || ... */
diff -r update5/drivers/net/wireless/bcmdhd/src/shared/linux_osl.c update6/drivers/net/wireless/bcmdhd/src/shared/linux_osl.c
4c4
<  * Copyright (C) 1999-2011, Broadcom Corporation
---
>  * Copyright (C) 1999-2012, Broadcom Corporation
24c24
<  * $Id: linux_osl.c 306555 2012-01-06 11:11:48Z $
---
>  * $Id: linux_osl.c 309193 2012-01-19 00:03:57Z $
87c87
< #endif
---
> #endif /* CONFIG_DHD_USE_STATIC_BUF */
113,115d112
< 
< 
< 
163,164d159
< 
< 
180d174
< 
196d189
< 
261c254
< #endif
---
> #endif /* CONFIG_DHD_USE_STATIC_BUF */
322d314
< 
328d319
< 
337d327
< 
343d332
< 
346d334
< 
354d341
< 
361d347
< 
458d443
< 
472d456
< 
481d464
< 
495c478
< #endif
---
> #endif /* CTFPOOL */
509d491
< 
515a498
> 
532d514
< 
538a521
> 
550d532
< 
559d540
< 
583d563
< 
593d572
< 
604,605c583
< #endif
< 
---
> #endif /* CTFPOOL */
620d597
< 
625,626d601
< 
< 
636d610
< 
639d612
< 
793d765
< 
801a774
> 
804c777
< #endif
---
> #endif /* CONFIG_DHD_USE_STATIC_BUF */
813,814d785
< 
< 
823d793
< 
834d803
< 
864a834,842
> 
> struct pci_dev *
> osl_pci_device(osl_t *osh)
> {
> 	ASSERT(osh && (osh->magic == OS_HANDLE_MAGIC) && osh->pdev);
> 
> 	return osh->pdev;
> }
> 
887d864
< 
923c900
< #endif
---
> #endif /* CONFIG_DHD_USE_STATIC_BUF */
960c937,938
< #endif
---
> #endif /* CONFIG_DHD_USE_STATIC_BUF */
> 
1054c1032
< #endif
---
> #endif /* BCMASSERT_LOG */
1068,1069d1045
< 
< 
1076d1051
< 
1086d1060
< 
1095d1068
< 
1099d1071
< 
1105,1110d1076
< 
< 
< 
< 
< 
< 
diff -r update5/drivers/net/wireless/bcmdhd/src/shared/siutils.c update6/drivers/net/wireless/bcmdhd/src/shared/siutils.c
62a63,64
> int do_4360_pcie2_war = 0;
> 
184c186
< 	bool pci, pcie;
---
> 	bool pci, pcie, pcie_gen2 = FALSE;
240c242
< 			} else if (cid == PCIE_CORE_ID) {
---
> 			} else if ((cid == PCIE_CORE_ID) || (cid == PCIE2_CORE_ID)) {
243a246,247
> 				if (cid == PCIE2_CORE_ID)
> 					pcie_gen2 = TRUE;
270a275,277
> 		if (pcie_gen2)
> 			sii->pub.buscoretype = PCIE2_CORE_ID;
> 		else
331a339,340
> 		if (!regs)
> 			return NULL;
356a366,369
> 	if (!cc) {
> 		SI_ERROR(("%s: chipcommon register space is null \n", __FUNCTION__));
> 		return NULL;
> 	}
424,430c437
< 		if ((CHIPID(sih->chip) == BCM4331_CHIP_ID) ||
< 		    (CHIPID(sih->chip) == BCM43431_CHIP_ID)) {
< 			/* set default mux pin to SROM */
< 			si_chipcontrl_epa4331(sih, FALSE);
< 			si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, watchdog), ~0, 100);
< 			OSL_DELAY(20000);	/* Srom read takes ~12mS */
< 		}
---
> 
1916a1924,1979
> uint32
> si_socram_srmem_size(si_t *sih)
> {
> 	si_info_t *sii;
> 	uint origidx;
> 	uint intr_val = 0;
> 
> 	sbsocramregs_t *regs;
> 	bool wasup;
> 	uint corerev;
> 	uint32 coreinfo;
> 	uint memsize = 0;
> 
> 	if ((CHIPID(sih->chip) == BCM4334_CHIP_ID) && (CHIPREV(sih->chiprev) < 2)) {
> 		return (32 * 1024);
> 	}
> 
> 
> 	sii = SI_INFO(sih);
> 
> 	/* Block ints and save current core */
> 	INTR_OFF(sii, intr_val);
> 	origidx = si_coreidx(sih);
> 
> 	/* Switch to SOCRAM core */
> 	if (!(regs = si_setcore(sih, SOCRAM_CORE_ID, 0)))
> 		goto done;
> 
> 	/* Get info for determining size */
> 	if (!(wasup = si_iscoreup(sih)))
> 		si_core_reset(sih, 0, 0);
> 	corerev = si_corerev(sih);
> 	coreinfo = R_REG(sii->osh, &regs->coreinfo);
> 
> 	/* Calculate size from coreinfo based on rev */
> 	if (corerev >= 16) {
> 		uint8 i;
> 		uint nb = (coreinfo & SRCI_SRNB_MASK) >> SRCI_SRNB_SHIFT;
> 		for (i = 0; i < nb; i++) {
> 			W_REG(sii->osh, &regs->bankidx, i);
> 			if (R_REG(sii->osh, &regs->bankinfo) & SOCRAM_BANKINFO_RETNTRAM_MASK)
> 				memsize += socram_banksize(sii, regs, i, SOCRAM_MEMTYPE_RAM);
> 		}
> 	}
> 
> 	/* Return to previous state and core */
> 	if (!wasup)
> 		si_core_disable(sih, 0);
> 	si_setcoreidx(sih, origidx);
> 
> done:
> 	INTR_RESTORE(sii, intr_val);
> 
> 	return memsize;
> }
> 
1986c2049
< si_chipcontrl_epa4331_restore(si_t *sih, uint32 val)
---
> si_chipcontrl_restore(si_t *sih, uint32 val)
2000c2063
< si_chipcontrl_epa4331_read(si_t *sih)
---
> si_chipcontrl_read(si_t *sih)
2046a2110,2139
> 	}
> 
> 	si_setcoreidx(sih, origidx);
> }
> 
> /* switch muxed pins, on: SROM, off: FEMCTRL */
> void
> si_chipcontrl_srom4360(si_t *sih, bool on)
> {
> 	si_info_t *sii;
> 	chipcregs_t *cc;
> 	uint origidx;
> 	uint32 val;
> 
> 	sii = SI_INFO(sih);
> 	origidx = si_coreidx(sih);
> 
> 	cc = (chipcregs_t *)si_setcore(sih, CC_CORE_ID, 0);
> 
> 	val = R_REG(sii->osh, &cc->chipcontrol);
> 
> 	if (on) {
> 		val &= ~(CCTRL4360_SECI_MODE |
> 			CCTRL4360_BTSWCTRL_MODE |
> 			CCTRL4360_EXTRA_FEMCTRL_MODE |
> 			CCTRL4360_BT_LGCY_MODE |
> 			CCTRL4360_CORE2FEMCTRL4_ON);
> 
> 		W_REG(sii->osh, &cc->chipcontrol, val);
> 	} else {
diff -r update5/drivers/net/wireless/bcmdhd/src/shared/siutils_priv.h update6/drivers/net/wireless/bcmdhd/src/shared/siutils_priv.h
108c108,109
< #define PCIE(si)	((BUSTYPE((si)->pub.bustype) == PCI_BUS) &&	\
---
> 
> #define PCIE_GEN1(si)	((BUSTYPE((si)->pub.bustype) == PCI_BUS) &&	\
109a111,116
> 
> #define PCIE_GEN2(si)	((BUSTYPE((si)->pub.bustype) == PCI_BUS) &&	\
> 			 ((si)->pub.buscoretype == PCIE2_CORE_ID))
> 
> #define PCIE(si)	(PCIE_GEN1(si) || PCIE_GEN2(si))
> 
115,116c122
< #define SI_FAST(si) (((si)->pub.buscoretype == PCIE_CORE_ID) ||	\
< 		     (((si)->pub.buscoretype == PCI_CORE_ID) && (si)->pub.buscorerev >= 13))
---
> #define SI_FAST(si) (PCIE(si) || (PCI(si) && ((si)->pub.buscorerev >= 13)))
144,147c150,153
< 	(((PCIE(si)) && (si->pub.chip == BCM4311_CHIP_ID) && ((si->pub.chiprev <= 1))) || \
< 	((PCI(si) || PCIE(si)) && (si->pub.chip == BCM4321_CHIP_ID)) || \
< 	(PCIE(si) && (si->pub.chip == BCM4716_CHIP_ID)) || \
< 	(PCIE(si) && (si->pub.chip == BCM4748_CHIP_ID)))
---
> 	(((PCIE_GEN1(si)) && (si->pub.chip == BCM4311_CHIP_ID) && ((si->pub.chiprev <= 1))) || \
> 	((PCI(si) || PCIE_GEN1(si)) && (si->pub.chip == BCM4321_CHIP_ID)) || \
> 	(PCIE_GEN1(si) && (si->pub.chip == BCM4716_CHIP_ID)) || \
> 	(PCIE_GEN1(si) && (si->pub.chip == BCM4748_CHIP_ID)))
Nur in update6/drivers/net/wireless/bcmdhd/src/wl: bcmwifi.
diff -r update5/drivers/net/wireless/bcmdhd/src/wl/sys/wl_android.c update6/drivers/net/wireless/bcmdhd/src/wl/sys/wl_android.c
4c4
<  * Copyright (C) 1999-2011, Broadcom Corporation
---
>  * Copyright (C) 1999-2012, Broadcom Corporation
24c24
<  * $Id: wl_android.c 307885 2012-01-12 23:30:48Z $
---
>  * $Id: wl_android.c 309571 2012-01-20 01:45:10Z $
76d75
< #define CMD_P2P_GET_NOA		"P2P_GET_NOA"
79c78,82
< #define CMD_SET_MAX_NUM_STA	"MAX_NUM_STA"
---
> 
> /* Hostapd private command */
> #define CMD_SET_HAPD_MAX_NUM_STA	"HAPD_MAX_NUM_STA"
> #define CMD_SET_HAPD_SSID			"HAPD_SSID"
> #define CMD_SET_HAPD_HIDE_SSID		"HAPD_HIDE_SSID"
112a116,120
> #endif /* ROAM_API */
> 
> #ifdef OKC_SUPPORT
> #define CMD_OKC_SET_PMK		"SET_PMK"
> #define CMD_OKC_ENABLE		"OKC_ENABLE"
147a156,162
> /* CSP#505233: Flags to indicate if we distingish power off policy when
>  * user set the memu "Keep Wi-Fi on during sleep" to "Never"
>  */
> #ifdef WL_CFG80211
> bool suspend_power_off;
> #endif
> 
248c263
< 			sizeof(roam_trigger), 1);
---
> 		sizeof(roam_trigger), 1);
259c274
< 			sizeof(roam_trigger), 0)) {
---
> 		sizeof(roam_trigger), 0)) {
262c277
< 				sizeof(roam_trigger), 0))
---
> 			sizeof(roam_trigger), 0))
267c282
< 			CMD_ROAMTRIGGER_GET, roam_trigger[0]);
---
> 		CMD_ROAMTRIGGER_GET, roam_trigger[0]);
281c296
< 			sizeof(roam_delta), 1);
---
> 		sizeof(roam_delta), 1);
292c307
< 			sizeof(roam_delta), 0)) {
---
> 		sizeof(roam_delta), 0)) {
295c310
< 				sizeof(roam_delta), 0))
---
> 			sizeof(roam_delta), 0))
300c315
< 			CMD_ROAMDELTA_GET, roam_delta[0]);
---
> 		CMD_ROAMDELTA_GET, roam_delta[0]);
312c327
< 			sizeof(roam_scan_period), 1);
---
> 		sizeof(roam_scan_period), 1);
322c337
< 			sizeof(roam_scan_period), 0))
---
> 		sizeof(roam_scan_period), 0))
326c341
< 			CMD_ROAMSCANPERIOD_GET, roam_scan_period);
---
> 		CMD_ROAMSCANPERIOD_GET, roam_scan_period);
335c350
< 	wl_country_t cspec = {{0} , 0, {0} };
---
> 	wl_country_t cspec = {{0}, 0, {0} };
343c358
< 				country_code, rev));
---
> 		country_code, rev));
373c388
< 			sizeof(smbuf), NULL);
---
> 		sizeof(smbuf), NULL);
377c392
< 					__func__, error));
---
> 			__func__, error));
385c400
< 			cspec.ccode[0], cspec.ccode[1], cspec.rev);
---
> 		cspec.ccode[0], cspec.ccode[1], cspec.rev);
389c404
< #endif
---
> #endif /* ROAM_API */
518a534
> 	int retry = POWERUP_MAX_RETRY;
527a544
> 		do {
530,531c547,559
< 			msleep(100);
< 		sdioh_start(NULL, 0);
---
> 			msleep(300);
> 
> 			ret = sdioh_start(NULL, 0);
> 			if (ret == 0)
> 				break;
> 			DHD_ERROR(("\nfailed to power up wifi chip, retry again (%d left) **\n\n",
> 				retry+1));
> 			dhd_customer_gpio_wlan_ctrl(WLAN_RESET_OFF);
> 		} while (retry-- >= 0);
> 		if (ret != 0) {
> 			DHD_ERROR(("\nfailed to power up wifi chip, max retry reached **\n\n"));
> 			goto exit;
> 		}
535c563
< 		g_wifi_on = 1;
---
> 		g_wifi_on = TRUE;
536a565,566
> 
> exit:
559c589
< 		g_wifi_on = 0;
---
> 		g_wifi_on = FALSE;
597c627
< static int wl_android_set_max_num_sta(struct net_device *net, const char* string_num)
---
> static int wl_android_set_max_num_sta(struct net_device *dev, const char* string_num)
599a630
> 
601,602c632,648
< 	DHD_INFO(("%s : SoftAP Max Station => %d\n", __FUNCTION__, max_assoc));
< 	wldev_iovar_setint(net, "maxassoc", max_assoc);
---
> 	DHD_INFO(("%s : HAPD_MAX_NUM_STA = %d\n", __FUNCTION__, max_assoc));
> 	wldev_iovar_setint(dev, "maxassoc", max_assoc);
> 	return 1;
> }
> 
> static int wl_android_set_ssid (struct net_device *dev, const char* hapd_ssid)
> {
> 	wlc_ssid_t ssid;
> 	s32 ret;
> 
> 	ssid.SSID_len = strlen(hapd_ssid);
> 	bcm_strncpy_s(ssid.SSID, sizeof(ssid.SSID), hapd_ssid, ssid.SSID_len);
> 	DHD_INFO(("%s: HAPD_SSID = %s\n", __FUNCTION__, ssid.SSID));
> 	ret = wldev_ioctl(dev, WLC_SET_SSID, &ssid, sizeof(wlc_ssid_t), true);
> 	if (ret < 0) {
> 		DHD_ERROR(("%s : WLC_SET_SSID Error:%d\n", __FUNCTION__, ret));
> 	}
603a650,691
> 
> }
> 
> static int wl_android_set_hide_ssid(struct net_device *dev, const char* string_num)
> {
> 	int hide_ssid;
> 	int enable = 0;
> 
> 	hide_ssid = my_atoi(string_num);
> 	DHD_INFO(("%s: HAPD_HIDE_SSID = %d\n", __FUNCTION__, hide_ssid));
> 	if (hide_ssid)
> 		enable = 1;
> 	wldev_iovar_setint(dev, "closednet", enable);
> 	return 1;
> }
> 
> #ifdef OKC_SUPPORT
> 
> static int
> wl_android_set_pmk(struct net_device *dev, char *command, int total_len)
> {
> 	uchar pmk[33];
> 	int error = 0;
> 	char smbuf[WLC_IOCTL_SMLEN];
> #ifdef OKC_DEBUG
> 	int i = 0;
> #endif
> 
> 	bzero(pmk, sizeof(pmk));
> 	memcpy((char *)pmk, command + strlen("SET_PMK "), 32);
> 	error = wldev_iovar_setbuf(dev, "okc_info_pmk", pmk, 32, smbuf, sizeof(smbuf), NULL);
> 	if (error) {
> 		DHD_ERROR(("Failed to set PMK for OKC, error = %d\n", error));
> 	}
> #ifdef OKC_DEBUG
> 	DHD_ERROR(("PMK is "));
> 	for (i = 0; i < 32; i++)
> 		DHD_ERROR(("%02X ", pmk[i]));
> 
> 	DHD_ERROR(("\n"));
> #endif
> 	return error;
605a694,712
> static int
> wl_android_okc_enable(struct net_device *dev, char *command, int total_len)
> {
> 	int error = 0;
> 	char okc_enable = 0;
> 
> 	okc_enable = command[strlen(CMD_OKC_ENABLE) + 1] - '0';
> 	error = wldev_iovar_setint(dev, "okc_enable", okc_enable);
> 	if (error) {
> 		DHD_ERROR(("Failed to %s OKC, error = %d\n",
> 			okc_enable ? "enable" : "disable", error));
> 	}
> 
> 	return error;
> }
> 
> #endif /* OKC_ SUPPORT */
> 
> 
707a815,816
> #ifndef GLOBALCONFIG_WLAN_COUNTRY_CODE
> 
711a821
> #endif
746c856
< #endif
---
> #endif /* ROAM_API */
767,769d876
< 	else if (strnicmp(command, CMD_P2P_GET_NOA, strlen(CMD_P2P_GET_NOA)) == 0) {
< 		bytes_written = wl_cfg80211_get_p2p_noa(net, command, priv_cmd.total_len);
< 	}
783,784c890,891
< 	else if (strnicmp(command, CMD_SET_MAX_NUM_STA, strlen(CMD_SET_MAX_NUM_STA)) == 0) {
< 		int skip = strlen(CMD_SET_MAX_NUM_STA) + 3;
---
> 	else if (strnicmp(command, CMD_SET_HAPD_MAX_NUM_STA, strlen(CMD_SET_HAPD_MAX_NUM_STA)) == 0) {
> 		int skip = strlen(CMD_SET_HAPD_MAX_NUM_STA) + 3;
786a894,908
> 	else if (strnicmp(command, CMD_SET_HAPD_SSID, strlen(CMD_SET_HAPD_SSID)) == 0) {
> 		int skip = strlen(CMD_SET_HAPD_SSID) + 3;
> 		wl_android_set_ssid(net, (const char*)command+skip);
> 	}
> 	else if (strnicmp(command, CMD_SET_HAPD_HIDE_SSID, strlen(CMD_SET_HAPD_HIDE_SSID)) == 0) {
> 		int skip = strlen(CMD_SET_HAPD_HIDE_SSID) + 3;
> 		wl_android_set_hide_ssid(net, (const char*)command+skip);
> 	}
> #ifdef OKC_SUPPORT
> 	else if (strnicmp(command, CMD_OKC_SET_PMK, strlen(CMD_OKC_SET_PMK)) == 0)
> 		bytes_written = wl_android_set_pmk(net, command, priv_cmd.total_len);
> 	else if (strnicmp(command, CMD_OKC_ENABLE, strlen(CMD_OKC_ENABLE)) == 0)
> 		bytes_written = wl_android_okc_enable(net, command, priv_cmd.total_len);
> #endif /* OKC_SUPPORT */
> 
794c916
< 		if (bytes_written == 0)
---
> 		if ((bytes_written == 0) && (priv_cmd.total_len > 0))
796c918
< 		if (bytes_written > priv_cmd.total_len) {
---
> 		if (bytes_written >= priv_cmd.total_len) {
807c929,930
< 	} else {
---
> 	}
> 	else {
901a1025
> 			if (size != 0L)
908c1032
< 	return 0;
---
> 	return NULL;
931c1055
< 		mdelay(msec);
---
> 		msleep(msec);
982d1105
< #ifdef POWER_ON_DELAY_4330
984,986d1106
< #else
< 	wifi_set_power(1, 0);	/* Power On */
< #endif
988a1109,1112
> #ifdef WL_CFG80211
> 	suspend_power_off = FALSE;
> #endif
> 
1003a1128,1132
> #ifdef WL_CFG80211
> 	if (suspend_power_off)
> 		suspend_power_off = FALSE;
> #endif
> 
1006a1136
> int dhd_os_check_wakelock(void *dhdp);
1010,1012c1140,1143
< 	DHD_TRACE(("##> %s\n", __FUNCTION__));
< #if defined(OOB_INTR_ONLY)
< 	bcmsdh_oob_intr_set(0);
---
> 	DHD_ERROR(("##> %s\n", __FUNCTION__));
> #if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 39)) && defined(OOB_INTR_ONLY) && 1
> 	if (dhd_os_check_if_up(bcmsdh_get_drvdata()))
> 		bcmsdh_oob_intr_set(0);
1013a1145,1154
> 	if (dhd_os_check_if_up(bcmsdh_get_drvdata()) &&
> 		dhd_os_check_wakelock(bcmsdh_get_drvdata())) {
> 		DHD_ERROR(("%s no driver data\n", __FUNCTION__));
> 		return -EBUSY;
> 	}
> #if defined(OOB_INTR_ONLY)
> 	if (dhd_os_check_if_up(bcmsdh_get_drvdata()))
> 		bcmsdh_oob_intr_set(0);
> #endif	/* defined(OOB_INTR_ONLY) */
> 	smp_mb();
1019c1160,1165
< 	DHD_TRACE(("##> %s\n", __FUNCTION__));
---
> 	DHD_ERROR(("##> %s\n", __FUNCTION__));
> 
> #if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 39)) && defined(OOB_INTR_ONLY) && 1
> 	if (dhd_os_check_if_up(bcmsdh_get_drvdata()))
> 		bcmsdh_oob_intr_set(1);
> #endif /* (OOB_INTR_ONLY) */
1023a1170
> 	smp_mb();
diff -r update5/drivers/net/wireless/bcmdhd/src/wl/sys/wl_cfg80211.c update6/drivers/net/wireless/bcmdhd/src/wl/sys/wl_cfg80211.c
4c4
<  * Copyright (C) 1999-2011, Broadcom Corporation
---
>  * Copyright (C) 1999-2012, Broadcom Corporation
24c24
<  * $Id: wl_cfg80211.c 307885 2012-01-12 23:30:48Z $
---
>  * $Id: wl_cfg80211.c 310409 2012-01-24 18:47:09Z $
33c33
< #include <bcmwifi.h>
---
> #include <bcmwifi_channels.h>
62a63,73
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0))
> #define DAEMONIZE(a) daemonize(a); \
> 	allow_signal(SIGKILL); \
> allow_signal(SIGTERM);
> #else /* Linux 2.4 (w/o preemption patch) */
> #define DAEMONIZE(a) daemonize(); \
> 	do { if (a) \
> 		strncpy(current->comm, a, MIN(sizeof(current->comm), (strlen(a) + 1))); \
> 	} while (0);
> #endif /* LINUX_VERSION_CODE  */
> 
95a107
> 
96a109
> static int vsdb_supported = 0;
99c112
< u32 wl_dbg_level = WL_DBG_ERR;
---
> u32 wl_dbg_level = WL_DBG_ERR |WL_DBG_SCAN2;
106a120,123
> #ifdef D11AC_IOTYPES
> #define WL_CHANSPEC_CTL_SB_NONE WL_CHANSPEC_CTL_SB_LLL
> #endif /* D11AC_IOTYPES */
> 
179a197,203
> #ifdef BCMCCX
> #ifndef WLAN_AKM_SUITE_CCKM
> #define WLAN_AKM_SUITE_CCKM 0x000FAC04
> #endif
> #define DOT11_LEAP_AUTH	0x80 /* LEAP auth frame paylod constants */
> #endif /* BCMCCX */
> 
253a278,279
> static s32 wl_notify_connect_status_ap(struct wl_priv *wl, struct net_device *ndev,
> 	const wl_event_msg_t *e, void *data);
323c349
< static struct wireless_dev *wl_alloc_wdev(struct device *dev);
---
> static s32 wl_setup_wiphy(struct wireless_dev *wdev, struct device *dev);
413,414c439,444
< 
< 
---
> #ifdef ROAM_CHANNEL_CACHE
> void reset_roam_cache(void);
> void add_roam_cache(wl_bss_info_t *bi);
> int  get_roam_channel_list(int target_chan, chanspec_t *channels, const wlc_ssid_t *ssid);
> void print_roam_cache(void);
> #endif
430a461,464
> #ifdef PROP_TXSTATUS
> extern int dhd_wlfc_init(dhd_pub_t *dhd);
> extern void dhd_wlfc_deinit(dhd_pub_t *dhd);
> #endif
569c603,618
< 	.n_bitrates = wl_a_rates_size
---
> 	.n_bitrates = wl_a_rates_size,
> #if (ENABLE_P2P_INTERFACE)
> 	/* wpa_supplicant sets wmm_enabled based on whether ht_cap
> 	 * is present or not. The wmm_enabled is inturn used to
> 	 * set the replay counters in the RSN IE. Without this
> 	 * the 4way handshake will fail complaining that IE in beacon
> 	 * doesn't match with the IE present in the 3/4 EAPOL msg.
> 	 */
> 	.ht_cap = {
> 		IEEE80211_HT_CAP_SGI_20 |
> 		IEEE80211_HT_CAP_DSSSCCK40 | IEEE80211_HT_CAP_MAX_AMSDU,
> 		.ht_supported = TRUE,
> 		.ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K,
> 		.ampdu_density = IEEE80211_HT_MPDU_DENSITY_16
> 	}
> #endif
582a632,776
> #ifdef WL_CFG80211_GON_COLLISION
> #define BLOCK_GON_REQ_MAX_NUM 5
> #endif /* WL_CFG80211_GON_COLLISION */
> 
> /* IOCtl version read from targeted driver */
> static int ioctl_version;
> 
> #ifdef D11AC_IOTYPES
> 
> /* Return a new chanspec given a legacy chanspec
>  * Returns INVCHANSPEC on error
>  */
> static chanspec_t
> wl_chspec_from_legacy(chanspec_t legacy_chspec)
> {
> 	chanspec_t chspec;
> 
> 	/* get the channel number */
> 	chspec = LCHSPEC_CHANNEL(legacy_chspec);
> 
> 	/* convert the band */
> 	if (LCHSPEC_IS2G(legacy_chspec)) {
> 		chspec |= WL_CHANSPEC_BAND_2G;
> 	} else {
> 		chspec |= WL_CHANSPEC_BAND_5G;
> 	}
> 
> 	/* convert the bw and sideband */
> 	if (LCHSPEC_IS20(legacy_chspec)) {
> 		chspec |= WL_CHANSPEC_BW_20;
> 	} else {
> 		chspec |= WL_CHANSPEC_BW_40;
> 		if (LCHSPEC_CTL_SB(legacy_chspec) == WL_LCHANSPEC_CTL_SB_LOWER) {
> 			chspec |= WL_CHANSPEC_CTL_SB_L;
> 		} else {
> 			chspec |= WL_CHANSPEC_CTL_SB_U;
> 		}
> 	}
> 
> 	if (wf_chspec_malformed(chspec)) {
> 		WL_ERR(("wl_chspec_from_legacy: output chanspec (0x%04X) malformed\n",
> 		        chspec));
> 		return INVCHANSPEC;
> 	}
> 
> 	return chspec;
> }
> 
> /* Return a legacy chanspec given a new chanspec
>  * Returns INVCHANSPEC on error
>  */
> static chanspec_t
> wl_chspec_to_legacy(chanspec_t chspec)
> {
> 	chanspec_t lchspec;
> 
> 	if (wf_chspec_malformed(chspec)) {
> 		WL_ERR(("wl_chspec_to_legacy: input chanspec (0x%04X) malformed\n",
> 		        chspec));
> 		return INVCHANSPEC;
> 	}
> 
> 	/* get the channel number */
> 	lchspec = CHSPEC_CHANNEL(chspec);
> 
> 	/* convert the band */
> 	if (CHSPEC_IS2G(chspec)) {
> 		lchspec |= WL_LCHANSPEC_BAND_2G;
> 	} else {
> 		lchspec |= WL_LCHANSPEC_BAND_5G;
> 	}
> 
> 	/* convert the bw and sideband */
> 	if (CHSPEC_IS20(chspec)) {
> 		lchspec |= WL_LCHANSPEC_BW_20;
> 		lchspec |= WL_LCHANSPEC_CTL_SB_NONE;
> 	} else if (CHSPEC_IS40(chspec)) {
> 		lchspec |= WL_LCHANSPEC_BW_40;
> 		if (CHSPEC_CTL_SB(chspec) == WL_CHANSPEC_CTL_SB_L) {
> 			lchspec |= WL_LCHANSPEC_CTL_SB_LOWER;
> 		} else {
> 			lchspec |= WL_LCHANSPEC_CTL_SB_UPPER;
> 		}
> 	} else {
> 		/* cannot express the bandwidth */
> 		char chanbuf[CHANSPEC_STR_LEN];
> 		WL_ERR((
> 		        "wl_chspec_to_legacy: unable to convert chanspec %s (0x%04X) "
> 		        "to pre-11ac format\n",
> 		        wf_chspec_ntoa(chspec, chanbuf), chspec));
> 		return INVCHANSPEC;
> 	}
> 
> 	return lchspec;
> }
> 
> /* given a chanspec value, do the endian and chanspec version conversion to
>  * a chanspec_t value
>  * Returns INVCHANSPEC on error
>  */
> static chanspec_t
> wl_chspec_host_to_driver(chanspec_t chanspec)
> {
> 	if (ioctl_version == 1) {
> 		chanspec = wl_chspec_to_legacy(chanspec);
> 		if (chanspec == INVCHANSPEC) {
> 			return chanspec;
> 		}
> 	}
> 	chanspec = htodchanspec(chanspec);
> 
> 	return chanspec;
> }
> 
> /* given a chanspec value from the driver, do the endian and chanspec version conversion to
>  * a chanspec_t value
>  * Returns INVCHANSPEC on error
>  */
> static chanspec_t
> wl_chspec_driver_to_host(chanspec_t chanspec)
> {
> 	chanspec = dtohchanspec(chanspec);
> 	if (ioctl_version == 1) {
> 		chanspec = wl_chspec_from_legacy(chanspec);
> 	}
> 
> 	return chanspec;
> }
> 
> #else /* not D11AC_IOTYPES */
> 
> static chanspec_t
> wl_chspec_host_to_driver(chanspec_t chanspec)
> {
> 	return htodchanspec(chanspec);
> }
> 
> static chanspec_t
> wl_chspec_driver_to_host(chanspec_t chanspec)
> {
> 	return dtohchanspec(chanspec);
> }
> 
> #endif /* D11AC_IOTYPES */
> 
732a927,930
> 	if (vsdb_supported) {
> 		return wf_chspec_aton(WL_P2P_TEMP_CHAN);
> 	}
> 	else {
759c957
< 			WL_DBG(("Valid BSS Found. chanspec:%d \n", bss->chanspec));
---
> 				WL_DBG(("Valid BSS Found. chanspec:%d \n", bss->chanspec));
763a962
> }
788a988,991
> #ifdef PROP_TXSTATUS
> 	s32 up = 1;
> 	dhd_pub_t *dhd = (dhd_pub_t *)(wl->pub);
> #endif /* PROP_TXSTATUS */
854c1057
< 		if (!p2p_is_on(wl) && strstr(name, WL_P2P_INTERFACE_PREFIX)) {
---
> 		if (wl->p2p && !wl->p2p->on && strstr(name, WL_P2P_INTERFACE_PREFIX)) {
865c1068,1077
< 
---
> 		WL_SCAN2((" Scan Abort %p(id %d)\n", _ndev, wl->escan_info.cur_sync_id));
> 		wl_cfg80211_scan_abort(wl, _ndev);
> #ifdef PROP_TXSTATUS
> 		if (!wl->wlfc_on) {
> 			dhd->wlfc_enabled = true;
> 			dhd_wlfc_init(dhd);
> 			wldev_ioctl(_ndev, WLC_UP, &up, sizeof(s32), true);
> 			wl->wlfc_on = true;
> 		}
> #endif
930a1143,1149
> #ifdef PROP_TXSTATUS
> 			if (dhd->wlfc_enabled && wl->wlfc_on) {
> 				dhd->wlfc_enabled = false;
> 				dhd_wlfc_deinit(dhd);
> 				wl->wlfc_on = false;
> 			}
> #endif
944a1164
> 	WL_SCAN2(("Enter\n"));
962d1181
< #if defined(DONGLEHOST)
976d1194
< #endif /* defined(DONGLEHOST) */
989a1208
> 	WL_SCAN2(("Exit\n"));
1041a1261,1262
> 			WL_SCAN2(("Scan Abort %p(id %d)\n", ndev, wl->escan_info.cur_sync_id));
> 			wl_cfg80211_scan_abort(wl, ndev);
1044d1264
< 			//wlif_type = ap ? WL_P2P_IF_GO : WL_P2P_IF_CLIENT;
1046,1047c1266,1267
< 			WL_ERR(("%s : ap (%d), infra (%d), iftype: (%d)\n",
< 				ndev->name, ap, infra, type));
---
> 			WL_ERR(("%s : ap (%d), infra (%d), iftype: (%d), chspec: (0x%04x)\n",
> 				ndev->name, ap, infra, type, chspec));
1076c1296,1297
< wl_cfg80211_notify_ifadd(struct net_device *ndev, s32 idx, s32 bssidx, void* _net_attach)
---
> wl_cfg80211_notify_ifadd(struct net_device *ndev, s32 idx, s32 bssidx,
> 	void* _net_attach)
1085c1306
< 		WL_DBG(("IF_ADD event received, old interface name: %s,"
---
> 		WL_DBG(("IF_ADD event called from dongle, old interface name: %s,"
1108c1329,1333
< 	if (!ndev || !ndev->name) {
---
> #ifdef PROP_TXSTATUS
> 	dhd_pub_t *dhd =  (dhd_pub_t *)(wl->pub);
> #endif /* PROP_TXSTATUS */
> 
> 	if (!ndev || (strlen(ndev->name) == 0)) {
1123a1349,1350
> 			WL_SCAN2(("Send Notify Complete %p(id %d)\n",
> 				ndev, wl->escan_info.cur_sync_id));
1128c1355
< 		WL_ERR(("IF_DEL event received, net %x, vif name: %s\n",
---
> 		WL_ERR(("IF_DEL event called from dongle, net %x, vif name: %s\n",
1130a1358
> 		wl->first_remain = true;
1140c1368,1374
< 
---
> #ifdef PROP_TXSTATUS
> 		if (dhd->wlfc_enabled && wl->wlfc_on) {
> 			dhd->wlfc_enabled = false;
> 			dhd_wlfc_deinit(dhd);
> 			wl->wlfc_on = false;
> 		}
> #endif
1179a1414,1469
> 
> /* Find my listen channel value in my GON Req frame,
>  * Save my listen channel for channel sync
>  */
> static s32 wl_find_my_listen_channel(struct wl_priv *wl,
> 	u8 *ie, u32 ie_len)
> {
> 	wifi_p2p_ie_t *p2p_ie;
> 	u8 *end, *pos;
> 	s32 my_listen_channel;
> 
> 	p2p_ie = wl_cfgp2p_find_p2pie(ie, ie_len);
> 
> 	if (p2p_ie == NULL)
> 		return 0;
> 
> 	pos = p2p_ie->subelts;
> 	end = p2p_ie->subelts + (p2p_ie->len - 4);
> 
> 	CFGP2P_DBG((" found p2p ie ! lenth %d \n",
> 		p2p_ie->len));
> 
> 	while (pos < end) {
> 		uint16 attr_len;
> 		if (pos + 2 >= end) {
> 			CFGP2P_DBG((" -- Invalid P2P attribute"));
> 			return 0;
> 		}
> 		attr_len = ((uint16) (((pos + 1)[1] << 8) | (pos + 1)[0]));
> 
> 		if (pos + 3 + attr_len > end) {
> 			CFGP2P_DBG(("P2P: Attribute underflow "
> 				   "(len=%u left=%d)",
> 				   attr_len, (int) (end - pos - 3)));
> 			return 0;
> 		}
> 
> 		/* if Listen Channel att id is 6, save my listen channel */
> 		if (pos[0] == 6) {
> 			/* listen channel subel length format
> 			 * 1(id) + 2(len) + 3(country) + 1(op. class) + 1(chan num)
> 			 */
> 			my_listen_channel = pos[1 + 2 + 3 + 1];
> 
> 			if (my_listen_channel == SOCIAL_CHAN_1 ||
> 				my_listen_channel == SOCIAL_CHAN_2 ||
> 				my_listen_channel == SOCIAL_CHAN_3) {
> 				CFGP2P_DBG((" Found my Listen Channel %d \n", my_listen_channel));
> 				return my_listen_channel;
> 			}
> 		}
> 		pos += 3 + attr_len;
> 	}
> 	return 0;
> }
> 
1182,1183c1472,1473
< 	u32 n_ssids = request->n_ssids;
< 	u32 n_channels = request->n_channels;
---
> 	u32 n_ssids;
> 	u32 n_channels;
1210a1501,1506
> 	/* if request is null just exit so it will be all channel broadcast scan */
> 	if (!request)
> 		return;
> 
> 	n_ssids = request->n_ssids;
> 	n_channels = request->n_channels;
1322d1617
< 
1369a1665,1669
> 
> #ifdef USE_INITIAL_2G_SCAN
> static bool g_first_broadcast_scan = TRUE;
> #endif /* USE_INITIAL_2G_SCAN */
> 
1390a1691,1698
> 	if (!wl->p2p_supported)
> 		WL_SCAN2(("P2P is not supported\n"));
> 	else
> 		WL_SCAN2(("P2P is supported, ndev is %s, "
> 			"p2p_scan ? %s, p2p_is_on ? %s\n",
> 			(ndev == wl_to_prmry_ndev(wl)) ? "Primary" : "P2P",
> 			p2p_scan(wl) ? "YES" : "NO",
> 			p2p_is_on(wl) ? "YES" : "NO"));
1397a1706,1728
> #ifdef USE_INITIAL_2G_SCAN
> 			if (g_first_broadcast_scan == TRUE) {
> 				j = 0;
> 				if (!wl_get_valid_channels(ndev, chan_buf, sizeof(chan_buf))) {
> 					list = (wl_uint32_list_t *) chan_buf;
> 					n_valid_chan = dtoh32(list->count);
> 					for (i = 0; i < n_valid_chan; i++) {
> #if defined(BCM4334_CHIP)
> 						request->channels[i]->flags |=
> 							IEEE80211_CHAN_NO_HT40;
> #endif
> 						WL_SCAN(("list->element[%d]=%d\n",
> 							i, list->element[i]));
> 						if (list->element[i] > CH_MAX_2G_CHANNEL)
> 							break;
> 						j++;
> 					}
> 					request->n_channels = j;
> 					WL_SCAN(("request->n_channels=%d\n", request->n_channels));
> 					g_first_broadcast_scan = FALSE;
> 				}
> 			}
> #endif /* USE_INITIAL_2G_SCAN */
1420c1751
< 		params->sync_id = htod16(0x1234);
---
> 		params->sync_id = wl->escan_info.cur_sync_id;
1422a1754,1755
> 			kfree(params);
> 			params = NULL;
1429a1763,1764
> 		kfree(params);
> 		params = NULL;
1432a1768
> 		s32 _freq = 0;
1433a1770,1772
> 
> 		WL_DBG((" P2P E-SCAN START\n"));
> 
1449,1450c1788,1789
< 					channel =
< 					ieee80211_frequency_to_channel(scan_request->channels[i]->center_freq);
---
> 					_freq = scan_request->channels[i]->center_freq;
> 					channel = ieee80211_frequency_to_channel(_freq);
1487a1827
> 		kfree(default_chan_list);
1490,1494c1830
< 	if(params)
< 		kfree(params);
< 	if(default_chan_list)
< 		kfree(default_chan_list);
< 	if (unlikely(err))
---
> 	if (unlikely(err)) {
1495a1832
> 	}
1518c1855,1856
< 	results = (wl_scan_results_t *) wl->escan_info.escan_buf;
---
> 	WL_SCAN2(("scan result set to sync id :%d\n", wl->escan_info.cur_sync_id%2));
> 	results = (wl_scan_results_t *) wl->escan_info.escan_buf[wl->escan_info.cur_sync_id%2];
1539c1877
< 	bool escan_req;
---
> 	bool escan_req = false;
1552a1891,1899
> 	if (wl_get_drv_status_all(wl, SENDING_ACT_FRM)
> #ifdef WL_CFG80211_SYNC_GON_TIME
> 		|| wl_get_drv_status_all(wl, WAITING_MORE_TIME_NEXT_ACT_FRM)
> #endif /* WL_CFG80211_SYNC_GON_TIME */
> 		) {
> 		WL_ERR(("Sending Action Frames. Try it again.\n"));
> 		return -EAGAIN;
> 		}
> 
1555,1556c1902,1912
< 		WL_ERR(("Scanning already\n"));
< 		return -EAGAIN;
---
> 		if(wl->scan_request == NULL) {
> 			wl_clr_drv_status_all(wl, SCANNING);
> 			WL_ERR (( "<<<<<<<<<<<Force Clear Scanning Status1>>>>>>>>>>>\n"));
> 			WL_ERR (( "<<<<<<<<<<<Force Clear Scanning Status2>>>>>>>>>>>\n"));
> 			WL_ERR (( "<<<<<<<<<<<Force Clear Scanning Status3>>>>>>>>>>>\n"));
> 			}
> 		else {
> 
> 			WL_ERR(("Scanning already\n"));
> 			return -EAGAIN;
> 			}
1557a1914
> 
1566a1924,1932
> 	WL_DBG(("scan start\n"));
> 
> #ifdef WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
> 	if (wl_get_drv_status_all(wl, REMAINING_ON_CHANNEL)) {
> 		WL_SCAN2(("request scan abort: %p(%d)\n", ndev, wl->escan_info.cur_sync_id));
> 		wl_cfg80211_scan_abort(wl, ndev);
> 	}
> #endif /* WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST */
> 
1656a2023,2025
> 				/* find my listen channel */
> 				wl->afx_hdl->my_listen_chan =
> 					wl_find_my_listen_channel(wl, (u8 *)request->ie, request->ie_len);
1707a2077,2082
> 
> 	if (err == BCME_BUSY || err == BCME_NOTREADY) {
> 		WL_ERR(("---> Error occurred err = (%d), busy?%d", err, -EBUSY));
> 		err = -EBUSY;
> 	}
> 
1709a2085
> 	WL_SCAN2(("remove scan request:%p %d \n", ndev, wl->escan_info.cur_sync_id));
1720a2097
> 	WL_SCAN2(("start %p\n", ndev));
1908c2285,2289
< 		val = WPA_AUTH_PSK | WPA_AUTH_UNSPECIFIED;
---
> 		val = WPA_AUTH_PSK |
> #ifdef BCMCCX
> 		WPA_AUTH_CCKM |
> #endif
> 		WPA_AUTH_UNSPECIFIED;
1910c2291,2295
< 		val = WPA2_AUTH_PSK| WPA2_AUTH_UNSPECIFIED;
---
> 		val = WPA2_AUTH_PSK|
> #ifdef BCMCCX
> 		WPA2_AUTH_CCKM |
> #endif
> 		WPA2_AUTH_UNSPECIFIED;
1943c2328
< 	WL_DBG((" %s\n", __func__));
---
> 	WL_DBG((" %s \n", __FUNCTION__));
1954c2339
< 		WL_DBG((" * skip\n"));
---
> 		WL_DBG((" * skip \n"));
1969c2354
< 		val = 0;
---
> 		val = WL_AUTH_OPEN_SYSTEM;
1973c2358
< 		val = 1;
---
> 		val = WL_AUTH_SHARED_KEY;
1977c2362
< 		val = 2;
---
> 		val = WL_AUTH_OPEN_SHARED;
1981a2367,2370
> #ifdef BCMCCX
> 		val = DOT11_LEAP_AUTH;
> 		break;
> #endif
1983c2372
< 		val = 2;
---
> 		val = WL_AUTH_OPEN_SHARED;
2074,2075c2463
< 			err = wldev_iovar_setint_bsscfg(dev, "wsec",
< 				val, bssidx);
---
> 			err = wldev_iovar_setint_bsscfg(dev, "wsec", val, bssidx);
2112c2500,2504
< 		if (val & (WPA_AUTH_PSK | WPA_AUTH_UNSPECIFIED)) {
---
> 		if (val & (WPA_AUTH_PSK |
> #ifdef BCMCCX
> 			WPA_AUTH_CCKM |
> #endif
> 			WPA_AUTH_UNSPECIFIED)) {
2119a2512,2516
> #ifdef BCMCCX
> 			case WLAN_AKM_SUITE_CCKM:
> 				val = WPA_AUTH_CCKM;
> 				break;
> #endif
2125c2522,2526
< 		} else if (val & (WPA2_AUTH_PSK | WPA2_AUTH_UNSPECIFIED)) {
---
> 		} else if (val & (WPA2_AUTH_PSK |
> #ifdef BCMCCX
> 				WPA2_AUTH_CCKM |
> #endif
> 				WPA2_AUTH_UNSPECIFIED)) {
2132a2534,2538
> #ifdef BCMCCX
> 			case WLAN_AKM_SUITE_CCKM:
> 				val = WPA2_AUTH_CCKM;
> 				break;
> #endif
2248a2655,2662
> #ifdef ROAM_CHANNEL_CACHE
> #define MAX_ROAM_CACHE_NUM 100
> #endif
> #ifdef ESCAN_RESULT_PATCH
> static u8 connect_req_bssid[6];
> static u8 broad_bssid[6];
> #endif
> 
2267a2682,2685
> #ifdef ROAM_CHANNEL_CACHE
> 	chanspec_t chanspec_list[MAX_ROAM_CACHE_NUM];
> #endif
> 
2273a2692
> #if (defined (BCM4334_CHIP) || !defined(ESCAN_RESULT_PATCH))
2274a2694
> 		WL_SCAN2(("Abort Scan %p(%d)\n", dev, wl->escan_info.cur_sync_id));
2276a2697,2711
> #endif
> 
> #ifdef WL_CFG80211_GON_COLLISION
> 	/* init block gon req count  */
> 	wl->block_gon_req_tx_count = 0;
> 	wl->block_gon_req_rx_count = 0;
> #endif /* WL_CFG80211_GON_COLLISION */
> /*	WL_SCAN2(("Connect Request: \"%s\"" MACSTR "\n",
> 		sme->ssid, MAC2STR(sme->bssid)));
> */
> #ifdef ESCAN_RESULT_PATCH
> 	memcpy(connect_req_bssid, sme->bssid, ETHER_ADDR_LEN);
> 	bzero(broad_bssid, ETHER_ADDR_LEN);
> #endif
> 
2348a2784,2791
> #ifdef ROAM_CHANNEL_CACHE
> 		wlc_ssid_t ssid;
> 
> 		wl->channel = ieee80211_frequency_to_channel(chan->center_freq);
> 		memcpy(ssid.SSID, sme->ssid, sme->ssid_len);
> 		ssid.SSID_len = sme->ssid_len;
> 		chan_cnt = get_roam_channel_list(wl->channel, chanspec_list, &ssid);
> #else
2351,2352c2794,2796
< 		WL_DBG(("channel (%d), center_req (%d)\n", wl->channel,
< 			chan->center_freq));
---
> #endif
> 		WL_DBG(("channel (%d), center_req (%d), %d channels\n", wl->channel,
> 			chan->center_freq, chan_cnt));
2358c2802
< 		WL_DBG(("2. set wapi ie\n"));
---
> 		WL_DBG(("2. set wapi ie  \n"));
2363c2807
< 		WL_DBG(("2. Not wapi ie\n"));
---
> 		WL_DBG(("2. Not wapi ie  \n"));
2366c2810
< 	WL_DBG(("3. set wapi version\n"));
---
> 	WL_DBG(("3. set wapi version \n"));
2420,2422d2863
< 	/* Set up join scan parameters */
< 	ext_join_params->scan.scan_type = -1;
< 	ext_join_params->scan.nprobes = 2;
2426c2867
< 	ext_join_params->scan.active_time = WL_SCAN_ACTIVE_TIME*3;
---
> 	ext_join_params->scan.active_time = WL_SCAN_ACTIVE_TIME*8;
2427a2869,2871
> 	/* Set up join scan parameters */
> 	ext_join_params->scan.scan_type = -1;
> 	ext_join_params->scan.nprobes = (ext_join_params->scan.active_time/(WL_SCAN_ACTIVE_TIME *2));
2435a2880,2883
> #ifdef ROAM_CHANNEL_CACHE
> 		memcpy(ext_join_params->assoc.chanspec_list, chanspec_list,
> 			sizeof(chanspec_t) * chan_cnt);
> #else
2447c2895,2896
< 			htodchanspec(ext_join_params->assoc.chanspec_list[0]);
---
> 			wl_chspec_host_to_driver(ext_join_params->assoc.chanspec_list[0]);
> #endif /* ROAM_CHANNEL_CACHE */
2510a2960,2962
> 	WL_DBG(("request(%d) %02x:%02x:%02x:%02x:%02x:%02x\n",
> 		act, curbssid[0], curbssid[1], curbssid[2],
> 		curbssid[3],curbssid[4],curbssid[5]));
2514a2967,2968
> #if (defined (BCM4334_CHIP) || !defined (ESCAN_RESULT_PATCH))
> 		/* Let scan aborted by F/W */
2515a2970
> 			WL_SCAN2(("Abort scan : %p(%d)\n", dev, wl->escan_info.cur_sync_id));
2517a2973
> #endif /* ESCAN_RESULT_PATCH */
2847a3304,3309
> 
> 	#ifndef IEEE80211W
> 		if ((key_idx >= DOT11_MAX_DEFAULT_KEYS) && (key_idx < DOT11_MAX_DEFAULT_KEYS+2))
> 			return -EINVAL;
> 	#endif
> 
2957a3420
> 	WL_DBG((" Enter\n"));
2986a3450,3452
> #ifdef ESCAN_RESULT_PATCH
> 			return -ENODEV;
> #else
2988a3455
> #endif /* ESCAN_RESULT_PATCH */
3014c3481
< 		rssi = dtoh32(scb_val.val);
---
> 		rssi = dtoh32(scb_val.val) + RSSI_OFFSET;
3130a3598,3601
> 		spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
> 		WL_SCAN2(("remove scan_request %p, %d\n", ndev, wl->escan_info.cur_sync_id));
> 	} else {
> 		spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
3136d3606
< 	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
3337a3808,3815
> #if defined(BCM4334_CHIP)
> 	if (wl->scan_request) {
> 		struct cfg80211_scan_request *scan_request = wl->scan_request;
> 		u8 temp_id = wl->escan_info.cur_sync_id;
> 		wl->bss_list = (wl_scan_results_t *) wl->escan_info.escan_buf[(temp_id+1)%2];
> 		wl_inform_bss(wl);
> 		}
> #endif
3343c3821
< 	wl_clr_drv_status(wl, SCANNING, ndev);
---
> 
3344a3823
> 	wl_clr_drv_status(wl, SCANNING, ndev);
3348a3828
> 
3359c3839,3840
< 
---
> 	static int cmd_cnt = 0;
> 	static ulong saved_jiff = 0;
3362c3843,3858
< 	WL_DBG(("Enter, netdev_ifidx: %d \n", dev->ifindex));
---
> /* for camp only
> 	if(jiffies_to_msecs(jiffies - saved_jiff)>2000) {
> 		saved_jiff = jiffies;
> 		WL_SCAN2(("jiff:%lu cnt:%d\n", saved_jiff, cmd_cnt));
> 	}
> 	cmd_cnt ++;
> */
> 	WL_SCAN2(("duration :%d\n", duration));
> 	WL_DBG(("Enter, ifindex: %d, channel: %d, duration ms (%d) SCANNING ?? %s \n",
> 		dev->ifindex, ieee80211_frequency_to_channel(channel->center_freq),
> 		duration, (wl_get_drv_status(wl, SCANNING, ndev)) ? "YES":"NO"));
> 
> 	if (wl->first_remain) {
> 		wl->first_remain = false;
> 		duration = 100;
> 	}
3369c3865
< 
---
> #ifndef WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
3370a3867
> 		WL_SCAN2(("Abort Scan : %p(%d)\n", ndev, wl->escan_info.cur_sync_id));
3372a3870
> #endif /* not WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST */
3383c3881,3919
< 	if (!p2p_is_on(wl)) {
---
> 
> #ifdef WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
> 	if (wl_get_drv_status(wl, SCANNING, ndev)) {
> 		struct timer_list *_timer;
> 		WL_DBG((": fake listen state !! \n"));
> 
> 		wl_set_drv_status(wl, FAKE_REMAINING_ON_CHANNEL, ndev);
> 
> 		if (timer_pending(&wl->p2p->listen_timer)) {
> 			WL_ERR((": cancel current listen timer \n"));
> 			spin_lock_bh(&wl->p2p->timer_lock);
> 			del_timer_sync(&wl->p2p->listen_timer);
> 			spin_unlock_bh(&wl->p2p->timer_lock);
> 		}
> 
> 		_timer = &wl->p2p->listen_timer;
> 		wl_clr_p2p_status(wl, LISTEN_EXPIRED);
> 
> 		INIT_TIMER(_timer, wl_cfgp2p_listen_expired, duration, 0);
> 
> 		return BCME_OK;
> 	}
> #endif /* WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST */
> 
> #ifdef WL_CFG80211_SYNC_GON_TIME
> 	if (wl_get_drv_status_all(wl, WAITING_MORE_TIME_NEXT_ACT_FRM)) {
> 		/* do not enter listen mode again if we are in listen mode already for next af.
> 		 * remain on channel completion will be returned by waiting next af completion.
> 		 */
> #ifdef WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
> 		wl_set_drv_status(wl, FAKE_REMAINING_ON_CHANNEL, ndev);
> #else
> 		wl_set_drv_status(wl, REMAINING_ON_CHANNEL, ndev);
> #endif /* WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST */
> 		goto exit;
> 	}
> #endif /* WL_CFG80211_SYNC_GON_TIME */
> 
> 	if (wl->p2p && !wl->p2p->on) {
3398,3399d3933
< 	if (p2p_is_on(wl))
< 		wl_cfgp2p_discover_listen(wl, target_channel, duration);
3400a3935,3950
> 	if (p2p_is_on(wl)) {
> #ifndef WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
> 		wl_set_drv_status(wl, REMAINING_ON_CHANNEL, ndev);
> #endif /* not WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST */
> 		err = wl_cfgp2p_discover_listen(wl, target_channel, duration);
> 
> #ifdef WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
> 		if (err == BCME_OK) {
> 			wl_set_drv_status(wl, REMAINING_ON_CHANNEL, ndev);
> 		} else {
> 			/* if failed, firmware may be internal scanning state.
> 			so other scan request shall not abort it */
> 			wl_set_drv_status(wl, FAKE_REMAINING_ON_CHANNEL, ndev);
> 		}
> #endif /* WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST */
> 	}
3411c3961
< 	WL_DBG((" enter ) netdev_ifidx: %d\n", dev->ifindex));
---
> 	WL_DBG((" enter ) netdev_ifidx: %d \n", dev->ifindex));
3432a3983,3984
> #ifndef CUSTOMER_HW_SAMSUNG
> #error remove sending act frame to improve P2P connection ratio
3433a3986
> #endif
3434a3988,3989
> /* Do not abort scan for VSDB. Scan will be aborted in firmware if necessary */
> #ifndef WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
3435a3991
> #endif /* not WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST */
3448a4005,4006
> 	s32 ret = BCME_OK;
> 
3451,3452c4009,4019
< 		wl_cfgp2p_act_frm_search(wl, wl->afx_hdl->dev,
< 			wl->afx_hdl->bssidx, 0);
---
> 		if (wl->afx_hdl->is_listen && wl->afx_hdl->my_listen_chan) {
> 			ret = wl_cfgp2p_discover_listen(wl, wl->afx_hdl->my_listen_chan, 100);
> 		} else {
> 			ret = wl_cfgp2p_act_frm_search(wl, wl->afx_hdl->dev,
> 				wl->afx_hdl->bssidx, wl->afx_hdl->peer_listen_chan);
> 		}
> 		if (unlikely(ret != BCME_OK)) {
> 			WL_ERR(("ERROR occurred! returned value is (%d)\n", ret));
> 			if (wl_get_drv_status_all(wl, SCANNING_PEER_CHANNEL))
> 				complete(&wl->act_frm_scan);
> 		}
3469,3471c4036,4037
< 	memcpy(wl->afx_hdl->pending_tx_dst_addr.octet,
< 		af_params->action_frame.da.octet,
< 		sizeof(wl->afx_hdl->pending_tx_dst_addr.octet));
---
> 
> 	wl_set_drv_status(wl, SCANNING_PEER_CHANNEL, dev);
3477c4043
< 		wl_set_drv_status(wl, SENDING_ACT_FRM, dev);
---
> 		wl->afx_hdl->is_listen = FALSE;
3483c4049,4066
< 		wait_for_completion(&wl->act_frm_scan);
---
> 		wait_for_completion_timeout(&wl->act_frm_scan,
> 									msecs_to_jiffies(MAX_WAIT_TIME));
> 
> 		if ((wl->afx_hdl->peer_chan != WL_INVALID) ||
> 			!(wl_get_drv_status_all(wl, SCANNING_PEER_CHANNEL)))
> 			break;
> 
> 		if (wl->afx_hdl->my_listen_chan) {
> 			WL_DBG(("Scheduling Listen peer in my listen channel = %d\n",
> 				wl->afx_hdl->my_listen_chan));
> 			wl->afx_hdl->is_listen = TRUE;
> 			/* Do find_peer_for_action */
> 			schedule_work(&wl->afx_hdl->work);
> 			wait_for_completion_timeout(&wl->act_frm_scan,
> 									msecs_to_jiffies(MAX_WAIT_TIME));
> 		}
> 		if (!wl_get_drv_status_all(wl, SCANNING_PEER_CHANNEL))
> 			break;
3485a4069,4072
> 
> 	wl_clr_drv_status(wl, SCANNING, dev);
> 	wl_clr_drv_status(wl, SCANNING_PEER_CHANNEL, dev);
> 
3491a4079,4080
> 	wl->afx_hdl->is_listen = FALSE;
> 	wl->afx_hdl->pending_tx_act_frm = NULL;
3493a4083,4084
> #ifndef CUSTOMER_HW_SAMSUNG
> #error remove sending act frame to improve P2P connection ratio
3494a4086
> #endif
3512d4103
< 	scb_val_t scb_val;
3513a4105
> 	wifi_p2p_ie_t *customer_ie;
3521a4114,4115
> 	u32 customer_ie_len = 0;
> 	u32 remain_len;
3523a4118
> 	u8 *ptr;
3527a4123
> 	scb_val_t scb_val;
3528a4125,4130
> #ifdef WL_CFG80211_GON_COLLISION
> 	static uint8 saved_af_subtype = 0xff;
> #endif /* WL_CFG80211_GON_COLLISION */
> #ifdef WL_CFG80211_SYNC_GON_TIME
> 	bool is_waiting_more_time = false;
> #endif /* WL_CFG80211_SYNC_GON_TIME */
3530c4132
< 	WL_DBG(("Enter\n"));
---
> 	WL_DBG(("Enter \n"));
3576a4179,4202
> 				wpsie_len = wps_ie->length + sizeof(wps_ie->length) +
> 					sizeof(wps_ie->tag);
> 			}
> 
> 			/* Customer IE */
> 			ptr = (u8 *)(buf + ie_offset);
> 			remain_len = ie_len;
> 			customer_ie_len = 0;
> 			while (remain_len > 0)
> 			{
> 				customer_ie = wl_cfgp2p_find_customer_ie(ptr, &remain_len);
> 				if (customer_ie)
> 				{
> 					u32 add_len;
> 					add_len = customer_ie->len + sizeof(customer_ie->len)
> 						+ sizeof(customer_ie->id);
> 					customer_ie_len += add_len;
> 					ptr = (u8*)customer_ie + add_len;
> 					remain_len -= add_len;
> 					WL_INFO(("Customer IE exist(len:%d)\n", add_len));
> 				}
> 				else
> 					break;
> 			}
3582,3583c4208
< 				wpsie_len = wps_ie->length + sizeof(wps_ie->length) +
< 					sizeof(wps_ie->tag);
---
> 
3586,3589c4211,4213
< 					(u8 *)wps_ie, wpsie_len + p2pie_len + wfdie_len);
< 			}
< 			cfg80211_mgmt_tx_status(ndev, *cookie, buf,
< 						    len, true, GFP_KERNEL);
---
> 				(u8 *)wps_ie, wpsie_len + p2pie_len + wfdie_len + customer_ie_len);
> 
> 			cfg80211_mgmt_tx_status(ndev, *cookie, buf, len, true, GFP_KERNEL);
3610c4234,4238
< 			wl_cfg80211_scan_abort(wl, dev);
---
> /* Do not abort scan for VSDB. Scan will be aborted in firmware if necessary.
>  * And previous off-channel action frame must be ended before new af tx.
>  */
> #ifndef WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
> 			WL_SCAN2(("Abort scan: %p(%d)\n", dev, wl->escan_info.cur_sync_id));
3611a4240,4241
> 			wl_cfg80211_scan_abort(wl, dev);
> #endif /* not WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST */
3643a4274,4277
> 	/* Save listen_chan for searching common channel */
> 	wl->afx_hdl->peer_listen_chan = af_params->channel;
> 	WL_DBG(("channel from upper layer %d\n", wl->afx_hdl->peer_listen_chan));
> 
3681,3684c4315,4334
< 	if (act_frm && ((act_frm->subtype == P2P_PAF_GON_REQ) ||
< 	  (act_frm->subtype == P2P_PAF_GON_RSP) ||
< 	  (act_frm->subtype == P2P_PAF_GON_CONF) ||
< 	  (act_frm->subtype == P2P_PAF_PROVDIS_REQ))) {
---
> 	if (act_frm) {
> #ifdef WL_CFG80211_GON_COLLISION
> 		if (wl->block_gon_req_tx_count && act_frm->subtype == P2P_PAF_GON_REQ) {
> 			/* drop gon req tx action frame */
> 			wl->block_gon_req_tx_count--;
> 			WL_ERR(("Drop gon req tx action frame: count %d\n", wl->block_gon_req_tx_count));
> 			cfg80211_mgmt_tx_status(ndev, *cookie, buf, len, true, GFP_KERNEL);
> 			kfree(af_params);
> 			goto exit;
> 		} else if (act_frm->subtype == P2P_PAF_GON_CONF) {
> 			/* if go formation done, clear it */
> 			wl->block_gon_req_tx_count = 0;
> 			wl->block_gon_req_rx_count = 0;
> 		}
> #endif /* WL_CFG80211_GON_COLLISION */
> 
> 		if ((act_frm->subtype == P2P_PAF_GON_REQ) ||
> 		  (act_frm->subtype == P2P_PAF_GON_RSP) ||
> 		  (act_frm->subtype == P2P_PAF_GON_CONF) ||
> 		  (act_frm->subtype == P2P_PAF_PROVDIS_REQ)) {
3685a4336,4340
> 		}
> 
> 		if (act_frm->subtype == P2P_PAF_GON_REQ) {
> 			wl->afx_hdl->my_listen_chan =
> 				wl_find_my_listen_channel(wl, act_frm->elts, action_frame->len);
3688c4343
< 	if (act_frm && act_frm->subtype == P2P_PAF_DEVDIS_REQ) {
---
> 		if (act_frm->subtype == P2P_PAF_DEVDIS_REQ) {
3690,3693c4345,4349
< 	} else if (act_frm &&
< 		(act_frm->subtype == P2P_PAF_PROVDIS_REQ ||
< 		act_frm->subtype == P2P_PAF_PROVDIS_RSP ||
< 		act_frm->subtype == P2P_PAF_GON_RSP)) {
---
> 		} else if (act_frm->subtype == P2P_PAF_PROVDIS_REQ ||
> 			act_frm->subtype == P2P_PAF_INVITE_REQ ||
> 			act_frm->subtype == P2P_PAF_GON_REQ ||
> 		act_frm->subtype == P2P_PAF_GON_RSP ||
> 			act_frm->subtype == P2P_PAF_PROVDIS_RSP) {
3696a4353,4380
> #ifdef WL_CFG80211_SYNC_GON_TIME
> 		if (act_frm->subtype == P2P_PAF_PROVDIS_REQ ||
> 			act_frm->subtype == P2P_PAF_INVITE_REQ ||
> 			act_frm->subtype == P2P_PAF_GON_REQ ||
> 			act_frm->subtype == P2P_PAF_GON_RSP) {
> 			/* sometimes we can't get next gon frame with remain-on-channel,
> 			 * waiting for next gon frame more!
> 			 */
> 			is_waiting_more_time = true;
> 			if (act_frm->subtype == P2P_PAF_PROVDIS_RSP)
> 				wl->next_gon_af_subtype = P2P_PAF_GON_REQ;
> 			else
> 				wl->next_gon_af_subtype = act_frm->subtype + 1;
> 
> 			wl_set_drv_status(wl, WAITING_NEXT_ACT_FRM, dev);
> 			wl->afx_hdl->peer_chan = WL_INVALID;
> 		} else
> 			wl->next_gon_af_subtype = -1;
> #endif /* WL_CFG80211_SYNC_GON_TIME */
> 	}
> 
> 
> 	/* Set SENDING_ACT_FRM and destinatio address for sending af */
> 	wl_set_drv_status(wl, SENDING_ACT_FRM, dev);
> 	memcpy(wl->afx_hdl->tx_dst_addr.octet,
> 		af_params->action_frame.da.octet,
> 		sizeof(wl->afx_hdl->tx_dst_addr.octet));
> 
3709,3710c4393
< 		ack = (wl_cfgp2p_tx_action_frame(wl, dev, af_params, bssidx)) ?
< 				false : true;
---
> 		ack = (wl_cfgp2p_tx_action_frame(wl, dev, af_params, bssidx)) ? false : true;
3717a4401,4405
> 				/* if public action response, the peer only wait for 100ms.
> 				 * do not sync channel
> 				 */
> 				if (act_frm && IS_P2P_SOCIAL(af_params->channel) &&
> 					!IS_P2P_PUB_ACT_RSP_SUBTYPE(act_frm->subtype)) {
3719a4408,4415
> 					for (retry = 0; retry < WL_CHANNEL_SYNC_RETRY; retry++) {
> 						ack = (wl_cfgp2p_tx_action_frame(wl, dev,
> 							af_params, bssidx)) ? false : true;
> 						if (ack)
> 							break;
> 					}
> 				}
> 			} else {
3731a4428,4472
> 
> 	/* Clear SENDING_ACT_FRM after all sending af is done */
> 	wl_clr_drv_status(wl, SENDING_ACT_FRM, dev);
> 
> #ifdef WL_CFG80211_SYNC_GON_TIME
> 	if (ack && is_waiting_more_time && !wl->block_gon_req_tx_count &&
> 		wl_get_drv_status_all(wl, WAITING_NEXT_ACT_FRM) &&
> 		wl->af_sent_channel == wl->afx_hdl->my_listen_chan) {
> 		s32 extar_listen_time;
> 
> 		extar_listen_time =
> 			af_params->dwell_time - jiffies_to_msecs(jiffies - wl->saved_jiffies);
> 
> 		if (extar_listen_time > 50) {
> 			wl_set_drv_status(wl, WAITING_MORE_TIME_NEXT_ACT_FRM, dev);
> 			WL_DBG(("Wait more time! actual af time:%d, calculated extar listen:%d\n",
> 				af_params->dwell_time, extar_listen_time));
> 			if (wl_cfgp2p_discover_listen(wl, wl->af_sent_channel,
> 					extar_listen_time + 100) == BCME_OK) {
> 				wait_for_completion_timeout(&wl->wait_next_af,
> 									msecs_to_jiffies(extar_listen_time + 100 + 300));
> 			}
> 			wl_clr_drv_status(wl, WAITING_MORE_TIME_NEXT_ACT_FRM, dev);
> 		}
> 	}
> 	wl_clr_drv_status(wl, WAITING_NEXT_ACT_FRM, dev);
> 
> 	WL_INFO(("-- sending Action Frame is %s, af sent chan: %d, my listen chan: %d\n",
> 		(ack) ? "Succeeded!!":"Failed!!", wl->af_sent_channel, wl->afx_hdl->my_listen_chan));
> #endif /* WL_CFG80211_SYNC_GON_TIME */
> 
> #ifdef WL_CFG80211_GON_COLLISION
> 	/* Save Action Frame subtype */
> 	if (act_frm)
> 	saved_af_subtype = act_frm->subtype;
> 	else
> 		saved_af_subtype = 0xff;
> 
> 	/* if ack is ture, supplicant will wait more time(100ms).
> 	 * so we will return it as a success if block gon req tx is on.
> 	 */
> 	if (wl->block_gon_req_tx_count)
> 		ack = true;
> #endif /* WL_CFG80211_GON_COLLISION */
> 
3733c4474
< 	if (act_frm && act_frm->subtype == P2P_PAF_GON_CONF) {
---
> 	if (ack && act_frm && act_frm->subtype == P2P_PAF_GON_CONF) {
3787c4528,4532
< 	s32 channel;
---
> 	s32 _chan;
> #ifdef HT40_GO
> 	s32 center_chan;
> 	chanspec_t chspec = 0;
> #endif
3794,3797c4539,4591
< 	channel = ieee80211_frequency_to_channel(chan->center_freq);
< 	WL_DBG(("netdev_ifidx(%d), chan_type(%d) target channel(%d) \n",
< 		dev->ifindex, channel_type, channel));
< 	err = wldev_ioctl(dev, WLC_SET_CHANNEL, &channel, sizeof(channel), true);
---
> 	_chan = ieee80211_frequency_to_channel(chan->center_freq);
> 	WL_ERR(("netdev_ifidx(%d), chan_type(%d) target channel(%d) \n",
> 		dev->ifindex, channel_type, _chan));
> 
> #ifdef NOT_YET
> 	switch (channel_type) {
> 		case NL80211_CHAN_HT40MINUS:
> 			/* secondary channel is below the control channel */
> 			chspec = CH40MHZ_CHSPEC(channel, WL_CHANSPEC_CTL_SB_UPPER);
> 			break;
> 		case NL80211_CHAN_HT40PLUS:
> 			/* secondary channel is above the control channel */
> 			chspec = CH40MHZ_CHSPEC(channel, WL_CHANSPEC_CTL_SB_LOWER);
> 			break;
> 		default:
> 			chspec = CH20MHZ_CHSPEC(channel);
> 
> 	}
> #endif
> #ifdef HT40_GO
> 	switch(_chan) {
> 		/* adjust channel to center of 40MHz band */
> 		case 40:
> 		case 48:
> 		case 153:
> 		case 161:
> 			if (_chan <= (MAXCHANNEL - CH_20MHZ_APART))
> 				center_chan = _chan - CH_10MHZ_APART;
> 				chspec = CH40MHZ_CHSPEC(center_chan, WL_CHANSPEC_CTL_SB_UPPER);
> 			break;
> 		case 36:
> 		case 44:
> 		case 149:
> 		case 157:
> 			if (_chan <= (MAXCHANNEL - CH_20MHZ_APART))
> 				center_chan = _chan + CH_10MHZ_APART;
> 				chspec = CH40MHZ_CHSPEC(center_chan, WL_CHANSPEC_CTL_SB_LOWER);
> 			break;
> 		default:
> 			chspec = CH20MHZ_CHSPEC(_chan);
> 			break;
> 	}
> 
> 
> 	if ((err = wldev_iovar_setint(dev, "chanspec", chspec)) == BCME_BADCHAN) {
> 		err = wldev_ioctl(dev, WLC_SET_CHANNEL, &_chan, sizeof(_chan), true);
> 		if (err < 0) {
> 			WL_ERR(("WLC_SET_CHANNEL error %d"
> 				"chip may not be supporting this channel\n", err));
> 		}
> 	}
> #else
> 	err = wldev_ioctl(dev, WLC_SET_CHANNEL, &_chan, sizeof(_chan), true);
3799c4593,4594
< 		WL_ERR(("WLC_SET_CHANNEL error %d chip may not be supporting this channel\n", err));
---
> 		WL_ERR(("WLC_SET_CHANNEL error %d"
> 			"chip may not be supporting this channel\n", err));
3800a4596
> #endif
4153c4949
< 			WL_ERR(("No WFDIE in beacon \n"));
---
> 			WL_INFO(("No WFDIE in beacon \n"));
4202,4203c4998,5007
< 			wldev_ioctl(dev, WLC_DOWN, &ap, sizeof(s32), true);
< 			wldev_ioctl(dev, WLC_SET_INFRA, &infra, sizeof(s32), true);
---
> 			err = wldev_ioctl(dev, WLC_DOWN, &ap, sizeof(s32), true);
> 			if (err < 0) {
> 				WL_ERR(("WLC_DOWN error %d\n", err));
> 				goto exit;
> 			}
> 			err = wldev_ioctl(dev, WLC_SET_INFRA, &infra, sizeof(s32), true);
> 			if (err < 0) {
> 				WL_ERR(("SET INFRA error %d\n", err));
> 				goto exit;
> 			}
4459c5263
< static struct wireless_dev *wl_alloc_wdev(struct device *dev)
---
> static s32 wl_setup_wiphy(struct wireless_dev *wdev, struct device *sdiofunc_dev)
4461d5264
< 	struct wireless_dev *wdev;
4463,4467d5265
< 	wdev = kzalloc(sizeof(*wdev), GFP_KERNEL);
< 	if (unlikely(!wdev)) {
< 		WL_ERR(("Could not allocate wireless device\n"));
< 		return ERR_PTR(-ENOMEM);
< 	}
4473c5271
< 		goto wiphy_new_out;
---
> 		return err;
4475c5273
< 	set_wiphy_dev(wdev->wiphy, dev);
---
> 	set_wiphy_dev(wdev->wiphy, sdiofunc_dev);
4484a5283,5284
> #ifndef CUSTOMER_HW_SAMSUNG
> #error 5ghz cause p2p connection error
4485a5286
> #endif
4502c5303,5305
< 
---
> #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
> 	wdev->wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM;
> #endif
4510c5313
< 		goto wiphy_register_out;
---
> 		wiphy_free(wdev->wiphy);
4512,4520c5315
< 	return wdev;
< 
< wiphy_register_out:
< 	wiphy_free(wdev->wiphy);
< 
< wiphy_new_out:
< 	kfree(wdev);
< 
< 	return ERR_PTR(err);
---
> 	return err;
4550a5346,5348
> #ifdef ROAM_CHANNEL_CACHE
> 	reset_roam_cache();
> #endif
4552a5351,5353
> #ifdef ROAM_CHANNEL_CACHE
> 		add_roam_cache(bi);
> #endif
4556a5358,5360
> #ifdef ROAM_CHANNEL_CACHE
> 	/* print_roam_cache(); */
> #endif
4592a5397,5402
> 
> 	if(band==NULL) {
> 		kfree(notif_bss_info);
> 		return err;
> 	}
> 
4620,4621c5430
< 	if(unlikely(!channel))
< 	{
---
> 	if (unlikely(!channel)) {
4640,4641c5449
< 		/* find the P2PIE, if we do not find it,
< 			we will discard this frame */
---
> 		/* find the P2PIE, if we do not find it, we will discard this frame */
4643,4646c5451,5453
< 		p2p_ie = wl_cfgp2p_find_p2pie((u8 *)beacon_proberesp->variable,
< 							wl_get_ielen(wl));
< 		if (p2p_ie == NULL) {
< 			WL_ERR(("Couldn't find P2PIE in probe rep/beacon\n"));
---
> 		if ((p2p_ie = wl_cfgp2p_find_p2pie((u8 *)beacon_proberesp->variable,
> 			wl_get_ielen(wl))) == NULL) {
> 			WL_ERR(("Couldn't find P2PIE in probe response/beacon\n"));
4717a5525,5531
> /* The mainline kernel >= 3.2.0 has support for indicating new/del station
>  * to AP/P2P GO via events. If this change is backported to kernel for which
>  * this driver is being built, set CFG80211_STA_EVENT_AVAILABLE to 1. You
>  * should use this new/del sta event mechanism for BRCM supplicant from BRANCH
>  * HOSTAP_BRANCH_0_15 (ver >= 15_1).
>  */
> #define CFG80211_STA_EVENT_AVAILABLE	0
4719c5533
< wl_notify_connect_status(struct wl_priv *wl, struct net_device *ndev,
---
> wl_notify_connect_status_ap(struct wl_priv *wl, struct net_device *ndev,
4722,4723d5535
< 	bool act;
< 	bool isfree = false;
4725,4727d5536
< 	s32 freq;
< 	s32 channel;
< 	u8 body[200];
4732c5541,5542
< 	u16 fc = 0;
---
> #if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0)) && !CFG80211_STA_EVENT_AVAILABLE
> 	bool isfree = false;
4734a5545,5548
> 	s32 freq;
> 	s32 channel;
> 	u8 *body=NULL;
> 	u16 fc = 0;
4739a5554,5565
> #else
> 	struct station_info sinfo;
> #endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0)) && !CFG80211_STA_EVENT_AVAILABLE */
> 
> 
> #if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0)) && !CFG80211_STA_EVENT_AVAILABLE
> 	body=kzalloc(len, GFP_KERNEL);
> 	WL_DBG(("Enter \n"));
> 	if(body==NULL) {
> 		WL_ERR(("wl_notify_connect_status: Failed to allocate body\n"));
> 		return WL_INVALID;
> 	}
4741d5566
< 	memset(body, 0, sizeof(body));
4744c5569,5570
< 	if (wl_get_mode_by_netdev(wl, ndev) == WL_INVALID)
---
> 	if (wl_get_mode_by_netdev(wl, ndev) == WL_INVALID) {
> 		kfree(body);
4745a5572
> 	}
4747d5573
< 	if (wl_get_mode_by_netdev(wl, ndev) == WL_MODE_AP) {
4773c5599,5600
< 		if ((err = wldev_ioctl(ndev, WLC_GET_CHANNEL, &ci, sizeof(ci), false)))
---
> 		if ((err = wldev_ioctl(ndev, WLC_GET_CHANNEL, &ci, sizeof(ci), false))) {
> 			kfree(body);
4774a5602
> 		}
4802a5631,5667
> exit:
> 	if (isfree)
> 		kfree(mgmt_frame);
> 	if (body)
> 		kfree(body);
> 	return err;
> #else /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0) && !CFG80211_STA_EVENT_AVAILABLE */
> 	sinfo.filled = 0;
> 	if (((event == WLC_E_ASSOC_IND) || (event == WLC_E_REASSOC_IND)) &&
> 		reason == DOT11_SC_SUCCESS) {
> 		sinfo.filled = STATION_INFO_ASSOC_REQ_IES;
> 		if (!data) {
> 			WL_ERR(("No IEs present in ASSOC/REASSOC_IND"));
> 			return -EINVAL;
> 		}
> 		sinfo.assoc_req_ies = data;
> 		sinfo.assoc_req_ies_len = len;
> 		cfg80211_new_sta(ndev, e->addr.octet, &sinfo, GFP_ATOMIC);
> 	} else if (event == WLC_E_DISASSOC_IND) {
> 		cfg80211_del_sta(ndev, e->addr.octet, GFP_ATOMIC);
> 	} else if ((event == WLC_E_DEAUTH_IND) || (event == WLC_E_DEAUTH)) {
> 		cfg80211_del_sta(ndev, e->addr.octet, GFP_ATOMIC);
> 	}
> #endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0) && !CFG80211_STA_EVENT_AVAILABLE */
> 	return err;
> }
> 
> static s32
> wl_notify_connect_status(struct wl_priv *wl, struct net_device *ndev,
> 	const wl_event_msg_t *e, void *data)
> {
> 	bool act;
> 	s32 err = 0;
> 	u32 event = ntoh32(e->event_type);
> 
> 	if (wl_get_mode_by_netdev(wl, ndev) == WL_MODE_AP) {
> 		wl_notify_connect_status_ap(wl, ndev, e, data);
4805a5671,5675
> //chanyun TBD from DHD 15 no p2p firmware exist should change to interface
> 		if (strstr(fw_path, "_p2p") == NULL && event == WLC_E_DEAUTH) {
> 			WL_DBG(("unexpected event WLC_E_DEAUTH\n"));
> 			return WL_INVALID;
> 		}
4829a5700,5711
> 					WL_SCAN2(("link down notify escan complete: %p(%d)\n",
> 						ndev, wl->escan_info.cur_sync_id));
> #ifndef CUSTOMER_HW_SAMSUNG
> #error inform bss will be done at notify function
> 					{
> 						u8 temp_id = wl->escan_info.cur_sync_id;
> 						wl->bss_list =
> 						(wl_scan_results_t *)
> 						wl->escan_info.escan_buf[(temp_id+1)%2];
> 						wl_inform_bss(wl);
> 					}
> #endif
4837a5720,5729
> 				WL_DBG(("con=%02x:%02x:%02x:%02x:%02x:%02x\n",
> 					curbssid[0], curbssid[1], curbssid[2],
> 					curbssid[3],curbssid[4], curbssid[5]));
> 				WL_DBG(("dis=%02x:%02x:%02x:%02x:%02x:%02x\n",
> 					((u8 *)&e->addr)[0], ((u8 *)&e->addr)[1],
> 					((u8 *)&e->addr)[2], ((u8 *)&e->addr)[3],
> 					((u8 *)&e->addr)[4], ((u8 *)&e->addr)[5]));
> #ifdef ESCAN_RESULT_PATCH
> 				if (memcmp(curbssid, &e->addr, ETHER_ADDR_LEN) == 0) {
> #endif /* ESCAN_RESULT_PATCH */
4843d5734
< 
4850a5742,5745
> #ifdef ESCAN_RESULT_PATCH
> 				} else
> 					WL_ERR(("BSSID of event is not the connected BSSID\n"));
> #endif /* ESCAN_RESULT_PATCH */
4852a5748,5753
> #ifdef ESCAN_RESULT_PATCH
> 				if ((memcmp(connect_req_bssid, broad_bssid, ETHER_ADDR_LEN) == 0) ||
> 					(memcmp(&e->addr, broad_bssid, ETHER_ADDR_LEN) == 0) ||
> 					(memcmp(&e->addr, connect_req_bssid, ETHER_ADDR_LEN) == 0))
> 					/* In case this event comes while associating another AP */
> #endif /* ESCAN_RESULT_PATCH */
4863a5765,5766
> 					WL_SCAN2((" send noti due to connect fail : %p(%d)\n",
> 						ndev, wl->escan_info.cur_sync_id));
4874,4876d5776
< exit:
< 	if (isfree)
< 		kfree(mgmt_frame);
4917a5818,5819
> 	WL_DBG(("assoc info: %d %d %d\n", assoc_info.req_len,
> 		assoc_info.resp_len, assoc_info.flags));
4973a5876
> #ifndef ROAM_CHANNEL_CACHE
4975c5878
< 
---
> #endif
4976a5880,5888
> #ifdef ROAM_CHANNEL_CACHE
> 		int n_channels;
> 
> 		n_channels = get_roam_channel_list(ch, join_params->params.chanspec_list,
> 			&join_params->ssid);
> 		join_params->params.chanspec_num = htod32(n_channels);
> 		*join_params_size += WL_ASSOC_PARAMS_FIXED_SIZE +
> 			join_params->params.chanspec_num * sizeof(chanspec_t);
> #else
4994c5906
< 			htodchanspec(join_params->params.chanspec_list[0]);
---
> 			wl_chspec_host_to_driver(join_params->params.chanspec_list[0]);
4998,5000c5910,5913
< 
< 		WL_DBG(("%s  join_params->params.chanspec_list[0]= %X\n",
< 			__FUNCTION__, join_params->params.chanspec_list[0]));
---
> #endif /* ROAM_CHANNEL_CACHE */
> 		WL_DBG(("join_params->params.chanspec_list[0]= %X, %d channels\n",
> 			join_params->params.chanspec_list[0],
> 			join_params->params.chanspec_num));
5120c6033,6049
< 	WL_DBG((" enter\n"));
---
> 	WL_DBG((" Enter\n"));
> #ifdef ESCAN_RESULT_PATCH
> 	if (memcmp(curbssid, broad_bssid, ETHER_ADDR_LEN) == 0 &&
> 		memcmp(broad_bssid, connect_req_bssid, ETHER_ADDR_LEN) != 0) {
> 		WL_DBG(("copy bssid\n"));
> 		memcpy(curbssid, connect_req_bssid, ETHER_ADDR_LEN);
> 	}
> 	if (wl_get_drv_status(wl, CONNECTED, ndev)) {
> 		if (memcmp(curbssid, connect_req_bssid, ETHER_ADDR_LEN) == 0) {
> 			WL_ERR((" Connected event of connected device, ignore it\n"));
> 			return err;
> 		}
> 	}
> 
> 
> //	WL_SCAN2(("Connect done bssid=" MACSTR "\n", MAC2STR(curbssid)));
> #if defined(BCM4334_CHIP)
5121a6051
> 		WL_SCAN2(("Abort scan : %p(%d)\n", ndev, wl->escan_info.cur_sync_id));
5123a6054,6060
> #endif
> #else
> 	if (wl->scan_request) {
> 		WL_SCAN2(("Abort scan : %p(%d)\n", ndev, wl->escan_info.cur_sync_id));
> 		wl_cfg80211_scan_abort(wl, ndev);
> 	}
> #endif /* ESCAN_RESULT_PATCH */
5127c6064,6068
< 			wl_get_assoc_ies(wl, ndev);
---
> 			err = wl_get_assoc_ies(wl, ndev);
> 			if (err) {
> 				WL_DBG(("no assoc ies\n"));
> 				err = 0;
> 			}
5143c6084,6085
< 			WL_INFO(("Report connect result - connection succeeded\n"));
---
> 			WL_SCAN2(("Report connect result - connection succeeded(%d)\n",
> 				conn_info->resp_ie_len));
5146a6089,6092
> #ifdef ESCAN_RESULT_PATCH
> 	else
> 		WL_DBG(("wl_bss_connect_done : do nothing\n"));
> #endif /* ESCAN_RESULT_PATCH */
5222d6167
< 		WL_DBG(("cfg80211_scan_done\n"));
5224a6170,6174
> 		spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
> 		WL_DBG(("cfg80211_scan_done\n"));
> 		WL_SCAN2(("Remove Scan Request %p, %d\n", ndev, wl->escan_info.cur_sync_id));
> 	} else {
> 		spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
5226d6175
< 	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
5270a6220,6240
> 
> #ifdef WL_CFG80211_GON_COLLISION
> static bool
> wl_is_gon_req_collision(struct wl_priv *wl, wl_action_frame_t *tx_act_frm,
> 	wifi_p2p_pub_act_frame_t *rx_act_frm)
> {
> 	if (tx_act_frm && wl_cfgp2p_is_pub_action(tx_act_frm->data, tx_act_frm->len)) {
> 		wifi_p2p_pub_act_frame_t *pact_frm;
> 
> 		pact_frm = (wifi_p2p_pub_act_frame_t *)tx_act_frm->data;
> 
> 		if (pact_frm->subtype == P2P_PAF_GON_REQ &&
> 			rx_act_frm->subtype == P2P_PAF_GON_REQ) {
> 			WL_ERR((" GO NEGO Request COLLISION !!! \n"));
> 			return true;
> 		}
> 	}
> 	return false;
> }
> #endif /* WL_CFG80211_GON_COLLISION */
> 
5342a6313,6388
> 
> 		if (act_frm) {
> #ifdef WL_CFG80211_GON_COLLISION
> 			if (act_frm->subtype == P2P_PAF_GON_REQ) {
> 				if (wl->afx_hdl->pending_tx_act_frm) {
> 					wl_action_frame_t *tx_act_frm =
> 						&wl->afx_hdl->pending_tx_act_frm->action_frame;
> 					if (wl_is_gon_req_collision(wl, tx_act_frm, act_frm)) {
> 						/* if sa(peer) addr is less than da(my) addr,
> 						 * my device will process peer's gon request and block to send my gon req.
> 						 *
> 						 * if not (sa addr > da addr),
> 						 * my device will process gon request and drop current gon req of peer.
> 						 */
> 						if (memcmp(e->addr.octet, da.octet, ETHER_ADDR_LEN) < 0) {
> 							/* block to send tx gon request */
> 							wl->block_gon_req_tx_count = BLOCK_GON_REQ_MAX_NUM;
> 							WL_ERR((" block to send gon req tx !!!\n"));
> 
> 							/* if we are scanning peer channel for sending af,
> 							 * do not scan more to block to send current gon req
> 							 */
> 							if (wl_get_drv_status_all(wl, SCANNING_PEER_CHANNEL)) {
> 								wl_clr_drv_status(wl, SCANNING_PEER_CHANNEL, ndev);
> 								complete(&wl->act_frm_scan);
> 							}
> 						} else {
> 							/* drop current gon request of peer to process gon request by my device */
> 							/* should reduce another af tx to keep 100ms for next gon process */
> 							WL_ERR((" drop to receive gon req rx !!! \n"));
> 							wl->block_gon_req_rx_count = BLOCK_GON_REQ_MAX_NUM;
> 						}
> 
> 					}
> 				}
> 				if (wl->block_gon_req_rx_count) {
> 					WL_ERR(("drop frame GON Req Rx : count (%d)\n",
> 						wl->block_gon_req_rx_count));
> 					wl->block_gon_req_rx_count--;
> 					goto exit;
> 				}
> 			} else if (act_frm->subtype == P2P_PAF_GON_CONF) {
> 				/* if go formation done, clear it */
> 				wl->block_gon_req_tx_count = 0;
> 				wl->block_gon_req_rx_count = 0;
> 			}
> #endif /* WL_CFG80211_GON_COLLISION */
> 
> #ifdef WL_CFG80211_SYNC_GON_TIME
> 			if (wl_get_drv_status_all(wl, WAITING_NEXT_ACT_FRM)) {
> 				if (wl->next_gon_af_subtype == act_frm->subtype) {
> 					WL_DBG(("We got a right next frame!(%d) time (%d)\n",
> 						act_frm->subtype,
> 						jiffies_to_msecs(jiffies - wl->saved_jiffies)));
> 					wl_clr_drv_status(wl, WAITING_NEXT_ACT_FRM, ndev);
> 
> 					if (wl_get_drv_status_all(wl, SENDING_ACT_FRM) &&
> 						(wl_get_p2p_status(wl, ACTION_TX_COMPLETED) ||
> 						wl_get_p2p_status(wl, ACTION_TX_NOACK))) {
> 						WL_DBG(("*** Wake UP ** abort actframe ** \n"));
> 						//wake_up_interruptible(&wl->send_af_done_event);
> 						/* if channel is not zero, "actfame" uses off channel scan.
> 						 *  So abort scan for off channel completion. */
> 						if (wl->af_sent_channel)
> 							wl_cfg80211_scan_abort(wl, dev);
> 					} else if (wl_get_drv_status_all(wl, WAITING_MORE_TIME_NEXT_ACT_FRM)) {
> 						WL_DBG(("*** Wake UP ** wait_next_af ** \n"));
> 						complete(&wl->wait_next_af);
> 					}
> 					//wake_up_interruptible(&wl->send_af_done_event);
> 					//msleep(5);
> 				}
> 			}
> #endif /* WL_CFG80211_SYNC_GON_TIME */
> 		}
> 
5352a6399,6401
> 		if (wl_get_mode_by_netdev(wl, ndev) == WL_INVALID)
> 			return WL_INVALID;
> 
5353a6403,6432
> 
> 		/* wpa supplicant use probe request event for restarting another GON Req.
> 		 * but it makes GON Req repetition.
> 		 * so if src addr of prb req is same as my target device,
> 		 * do not send probe request event during sending action frame.
> 		 */
> 		if (event == WLC_E_P2P_PROBREQ_MSG) {
> 			WL_DBG((" Event %s\n", (event == WLC_E_P2P_PROBREQ_MSG) ?
> 				"WLC_E_P2P_PROBREQ_MSG":"WLC_E_PROBREQ_MSG"));
> 
> 			if ((wl_get_drv_status_all(wl, SENDING_ACT_FRM)
> #ifdef WL_CFG80211_SYNC_GON_TIME
> 				|| wl_get_drv_status_all(wl, WAITING_MORE_TIME_NEXT_ACT_FRM)
> #endif /* WL_CFG80211_SYNC_GON_TIME */
> 				) &&
> 				!memcmp(wl->afx_hdl->tx_dst_addr.octet, e->addr.octet, ETHER_ADDR_LEN)) {
> #ifdef WL_CFG80211_USE_PRB_REQ_FOR_AF_TX
> 				if (wl->afx_hdl->pending_tx_act_frm &&
> 					wl_get_drv_status_all(wl, SCANNING_PEER_CHANNEL)) {
> 					s32 channel = CHSPEC_CHANNEL(hton16(rxframe->channel));
> 					WL_DBG(("PROBE REQUEST : Peer found, channel : %d\n", channel));
> 					wl->afx_hdl->peer_chan = channel;
> 					complete(&wl->act_frm_scan);
> 				}
> #endif /* WL_CFG80211_USE_PRB_REQ_FOR_AF_TX */
> 				/* do not send probe request event to upper layer */
> 				WL_DBG((" Do Not Send..... PROBE REQUEST Event !!!!!\n"));
> 				return 0;
> 			}
> 		}
5360a6440
> exit:
5363c6443
< exit:
---
> 
5458a6539,6568
> 	wl->conn_info = (void *)kzalloc(sizeof(*wl->conn_info), GFP_KERNEL);
> 	if (unlikely(!wl->conn_info)) {
> 		WL_ERR(("wl->conn_info  alloc failed\n"));
> 		goto init_priv_mem_out;
> 	}
> 	wl->ie = (void *)kzalloc(sizeof(*wl->ie), GFP_KERNEL);
> 	if (unlikely(!wl->ie)) {
> 		WL_ERR(("wl->ie  alloc failed\n"));
> 		goto init_priv_mem_out;
> 	}
> #ifdef CONFIG_DHD_USE_STATIC_BUF
> 	wl->escan_info.escan_buf[0] = dhd_os_prealloc(NULL, DHD_PREALLOC_WIPHY_ESCAN0, 0);
> 	bzero(wl->escan_info.escan_buf[0], ESCAN_BUF_SIZE);
> #else
> 	wl->escan_info.escan_buf[0] = (void *)kzalloc(ESCAN_BUF_SIZE, GFP_KERNEL);
> 	if (unlikely(!wl->escan_info.escan_buf[0])) {
> 		WL_ERR(("wl->escan_info.escan_buf[0]  alloc failed\n"));
> 		goto init_priv_mem_out;
> 	}
> #endif
> #ifdef CONFIG_DHD_USE_STATIC_BUF
> 	wl->escan_info.escan_buf[1] = dhd_os_prealloc(NULL, DHD_PREALLOC_WIPHY_ESCAN1, 0);
> 	bzero(wl->escan_info.escan_buf[1], ESCAN_BUF_SIZE);
> #else
> 	wl->escan_info.escan_buf[1] = (void *)kzalloc(ESCAN_BUF_SIZE, GFP_KERNEL);
> 	if (unlikely(!wl->escan_info.escan_buf[1])) {
> 		WL_ERR(("wl->escan_info.escan_buf[1]  alloc failed\n"));
> 		goto init_priv_mem_out;
> 	}
> #endif
5464a6575,6578
> #ifdef WL_CFG80211_SYNC_GON_TIME
> 		init_completion(&wl->wait_next_af);
> #endif /* WL_CFG80211_SYNC_GON_TIME */
> 
5494a6609,6618
> 	kfree(wl->conn_info);
> 	wl->conn_info = NULL;
> 	kfree(wl->ie);
> 	wl->ie = NULL;
> #ifndef CONFIG_DHD_USE_STATIC_BUF
> 	kfree(wl->escan_info.escan_buf[0]);
> 	kfree(wl->escan_info.escan_buf[1]);
> #endif
> 	wl->escan_info.escan_buf[0] = NULL;
> 	wl->escan_info.escan_buf[1] = NULL;
5556d6679
< 	wl_clr_drv_status(wl, SCANNING, ndev);
5561a6685
> 	wl_clr_drv_status(wl, SCANNING, ndev);
5761a6886
> 	int refcnt = 0;
5764c6889
< 	if (!wdev || dev == wl_to_prmry_ndev(wl))
---
> 	if (!wdev || !wl || dev == wl_to_prmry_ndev(wl))
5766a6892,6906
> 		case NETDEV_DOWN:
> 			while(work_pending(&wdev->cleanup_work)) {
> 				WL_ERR(("%s : [NETDEV_DOWN] work_pending (%d th)\n",
> 					__FUNCTION__, refcnt));
> 				set_current_state(TASK_INTERRUPTIBLE);
> 				schedule_timeout(10);
> 				set_current_state(TASK_RUNNING);
> 				if(refcnt++ > 30) {
> 					WL_ERR(("%s : [NETDEV_DOWN] over refcnt = %d\n",
> 						__FUNCTION__, refcnt));
> 					break;
> 				}
> 			}
> 			break;
> 
5768,5770c6908,6925
< 				/* after calling list_del_rcu(&wdev->list) */
< 				wl_dealloc_netinfo(wl, ndev);
< 				break;
---
> 			/* after calling list_del_rcu(&wdev->list) */
> 			wl_dealloc_netinfo(wl, ndev);
> 			break;
> 		case NETDEV_GOING_DOWN:
> 			/* At NETDEV_DOWN state, wdev_cleanup_work work will be called.
> 			*  In front of door, the function checks
> 			*  whether current scan is working or not.
> 			*  If the scanning is still working, wdev_cleanup_work call WARN_ON and
> 			*  make the scan done forcibly.
> 			*/
> 			if (wl_get_drv_status(wl, SCANNING, dev)) {
> 				WL_SCAN2(("Abort Scan and send result\n"));
> 				wl_cfg80211_scan_abort(wl, dev);
> 				if (wl->escan_on) {
> 					wl_notify_escan_complete(wl, dev, true);
> 				}
> 			}
> 			break;
5783a6939,6944
> 
> 	if (wl->escan_info.ndev != ndev)
> 	{
> 		WL_SCAN2(("ndev is different %p %p\n", wl->escan_info.ndev, ndev));
> 		return;
> 	}
5786a6948,6957
> 	if(likely(wl->scan_request)) {
> 		u8 temp_id = wl->escan_info.cur_sync_id;
> 		if (aborted)
> 			wl->bss_list =
> 				(wl_scan_results_t *)wl->escan_info.escan_buf[(temp_id+1)%2];
> 		else
> 			wl->bss_list =
> 				(wl_scan_results_t *)wl->escan_info.escan_buf[(temp_id)%2];
> 		wl_inform_bss(wl);
> 	}
5791a6963
> 		spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
5793c6965,6969
< 	spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
---
> 	else {
> 		spin_unlock_irqrestore(&wl->cfgdrv_lock, flags);
> 		WL_SCAN2(("no scan request is existed\n"));
> 	}
> 	WL_DBG(("Exit \n"));
5808a6985
> 	u8 *ptr;
5810c6987
< 	WL_DBG((" enter event type : %d, status : %d\n",
---
> 	WL_DBG((" enter event type : %d, status : %d \n",
5817c6994
< 		ndev = wl->escan_info.ndev;
---
> 			ndev = wl->escan_info.ndev;
5822,5823c6999,7002
< 		WL_ERR(("escan is not ready ndev %p wl->escan_on %d drv_status 0x%x\n",
< 			ndev, wl->escan_on, wl_get_drv_status(wl, SCANNING, ndev)));
---
> 		WL_ERR(("escan is not ready ndev %p wl->escan_on %d"
> 			" drv_status 0x%x e_type %d e_states %d\n",
> 			ndev, wl->escan_on, wl_get_drv_status(wl, SCANNING, ndev),
> 			ntoh32(e->event_type), ntoh32(e->status)));
5826a7006
> 	escan_result = (wl_escan_result_t *) data;
5829d7008
< 		escan_result = (wl_escan_result_t *) data;
5848a7028,7033
> 		if (escan_result->sync_id != wl->escan_info.cur_sync_id) {
> 			WL_ERR(("Escan sync id mismatch: status %d cur_sync_id %d coming_sync_id %d\n"
> 			, status, wl->escan_info.cur_sync_id, escan_result->sync_id));
> 			goto exit;
> 		}
> 
5856,5858c7041,7044
< 		if (wl_get_drv_status_all(wl, SENDING_ACT_FRM)) {
< 			p2p_dev_addr = wl_cfgp2p_retreive_p2p_dev_addr(bi,
< 								bi_length);
---
> 		ptr = (u8 *) bi;
> 		ptr += dtoh16(bi->ie_offset);
> 		if (wl_get_drv_status_all(wl, SCANNING_PEER_CHANNEL)) {
> 			p2p_dev_addr = wl_cfgp2p_retreive_p2p_dev_addr(bi, bi_length);
5860,5862c7046,7048
< 				wl->afx_hdl->pending_tx_dst_addr.octet,
< 							ETHER_ADDR_LEN)) {
< 				s32 channel = CHSPEC_CHANNEL(dtohchanspec(bi->chanspec));
---
> 				wl->afx_hdl->tx_dst_addr.octet, ETHER_ADDR_LEN)) {
> 				s32 channel = CHSPEC_CHANNEL(
> 					wl_chspec_driver_to_host(bi->chanspec));
5871c7057
< 		list = (wl_scan_results_t *)wl->escan_info.escan_buf;
---
> 			list = (wl_scan_results_t *)wl->escan_info.escan_buf[wl->escan_info.cur_sync_id%2];
5903c7089
< 		memcpy(&(wl->escan_info.escan_buf[list->buflen]), bi, bi_length);
---
> 		memcpy(&(wl->escan_info.escan_buf[wl->escan_info.cur_sync_id%2][list->buflen]), bi, bi_length);
5913c7099,7102
< 		if (wl_get_drv_status_all(wl, SENDING_ACT_FRM)) {
---
> 		if (escan_result->sync_id != wl->escan_info.cur_sync_id)
> 			WL_ERR(("Escan sync id mismatch: status %d cur_sync_id %d coming_sync_id %d\n"
> 			, status, wl->escan_info.cur_sync_id, escan_result->sync_id));
> 		if (wl_get_drv_status_all(wl, SCANNING_PEER_CHANNEL)) {
5922,5923c7111,7114
< 			WL_INFO(("ESCAN COMPLETED\n"));
< 			wl->bss_list = (wl_scan_results_t *)wl->escan_info.escan_buf;
---
> 			WL_SCAN2(("ESCAN COMPLETED\n"));
> #ifndef CUSTOMER_HW_SAMSUNG
> #error bss list is informed at notify function
> 			wl->bss_list = (wl_scan_results_t *)wl->escan_info.escan_buf[wl->escan_info.cur_sync_id%2];
5924a7116
> #endif
5927a7120
> 		wl->escan_info.cur_sync_id++;
5931c7124,7127
< 		if (wl_get_drv_status_all(wl, SENDING_ACT_FRM)) {
---
> 		if (escan_result->sync_id!=wl->escan_info.cur_sync_id)
> 			WL_ERR(("Escan sync id mismatch: status %d cur_sync_id %d coming_sync_id %d\n"
> 			, status, wl->escan_info.cur_sync_id, escan_result->sync_id));
> 		if (wl_get_drv_status_all(wl, SCANNING_PEER_CHANNEL)) {
5940,5941c7136,7139
< 			WL_INFO(("ESCAN ABORTED\n"));
< 			wl->bss_list = (wl_scan_results_t *)wl->escan_info.escan_buf;
---
> 			WL_SCAN2(("ESCAN ABORTED\n"));
> #ifndef CUSTOMER_HW_SAMSUNG
> #error bss list is informed at notify function
> 			wl->bss_list = (wl_scan_results_t *)wl->escan_info.escan_buf[(wl->escan_info.cur_sync_id+1)%2];
5942a7141
> #endif
5945a7145
> 		wl->escan_info.cur_sync_id += 2;
5950c7150,7153
< 		if (wl_get_drv_status_all(wl, SENDING_ACT_FRM)) {
---
> 		if (escan_result->sync_id!=wl->escan_info.cur_sync_id)
> 			WL_ERR(("Escan sync id mismatch: status %d cur_sync_id %d coming_sync_id %d\n"
> 			, status, wl->escan_info.cur_sync_id, escan_result->sync_id));
> 		if (wl_get_drv_status_all(wl, SCANNING_PEER_CHANNEL)) {
5959c7162,7164
< 			wl->bss_list = (wl_scan_results_t *)wl->escan_info.escan_buf;
---
> #ifndef CUSTOMER_HW_SAMSUNG
> #error bss list is informed at notify function
> 			wl->bss_list = (wl_scan_results_t *)wl->escan_info.escan_buf[(wl->escan_info.cur_sync_id+1)%2];
5960a7166
> #endif
5963a7170
> 		wl->escan_info.cur_sync_id += 2;
5992a7200
> 		wl->escan_info.cur_sync_id = 0;
6015a7224,7225
> 	wl->first_remain = true;
> 	wl->wlfc_on = false;
6018a7229
> 	init_waitqueue_head(&wl->send_af_done_event);
6099a7311
> #if !ENABLE_P2P_INTERFACE
6102a7315
> #endif
6143,6145d7355
< 	wdev = wl_alloc_wdev(dev);
< 	if (IS_ERR(wdev))
< 		return -ENOMEM;
6146a7357,7366
> 	wdev = kzalloc(sizeof(*wdev), GFP_KERNEL);
> 	if (unlikely(!wdev)) {
> 		WL_ERR(("Could not allocate wireless device\n"));
> 		return -ENOMEM;
> 	}
> 	err = wl_setup_wiphy(wdev, dev);
> 	if (unlikely(err)) {
> 		kfree(wdev);
> 		return -ENOMEM;
> 	}
6274a7495
> 	int ret;
6276a7498
> 	DAEMONIZE("dhd_cfg80211_event");
6279c7501,7502
< 	while (down_interruptible (&tsk->sema) == 0) {
---
> 	while ((ret = down_interruptible (&tsk->sema)) == 0) {
> 		WL_DBG(("down the event sema\n"));
6281c7504,7506
< 		if (tsk->terminated)
---
> 		if (tsk->terminated) {
> 			WL_DBG(("%s was terminated[%d] ret=%d\n",
> 				__func__, __LINE__, ret));
6282a7508
> 		}
6296a7523
> 				WL_DBG(("call event handler\n"));
6298a7526
> 
6305c7533
< 	WL_DBG(("%s was terminated\n", __func__));
---
> 	WL_ERR(("%s was terminated[%d] ret=%d\n", __func__, __LINE__, ret));
6323c7551,7553
< 		WL_ERR((" PNO Event\n"));
---
> 		WL_ERR((" PNOEVENT: PNO_NET_FOUND\n"));
> 	else if (event_type == WLC_E_PFN_NET_LOST)
> 		WL_ERR((" PNOEVENT: PNO_NET_LOST\n"));
6397a7628
> 	WL_DBG(("enque the event to event queue\n"));
6488,6493c7719,7725
< 	s8 phylist_buf[128];
< 	s8 *phy;
< 	s32 err = 0;
< 
< 	err = wldev_ioctl(wl_to_prmry_ndev(wl), WLC_GET_PHYLIST, phylist_buf,
< 		sizeof(phylist_buf), false);
---
> 	u32 bandlist[3];
> 	u32 nband = 0;
> 	u32 i = 0;
> 	s32 err = 0;
> 	memset(bandlist, 0, sizeof(bandlist));
> 	err = wldev_ioctl(wl_to_prmry_ndev(wl), WLC_GET_BANDLIST, bandlist,
> 		sizeof(bandlist), false);
6498,6501c7730,7735
< 	phy = phylist_buf;
< 	for (; *phy; phy++) {
< 		if (*phy == 'a' || *phy == 'n') {
< 			wiphy = wl_to_wiphy(wl);
---
> 	wiphy = wl_to_wiphy(wl);
> 	nband = bandlist[0];
> 	wiphy->bands[IEEE80211_BAND_5GHZ] = NULL;
> 	wiphy->bands[IEEE80211_BAND_2GHZ] = NULL;
> 	for (i = 1; i <= nband && i < ARRAYSIZE(bandlist); i++) {
> 		if (bandlist[i] == WLC_BAND_5G)
6504c7738,7740
< 		}
---
> 		else if (bandlist[i] == WLC_BAND_2G)
> 			wiphy->bands[IEEE80211_BAND_2GHZ] =
> 				&__wl_band_2ghz;
6505a7742
> 	wiphy_apply_custom_regulatory(wiphy, &brcm_regdom);
6551,6555c7788
< 	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
< 	if (wl->scan_request) {
< 		cfg80211_scan_done(wl->scan_request, true);
< 		wl->scan_request = NULL;
< 	}
---
> 
6565a7799,7803
> 	spin_lock_irqsave(&wl->cfgdrv_lock, flags);
> 	if (wl->scan_request) {
> 		cfg80211_scan_done(wl->scan_request, true);
> 		wl->scan_request = NULL;
> 	}
6583a7822,7823
> 	int val = 1;
> 	dhd_pub_t *dhd;
6587a7828,7842
> 
> 	if ((err = wldev_ioctl(wl_to_prmry_ndev(wl), WLC_GET_VERSION, &val,
> 		sizeof(int), false) < 0)) {
> 		WL_ERR(("WLC_GET_VERSION failed, err=%d\n", err));
> 		return err;
> 	}
> 	val = dtoh32(val);
> 	if (val != WLC_IOCTL_VERSION && val != 1) {
> 		WL_ERR(("Version mismatch, please upgrade. Got %d, expected %d or 1\n",
> 			val, WLC_IOCTL_VERSION));
> 		return BCME_VERSION;
> 	}
> 	ioctl_version = val;
> 	WL_TRACE(("WLC_GET_VERSION=%d\n", ioctl_version));
> 
6589c7844,7847
< 	wl_cfg80211_attach_post(wl_to_prmry_ndev(wl));
---
> 	dhd = (dhd_pub_t *)(wl->pub);
> 	if ((dhd->op_mode & HOSTAPD_MASK) != HOSTAPD_MASK) {
> 		wl_cfg80211_attach_post(wl_to_prmry_ndev(wl));
> 	}
6695d7952
< 		WL_ERR(("unsupported item (%d)\n", item));
6699a7957,7960
> 
> 	if (err == EOPNOTSUPP)
> 		WL_ERR(("unsupported item (%d)\n", item));
> 
6835,6836c8096,8097
< 	get_primary_mac(wl, &primary_mac);
< 	wl_cfgp2p_generate_bss_mac(&primary_mac, p2pdev_addr, &p2pif_addr);
---
> 		get_primary_mac(wl, &primary_mac);
> 		wl_cfgp2p_generate_bss_mac(&primary_mac, p2pdev_addr, &p2pif_addr);
6979a8241,8257
> }
> int wl_cfg80211_do_driver_init(struct net_device *net)
> {
> 	struct wl_priv *wl = *(struct wl_priv **)netdev_priv(net);
> 
> 	if (!wl || !wl->wdev)
> 		return -EINVAL;
> 
> 	if (dhd_do_driver_init(wl->wdev->netdev) < 0)
> 		return -1;
> 
> 	return 0;
> }
> 
> void wl_cfg80211_enable_trace(int level)
> {
> 	wl_dbg_level |= WL_DBG_DBG;
diff -r update5/drivers/net/wireless/bcmdhd/src/wl/sys/wl_cfg80211.h update6/drivers/net/wireless/bcmdhd/src/wl/sys/wl_cfg80211.h
54a55
> #define WL_DBG_SCAN2 (1 <<5)
113a115,126
> #if (WL_DBG_LEVEL > 0)
> #define	WL_SCAN2(args)								\
> do {									\
> 	if (wl_dbg_level & WL_DBG_SCAN2) {			\
> 		printk(KERN_ERR "CFG80211-SCAN) %s :", __func__);	\
> 		printk args;							\
> 	}									\
> } while (0)
> #else				/* !(WL_DBG_LEVEL > 0) */
> #define	WL_DBG(args)
> #endif				/* (WL_DBG_LEVEL > 0) */
> 
116,117c129,130
< #define WL_SCAN_BUF_MAX			(1024 * 8)
< #define WL_TLV_INFO_MAX			1024
---
> #define WL_SCAN_BUF_MAX		(1024 * 8)
> #define WL_TLV_INFO_MAX 	1500 /* customer want to large size IE, so increase ie length */
119c132
< #define WL_BSS_INFO_MAX			2048
---
> #define WL_BSS_INFO_MAX		2048
127c140
< #define WL_FILE_NAME_MAX		256
---
> #define WL_FILE_NAME_MAX	256
147c160,176
< 	WL_STATUS_SENDING_ACT_FRM
---
> 	WL_STATUS_SENDING_ACT_FRM,	/* includes scanning peer chan and sending af via "actframe" */
> 	WL_STATUS_SCANNING_PEER_CHANNEL, /* scanning peer chan for searching peer's channel */
> 	WL_STATUS_REMAINING_ON_CHANNEL,
> #ifdef WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
> 	/* it will be set when upper layer requests listen but scan is running.
> 	 * it's fake listen state to keep current scan process.
> 	 * if set, other scan request will not abort scan. */
> 	WL_STATUS_FAKE_REMAINING_ON_CHANNEL,
> #endif /* WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST */
> #ifdef WL_CFG80211_SYNC_GON_TIME
> 	/* waiting for next af to sync time of supplicant.
> 	 * it includes SENDING_ACT_FRM and WAITING_MORE_TIME_NEXT_ACT_FRM
> 	 */
> 	WL_STATUS_WAITING_NEXT_ACT_FRM,
> 	/* go to listen state to wait for next af after SENDING_ACT_FRM */
> 	WL_STATUS_WAITING_MORE_TIME_NEXT_ACT_FRM
> #endif /* WL_CFG80211_SYNC_GON_TIME */
331,333c360,363
<     u32 escan_state;
<     u8 escan_buf[ESCAN_BUF_SIZE];
<     struct wiphy *wiphy;
---
> 	u32 escan_state;
> 	u8 *escan_buf[2];
> 	u8 cur_sync_id;
> 	struct wiphy *wiphy;
372c402
< 	struct ether_addr	pending_tx_dst_addr;
---
> 	struct ether_addr	tx_dst_addr;
377a408,410
> 	s32 peer_listen_chan;	/* configured by upper layer */
> 	s32 my_listen_chan;	/* my listen channel in GON Req frame */
> 	bool is_listen;
395a429,431
> #ifdef WL_CFG80211_SYNC_GON_TIME
> 	struct completion wait_next_af;
> #endif /* WL_CFG80211_SYNC_GON_TIME */
403c439
< 	struct wl_ie ie;
---
> 	struct wl_ie *ie;
407c443
< 	struct wl_connect_info conn_info;
---
> 	struct wl_connect_info *conn_info;
413a450,457
> #ifdef WL_CFG80211_SYNC_GON_TIME
> 	u32 af_sent_channel;	/* channel action frame is sent */
> 	/* save the next gon af subtype when it needs to wait more time for next gon af
> 	 * default value is 0xff (-1)
> 	 */
> 	u8 next_gon_af_subtype;
> 	ulong saved_jiffies;	/* the time to send af via "actframe" iovar */
> #endif /* WL_CFG80211_SYNC_GON_TIME */
425a470
> 	bool wlfc_on;
437a483
> 	wait_queue_head_t send_af_done_event;
444a491,495
> 	bool first_remain;
> #ifdef WL_CFG80211_GON_COLLISION
> 	u8 block_gon_req_tx_count;
> 	u8 block_gon_req_rx_count;
> #endif /* WL_CFG80211_GON_COLLISION */
517a569,615
> wl_set_status_all(struct wl_priv *wl, s32 status, u32 op)
> {
> 	struct net_info *_net_info, *next;
> 	list_for_each_entry_safe(_net_info, next, &wl->net_list, list) {
> 		switch (op) {
> 			case 1:
> 				return; /* set all status is not allowed */
> 			case 2:
> 				clear_bit(status, &_net_info->sme_state);
> 				break;
> 			case 4:
> 				return; /* change all status is not allowed */
> 			default:
> 				return; /*unknown operation */
> 			}
> 		}
> }
> #define wl_set_status_by_netdev(wl, status, _ndev, op) \
> { \
> 	struct net_info *_net_info, *next;\
> 	int found = 0;\
> 	list_for_each_entry_safe(_net_info, next, &(wl)->net_list, list) {\
> 		if(_ndev && ((_net_info->ndev) == _ndev)) {\
> 			found = 1;\
> 			switch(op){\
> 				case 1:\
> 					set_bit(status, &(_net_info->sme_state));\
> 					if(status == WL_STATUS_SCANNING)\
> 						WL_SCAN2(("<<<Set SCANNING bit %p>>>\n", _ndev));\
> 					break;\
> 				case 2:\
> 					 clear_bit(status, &(_net_info->sme_state));\
> 					if(status == WL_STATUS_SCANNING)\
> 						WL_SCAN2(("<<<Clear SCANNING bit %p>>>\n", _ndev));\
> 					break;\
> 				case 4:\
> 					 change_bit(status, &(_net_info->sme_state));\
> 					break;\
> 			}\
> 		}\
> 	}\
> 	if(found == 0)\
> 		WL_ERR(("<<<Set Status command with not eixst device %p>>>\n", _ndev));\
> }
> 
> #if 0
> static inline void
522a621
> 	int found = 0;
525a625
> 			found = 1;
528a629,632
> #if (WL_DBG_LEVEL > 0)
> 					if(status == WL_STATUS_SCANNING )
> 						WL_SCAN2(("<<<Set SCANNING bit %p >>>\n", ndev));
> #endif
532c636,640
< 				break;
---
> #if (WL_DBG_LEVEL > 0)
> 					if(status == WL_STATUS_SCANNING )
> 						WL_SCAN2(("<<<Clear SCANNING bit %p >>>\n", ndev));
> #endif
> 					break;
539c647,649
< 			}
---
> 	}
> 	if(found ==0 )
> 		WL_ERR(("<<Set Status command with not exist device %p>>\n", ndev));
542c652
< 
---
> #endif
595c705
< #define wl_to_ie(w) (&w->ie)
---
> #define wl_to_ie(w) (w->ie)
598c708
< #define wl_to_conn(w) (&w->conn_info)
---
> #define wl_to_conn(w) (w->conn_info)
607a718,719
> #define wl_clr_drv_status_all(wl, stat) \
> 	(wl_set_status_all(wl, WL_STATUS_ ## stat, 2))
636c748,749
< extern s32 wl_cfg80211_notify_ifadd(struct net_device *net, s32 idx, s32 bssidx, void* _net_attach);
---
> extern s32 wl_cfg80211_notify_ifadd(struct net_device *ndev, s32 idx, s32 bssidx,
> 	void* _net_attach);
651a765,766
> int wl_cfg80211_do_driver_init(struct net_device *net);
> void wl_cfg80211_enable_trace(int level);
diff -r update5/drivers/net/wireless/bcmdhd/src/wl/sys/wl_cfgp2p.c update6/drivers/net/wireless/bcmdhd/src/wl/sys/wl_cfgp2p.c
4c4
<  * Copyright (C) 1999-2011, Broadcom Corporation
---
>  * Copyright (C) 1999-2012, Broadcom Corporation
24c24
<  * $Id: wl_cfgp2p.c 307885 2012-01-12 23:30:48Z $
---
>  * $Id: wl_cfgp2p.c 308397 2012-01-15 07:32:58Z $
37a38
> #include <linux/random.h>
290a292
> 		wl->p2p = NULL;
308c310,314
< 		wldev_ioctl(ndev, WLC_DOWN, &val, sizeof(s32), true);
---
> 		ret = wldev_ioctl(ndev, WLC_DOWN, &val, sizeof(s32), true);
> 		if (ret < 0) {
> 			CFGP2P_ERR(("WLC_DOWN error %d\n", ret));
> 			return ret;
> 		}
310c316,320
< 		wldev_ioctl(ndev, WLC_UP, &val, sizeof(s32), true);
---
> 		ret = wldev_ioctl(ndev, WLC_UP, &val, sizeof(s32), true);
> 		if (ret < 0) {
> 			CFGP2P_ERR(("WLC_UP error %d\n", ret));
> 			return ret;
> 		}
339a350
> 	u32 scb_timeout=10;
353a365,373
> 
> 	if (unlikely(err < 0))
> 		printk("'wl p2p_ifadd' error %d\n", err);
> 	else if (if_type == WL_P2P_IF_GO) {
> 		err = wldev_ioctl(ndev, WLC_SET_SCB_TIMEOUT, &scb_timeout, sizeof(u32), true);
> 		if (unlikely(err < 0))
> 			printk("'wl scb_timeout' error %d\n", err);
> 	}
> 
389a410
> 	u32 scb_timeout=10;
396c417,418
< 	CFGP2P_INFO(("---wl p2p_ifchange %02x:%02x:%02x:%02x:%02x:%02x %s %u\n",
---
> 	CFGP2P_INFO(("---wl p2p_ifchange %02x:%02x:%02x:%02x:%02x:%02x %s %u"
> 		" chanspec 0x%04x\n",
400c422,423
< 		(chspec & WL_CHANSPEC_CHAN_MASK) >> WL_CHANSPEC_CHAN_SHIFT));
---
> 		(chspec & WL_CHANSPEC_CHAN_MASK) >> WL_CHANSPEC_CHAN_SHIFT,
> 		ifreq.chspec));
406a430,433
> 	} else if (if_type == WL_P2P_IF_GO) {
> 		err = wldev_ioctl(netdev, WLC_SET_SCB_TIMEOUT, &scb_timeout, sizeof(u32), true);
> 		if (unlikely(err < 0))
> 			printk("'wl scb_timeout' error %d\n", err);
694c721,724
< #define P2PAPI_SCAN_HOME_TIME_MS 10
---
> #define P2PAPI_SCAN_HOME_TIME_MS 60
> #define P2PAPI_SCAN_NPROBS_TIME_MS 25
> #define P2PAPI_SCAN_AF_SEARCH_DWELL_TIME_MS (P2PAPI_SCAN_NPROBS_TIME_MS + 5)
> 
696c726
< 	wl_set_p2p_status(wl, SCANNING);
---
> 	//wl_set_p2p_status(wl, SCANNING);
747d776
< 	eparams->params.nprobes = htod32(P2PAPI_SCAN_NPROBES);
751c780
< 	else if (num_chans == 3)
---
> 	else if (num_chans == SOCIAL_CHAN_CNT)
752a782,783
> 	else if (num_chans == AF_PEER_SEARCH_CNT)
> 		eparams->params.active_time = htod32(P2PAPI_SCAN_AF_SEARCH_DWELL_TIME_MS);
754a786,789
> 	eparams->params.nprobes = htod32((eparams->params.active_time /
> 		P2PAPI_SCAN_NPROBS_TIME_MS));
> 	CFGP2P_DBG(("nprobes # %d, active_time %d\n",
> 		eparams->params.nprobes, eparams->params.active_time));
764c799
< 	eparams->sync_id = htod16(0x1234);
---
> 	eparams->sync_id = wl->escan_info.cur_sync_id;
775a811,812
> 	if (ret == BCME_OK)
> 		wl_set_p2p_status(wl, SCANNING);
795c832
< 	CFGP2P_ERR((" Enter\n"));
---
> 	CFGP2P_DBG((" Enter\n"));
797a835
> 
799c837
< 		chan_cnt = 1;
---
> 		chan_cnt = AF_PEER_SEARCH_CNT;
801a840
> 
809c848,852
< 		default_chan_list[0] = channel;
---
> 		u32 i;
> 		/* insert same channel to the chan_list */
> 		for (i = 0; i < chan_cnt; i++) {
> 			default_chan_list[i] = channel;
> 		}
815c858
< 	ret = wl_cfgp2p_escan(wl, ndev, true, SOCIAL_CHAN_CNT,
---
> 	ret = wl_cfgp2p_escan(wl, ndev, true, chan_cnt,
835a879,883
> 
> #define SAMSUNG_OUI			"\x00\x00\xf0"
> #define SAMSUNG_OUI_LEN		3
> #define wl_cfgp2p_is_customer_ie(ie, tlvs, len) wl_cfgp2p_has_ie(ie, tlvs, len, \
> 	(const uint8 *)SAMSUNG_OUI, 3, 0)
961c1009,1010
< 					wl_cfgp2p_is_wfd_ie(&ie_buf[pos-2], NULL, 0))) {
---
> 					wl_cfgp2p_is_wfd_ie(&ie_buf[pos-2], NULL, 0) ||
> 					wl_cfgp2p_is_customer_ie(&ie_buf[pos-2], NULL, 0))) {
988c1037,1038
< 					wl_cfgp2p_is_wfd_ie(&ie_buf[pos-2], NULL, 0))) {
---
> 					wl_cfgp2p_is_wfd_ie(&ie_buf[pos-2], NULL, 0) ||
> 					wl_cfgp2p_is_customer_ie(&ie_buf[pos-2], NULL, 0))) {
1043a1094
> 		type != 0 &&
1047a1099,1105
> 	/* If the contents match the SAMSUNG OUI */
> 	if (ie[TLV_LEN_OFF] >= oui_len + 1 &&
> 	        !bcmp(&ie[TLV_BODY_OFF], oui, oui_len) &&
> 	        !bcmp(oui, SAMSUNG_OUI, SAMSUNG_OUI_LEN)) {
> 		return TRUE;
> 	}
> 
1086a1145,1158
> wl_cfgp2p_find_customer_ie(u8 *parse, u32 *len)
> {
> 	bcm_tlv_t *ie;
> 
> 	while ((ie = bcm_parse_tlvs(parse, *((int*)len), DOT11_MNG_VS_ID))) {
> 		if (wl_cfgp2p_has_ie((uint8 *) ie, &parse, len,
> 			(const uint8 *)SAMSUNG_OUI, WFA_OUI_LEN, 0)) {
> 			return (wifi_p2p_ie_t *)ie;
> 		}
> 	}
> 	return NULL;
> }
> 
> wifi_p2p_ie_t *
1105c1177
< 		if (wl_cfgp2p_is_wfd_ie((uint8 *)ie, &parse, &len))
---
> 		if (wl_cfgp2p_is_wfd_ie((uint8*)ie, &parse, &len)) {
1107a1180
> 	}
1208,1209c1281,1312
< 		cfg80211_remain_on_channel_expired(ndev, wl->last_roc_id, &wl->remain_on_chan,
< 		    wl->remain_on_chan_type, GFP_KERNEL);
---
> 
> 		if (wl->afx_hdl->is_listen == TRUE &&
> 			wl_get_drv_status_all(wl, SCANNING_PEER_CHANNEL)) {
> 			WL_DBG(("Listen DONE for action frame\n"));
> 			complete(&wl->act_frm_scan);
> 		}
> #ifdef WL_CFG80211_SYNC_GON_TIME
> 		else if (wl_get_drv_status_all(wl, WAITING_MORE_TIME_NEXT_ACT_FRM)) {
> 			wl_clr_drv_status(wl, WAITING_MORE_TIME_NEXT_ACT_FRM, ndev);
> 			WL_DBG(("Listen DONE and wake up wait_next_af !!(%d)\n",
> 				jiffies_to_msecs(jiffies - wl->saved_jiffies)));
> 
> 			if (wl_get_drv_status_all(wl, WAITING_NEXT_ACT_FRM))
> 				wl_clr_drv_status(wl, WAITING_NEXT_ACT_FRM, ndev);
> 
> 			complete(&wl->wait_next_af);
> 		}
> #endif /* WL_CFG80211_SYNC_GON_TIME */
> 
> 		if (wl_get_drv_status_all(wl, REMAINING_ON_CHANNEL)
> #ifdef WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
> 			|| wl_get_drv_status_all(wl, FAKE_REMAINING_ON_CHANNEL)
> #endif /* WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST */
> 			) {
> 			WL_DBG(("Listen DONE for ramain on channel expired\n"));
> 			wl_clr_drv_status(wl, REMAINING_ON_CHANNEL, ndev);
> #ifdef WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST
> 			wl_clr_drv_status(wl, FAKE_REMAINING_ON_CHANNEL, ndev);
> #endif /* WL_CFG80211_VSDB_PRIORITIZE_SCAN_REQUEST */
> 			cfg80211_remain_on_channel_expired(ndev, wl->last_roc_id,
> 				&wl->remain_on_chan, wl->remain_on_chan_type, GFP_KERNEL);
> 		}
1222c1325
< static void
---
> void
1247,1255c1350
< #define INIT_TIMER(timer, func, duration, extra_delay)	\
< 	do {                   \
< 		init_timer(timer); \
< 		timer->function = func; \
< 		timer->expires = jiffies + msecs_to_jiffies(duration + extra_delay); \
< 		timer->data = (unsigned long) wl; \
< 		add_timer(timer); \
< 	} while (0);
< 
---
> #define EXTRA_DEAY_TIME	100
1258c1353,1355
< 	CFGP2P_DBG((" Enter Channel : %d, Duration : %d\n", channel, duration_ms));
---
> 	s32 extra_delay;
> 
> 	CFGP2P_DBG((" Enter Listen Channel : %d, Duration : %d\n", channel, duration_ms));
1273c1370
< 	wl_cfgp2p_set_p2p_mode(wl, WL_P2P_DISC_ST_LISTEN, channel, (u16) duration_ms,
---
> 	ret = wl_cfgp2p_set_p2p_mode(wl, WL_P2P_DISC_ST_LISTEN, channel, (u16) duration_ms,
1280c1377,1383
< 	INIT_TIMER(_timer, wl_cfgp2p_listen_expired, duration_ms, 200);
---
> 	if (ret == BCME_OK) {
> 		extra_delay = EXTRA_DEAY_TIME + (duration_ms / 20);
> 	} else {
> 		/* if failed to set listen, it doesn't need to wait whole duration. */
> 		duration_ms = 50 + duration_ms / 20;
> 		extra_delay = 0;
> 	}
1282c1385,1387
< #undef INIT_TIMER
---
> 	INIT_TIMER(_timer, wl_cfgp2p_listen_expired, duration_ms, extra_delay);
> 
> #undef EXTRA_DEAY_TIME
1331a1437
> 			CFGP2P_DBG(("WLC_E_ACTION_FRAME_COMPLETE : ACK\n"));
1335c1441
< 			CFGP2P_ERR(("WLC_E_ACTION_FRAME_COMPLETE : NO ACK\n"));
---
> 			CFGP2P_DBG(("WLC_E_ACTION_FRAME_COMPLETE : NO ACK\n"));
1340c1446,1448
< 		wake_up_interruptible(&wl->netif_change_event);
---
> 
> 		if (wl_get_drv_status_all(wl, SENDING_ACT_FRM))
> 			wake_up_interruptible(&wl->send_af_done_event);
1369a1478,1482
> #ifdef WL_CFG80211_SYNC_GON_TIME
> 	wl->af_sent_channel  = af_params->channel;
> 	wl->saved_jiffies = jiffies;
> #endif /* WL_CFG80211_SYNC_GON_TIME */
> 
1378c1491,1492
< 	timeout = wait_event_interruptible_timeout(wl->netif_change_event,
---
> 
> 	timeout = wait_event_interruptible_timeout(wl->send_af_done_event,
1388a1503,1506
> 	/* clear status bit for action tx */
> 	wl_clr_p2p_status(wl, ACTION_TX_COMPLETED);
> 	wl_clr_p2p_status(wl, ACTION_TX_NOACK);
> 
1774,1776c1892
< 	p2p_ie = wl_cfgp2p_find_p2pie(((u8 *) bi) + bi->ie_offset,
< 							bi->ie_length);
< 	if (!(p2p_ie)) {
---
> 	if (!(p2p_ie = wl_cfgp2p_find_p2pie(((u8 *) bi) + bi->ie_offset, bi->ie_length))) {
1781,1782c1897
< 	capability = wl_cfgp2p_retreive_p2pattrib(p2p_ie, P2P_SEID_P2P_INFO);
< 	if (!(capability)) {
---
> 	if (!(capability = wl_cfgp2p_retreive_p2pattrib(p2p_ie, P2P_SEID_P2P_INFO))) {
1789c1904
< 	if (!p2p_go)
---
> 	if (!p2p_go) {
1790a1906
> 	}
1793,1794c1909
< 	ptr = wl_cfgp2p_retreive_p2pattrib(p2p_ie, P2P_SEID_DEV_INFO);
< 	if (!(ptr)) {
---
> 	if (!(ptr = wl_cfgp2p_retreive_p2pattrib(p2p_ie, P2P_SEID_DEV_INFO))) {
1802c1917
< 		WL_ERR(("Both DEVICE_ID&_INFO attribute not present in P2PIE"));
---
> 		WL_ERR((" Both DEVICE_ID & DEVICE_INFO attribute not present in P2P IE "));
1925d2039
< #if defined(OEM_ANROID)
1927,1929d2040
< #else
< 	(void)ndev;
< #endif
1942c2053,2068
< 	CFGP2P_DBG(("Do Nothing \n"));
---
> 	struct wireless_dev *wdev = net->ieee80211_ptr;
> 
> 	if (!wdev)
> 		return -EINVAL;
> 
> 	/* If suppose F/W download (ifconfig wlan0 up) hasn't been done by now,
> 	 * do it here. This will make sure that in concurrent mode, supplicant
> 	 * is not dependent on a particular order of interface initialization.
> 	 * i.e you may give wpa_supp -iwlan0 -N -ip2p0 or wpa_supp -ip2p0 -N
> 	 * -iwlan0.
> 	 */
> 	wl_cfg80211_do_driver_init(net);
> 
> 	wdev->wiphy->interface_modes |= (BIT(NL80211_IFTYPE_P2P_CLIENT)
> 		| BIT(NL80211_IFTYPE_P2P_GO));
> 
1948c2074,2081
< 	CFGP2P_DBG(("Do Nothing \n"));
---
> 	struct wireless_dev *wdev = net->ieee80211_ptr;
> 
> 	if (!wdev)
> 		return -EINVAL;
> 
> 	wdev->wiphy->interface_modes = (wdev->wiphy->interface_modes)
> 					& (~(BIT(NL80211_IFTYPE_P2P_CLIENT)|
> 					BIT(NL80211_IFTYPE_P2P_GO)));
diff -r update5/drivers/net/wireless/bcmdhd/src/wl/sys/wl_cfgp2p.h update6/drivers/net/wireless/bcmdhd/src/wl/sys/wl_cfgp2p.h
46a47
> #define P2P_RES_MAX_LEN 1400
50c51
< 	u8  p2p_probe_res_ie[IE_MAX_LEN];
---
> 	u8  p2p_probe_res_ie[P2P_RES_MAX_LEN];
143c144,153
< 
---
> #define INIT_TIMER(timer, func, duration, extra_delay)	\
> 	do {				   \
> 		init_timer(timer); \
> 		timer->function = func; \
> 		timer->expires = jiffies + msecs_to_jiffies(duration + extra_delay); \
> 		timer->data = (unsigned long) wl; \
> 		add_timer(timer); \
> 	} while (0);
> extern void
> wl_cfgp2p_listen_expired(unsigned long data);
193a204,206
> wl_cfgp2p_find_customer_ie(u8 *parse, u32 *len);
> 
> extern wifi_p2p_ie_t *
268a282
> #define AF_PEER_SEARCH_CNT (SOCIAL_CHAN_CNT + 1)
281a296,299
> #define IS_P2P_PUB_ACT_RSP_SUBTYPE(subtype) ((subtype == P2P_PAF_GON_RSP) || \
> 							((subtype == P2P_PAF_GON_CONF) || \
> 							(subtype == P2P_PAF_INVITE_RSP) || \
> 							(subtype == P2P_PAF_PROVDIS_RSP)))
diff -r update5/drivers/net/wireless/bcmdhd/src/wl/sys/wldev_common.c update6/drivers/net/wireless/bcmdhd/src/wl/sys/wldev_common.c
62,65c62
< 	if (arg != NULL) {
< 	//	WLDEV_ERROR(("iovar:%s ioc->len%d cmd->%d type->%s\n",
< 	//		(char *)arg, ioc.len, cmd, set ? "set": "get"));
< 	}
---
> 
226c223,226
< 	ret = wldev_ioctl(dev, WLC_SET_VAR, buf, iovar_len, TRUE);
---
> 	if (iovar_len > 0)
> 		ret = wldev_ioctl(dev, WLC_SET_VAR, buf, iovar_len, TRUE);
> 	else
> 		return BCME_BUFTOOSHORT;
diff -r update5/drivers/net/wireless/bcmdhd/src/wl/sys/wl_iw.c update6/drivers/net/wireless/bcmdhd/src/wl/sys/wl_iw.c
4c4
<  * Copyright (C) 1999-2011, Broadcom Corporation
---
>  * Copyright (C) 1999-2012, Broadcom Corporation
48a49,74
> #ifdef BCMWAPI_WPI
> 
> #ifndef IW_ENCODE_ALG_SM4
> #define IW_ENCODE_ALG_SM4 0x20
> #endif
> 
> #ifndef IW_AUTH_WAPI_ENABLED
> #define IW_AUTH_WAPI_ENABLED 0x20
> #endif
> 
> #ifndef IW_AUTH_WAPI_VERSION_1
> #define IW_AUTH_WAPI_VERSION_1	0x00000008
> #endif
> 
> #ifndef IW_AUTH_CIPHER_SMS4
> #define IW_AUTH_CIPHER_SMS4	0x00000020
> #endif
> 
> #ifndef IW_AUTH_KEY_MGMT_WAPI_PSK
> #define IW_AUTH_KEY_MGMT_WAPI_PSK 4
> #endif
> 
> #ifndef IW_AUTH_KEY_MGMT_WAPI_CERT
> #define IW_AUTH_KEY_MGMT_WAPI_CERT 8
> #endif
> #endif
125,126c151
< static int
< wl_iw_iscan(iscan_info_t *iscan, wlc_ssid_t *ssid, uint16 action);
---
> static int wl_iw_iscan(iscan_info_t *iscan, wlc_ssid_t *ssid, uint16 action);
128,129c153,160
< #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 29)
< #define IW_DEV_IF(dev)        ((wl_iw_t *)netdev_priv(dev))
---
> 
> typedef struct priv_link {
> 	wl_iw_t *wliw;
> } priv_link_t;
> 
> 
> #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24))
> #define WL_DEV_LINK(dev)       (priv_link_t*)(dev->priv)
131c162
< #define IW_DEV_IF(dev)        ((wl_iw_t *)dev->priv)
---
> #define WL_DEV_LINK(dev)       (priv_link_t*)netdev_priv(dev)
133a165,167
> 
> #define IW_DEV_IF(dev)          ((wl_iw_t*)(WL_DEV_LINK(dev))->wliw)
> 
1198c1232
< 	DHD_ERROR(("TIMER_TIMER: i scan timer set(%s)\n", __func__));
---
> 	DHD_ERROR(("TIMER_TIMER: i scan timer set(%s)\n", __FUNCTION__));
1248a1283,1311
> #ifdef BCMWAPI_WPI
> static inline int _wpa_snprintf_hex(char *buf, size_t buf_size, const u8 *data,
> 	size_t len, int uppercase)
> {
> 	size_t i;
> 	char *pos = buf, *end = buf + buf_size;
> 	int ret;
> 	if (buf_size == 0)
> 		return 0;
> 	for (i = 0; i < len; i++) {
> 		ret = snprintf(pos, end - pos, uppercase ? "%02X" : "%02x",
> 			data[i]);
> 		if (ret < 0 || ret >= end - pos) {
> 			end[-1] = '\0';
> 			return pos - buf;
> 		}
> 		pos += ret;
> 	}
> 	end[-1] = '\0';
> 	return pos - buf;
> }
> 
> 
> static int
> wpa_snprintf_hex(char *buf, size_t buf_size, const u8 *data, size_t len)
> {
> 	return _wpa_snprintf_hex(buf, buf_size, data, len, 0);
> }
> #endif
1256a1320,1323
> #ifdef BCMWAPI_WPI
> 	char *buf;
> 	int custom_event_len;
> #endif
1301a1369,1399
> #ifdef BCMWAPI_WPI
> 		ptr = ((uint8 *)bi) + sizeof(wl_bss_info_t);
> 		ptr_len = bi->ie_length;
> 
> 		while ((ie = bcm_parse_tlvs(ptr, ptr_len, DOT11_MNG_WAPI_ID))) {
> 			WL_TRACE(("%s: found a WAPI IE...\n", __FUNCTION__));
> #ifdef WAPI_IE_USE_GENIE
> 			iwe.cmd = IWEVGENIE;
> 			iwe.u.data.length = ie->len + 2;
> 			event = IWE_STREAM_ADD_POINT(info, event, end, &iwe, (char *)ie);
> #else
> 			iwe.cmd = IWEVCUSTOM;
> 			custom_event_len = strlen("wapi_ie=") + 2*(ie->len + 2);
> 			iwe.u.data.length = custom_event_len;
> 
> 			buf = kmalloc(custom_event_len+1, GFP_KERNEL);
> 			if (buf == NULL)
> 			{
> 				WL_ERROR(("malloc(%d) returned NULL...\n", custom_event_len));
> 				break;
> 			}
> 
> 			memcpy(buf, "wapi_ie=", 8);
> 			wpa_snprintf_hex(buf + 8, 2+1, &(ie->id), 1);
> 			wpa_snprintf_hex(buf + 10, 2+1, &(ie->len), 1);
> 			wpa_snprintf_hex(buf + 12, 2*ie->len+1, ie->data, ie->len);
> 			event = IWE_STREAM_ADD_POINT(info, event, end, &iwe, buf);
> #endif
> 			break;
> 		}
> #endif
2205a2304,2318
> #if defined(BCMWAPI_WPI)
> 	uchar buf[WLC_IOCTL_SMLEN] = {0};
> 	uchar *p = buf;
> 	int wapi_ie_size;
> 
> 	WL_TRACE(("%s: SIOCSIWGENIE\n", dev->name));
> 
> 	if (extra[0] == DOT11_MNG_WAPI_ID)
> 	{
> 		wapi_ie_size = iwp->length;
> 		memcpy(p, extra, iwp->length);
> 		dev_wlc_bufvar_set(dev, "wapiie", buf, wapi_ie_size);
> 	}
> 	else
> #endif
2346a2460,2467
> #ifdef BCMWAPI_WPI
> 			case IW_ENCODE_ALG_SM4:
> 				key.algo = CRYPTO_ALGO_SMS4;
> 				if (iwe->ext_flags & IW_ENCODE_EXT_GROUP_KEY) {
> 					key.flags &= ~WL_PRIMARY_KEY;
> 				}
> 				break;
> #endif
2495a2617,2620
> #ifdef BCMWAPI_WPI
> 		else if (paramval & IW_AUTH_WAPI_VERSION_1)
> 			val = WAPI_AUTH_UNSPECIFIED;
> #endif
2521a2647,2651
> #ifdef BCMWAPI_WPI
> 		val &= ~SMS4_ENABLED;
> 		if (cipher_combined & IW_AUTH_CIPHER_SMS4)
> 			val |= SMS4_ENABLED;
> #endif
2566a2697,2700
> #ifdef BCMWAPI_WPI
> 		if (paramval & (IW_AUTH_KEY_MGMT_WAPI_PSK | IW_AUTH_KEY_MGMT_WAPI_CERT))
> 			val = WAPI_AUTH_UNSPECIFIED;
> #endif
2648a2783,2805
> #ifdef BCMWAPI_WPI
> 
> 	case IW_AUTH_WAPI_ENABLED:
> 		if ((error = dev_wlc_intvar_get(dev, "wsec", &val)))
> 			return error;
> 		if (paramval) {
> 			val |= SMS4_ENABLED;
> 			if ((error = dev_wlc_intvar_set(dev, "wsec", val))) {
> 				WL_ERROR(("%s: setting wsec to 0x%0x returned error %d\n",
> 					__FUNCTION__, val, error));
> 				return error;
> 			}
> 			if ((error = dev_wlc_intvar_set(dev, "wpa_auth", WAPI_AUTH_UNSPECIFIED))) {
> 				WL_ERROR(("%s: setting wpa_auth(%d) returned %d\n",
> 					__FUNCTION__, WAPI_AUTH_UNSPECIFIED,
> 					error));
> 				return error;
> 			}
> 		}
> 
> 		break;
> 
> #endif
3320c3477
< 	DHD_ERROR(("TIMER_TIMER: iscan timer removed(%s)\n", __func__));
---
> 	DHD_ERROR(("TIMER_TIMER: iscan timer removed(%s)\n", __FUNCTION__));
3477,3478c3634
< 			DHD_ERROR(("TIMER_TIMER: iscan timer remove(%s)\n",
< 				__func__));
---
> 			DHD_ERROR(("TIMER_TIMER: iscan timer remove(%s)\n", __FUNCTION__));
3504,3505c3660
< 				DHD_ERROR(("TIMER_TIMER: iscan timer set(%s)\n",
< 					__func__));
---
> 				DHD_ERROR(("TIMER_TIMER: iscan timer set(%s)\n", __FUNCTION__));
3518,3519c3673
< 				DHD_ERROR(("TIMER_TIMER: iscan timer set(%s)\n",
< 					__func__));
---
> 				DHD_ERROR(("TIMER_TIMER: iscan timer set(%s)\n", __FUNCTION__));
diff -r update5/drivers/net/wireless/bcmdhd/src/wl/sys/wl_linux_mon.c update6/drivers/net/wireless/bcmdhd/src/wl/sys/wl_linux_mon.c
229a230
> 		PKTSETPRIO(skb, 0);
Nur in update6/drivers/net/wireless/bcmdhd/src/wl/sys: wl_roam.c.
diff -r update5/drivers/sensor/cm3663.c update6/drivers/sensor/cm3663.c
37,43d36
< #if defined(CONFIG_MACH_S2PLUS)
< #include <linux/regulator/machine.h>
< #include <linux/err.h>
< #include <linux/delay.h>
< #endif
< 
< #define LIGHT_BUFFER_NUM	5
64,66d56
< #if defined(CONFIG_MACH_S2PLUS)
< 	0x03, /* PS_THD: 3 */
< #else
68d57
< #endif
71,76d59
< static const int adc_table[4] = {
< 	15,
< 	150,
< 	1500,
< 	15000,
< };
106,107d88
< 	int light_count;
< 	int light_buffer;
176,177d156
< 	cm3663->light_count = 0;
< 	cm3663->light_buffer = 0;
518,524d496
< 
< 	for (i = 0; ARRAY_SIZE(adc_table); i++)
< 		if (als <= adc_table[i])
< 			break;
< 
< 	if (cm3663->light_buffer == i) {
< 		if (cm3663->light_count++ == LIGHT_BUFFER_NUM) {
526,527c498,499
< 			input_report_rel(cm3663->light_input_dev,
< 							REL_MISC, als + 1);
---
> 	input_report_rel(cm3663->light_input_dev,
> 					REL_MISC, als + 1);
529,530c501,502
< 			input_report_abs(cm3663->light_input_dev,
< 							ABS_MISC, als + 1);
---
> 	input_report_abs(cm3663->light_input_dev,
> 					ABS_MISC, als + 1);
532,538c504
< 			input_sync(cm3663->light_input_dev);
< 			cm3663->light_count = 0;
< 		}
< 	} else {
< 		cm3663->light_buffer = i;
< 		cm3663->light_count = 0;
< 	}
---
> 	input_sync(cm3663->light_input_dev);
937,956d902
< 
< 	/* [S2PLUS] Temporary Patch */
< #if defined(CONFIG_MACH_S2PLUS)
< 	struct regulator *regulator;
< 	int ret = 0;
< 
< 	regulator = regulator_get(NULL, "vcc_pls_2.8v");
< 	if (IS_ERR(regulator)) {
< 		printk(KERN_ERR
< 			"vcc_pls_2.8v regulator get err\n");
< 		return -1;
< 	}
< 	if (!regulator_is_enabled(regulator)) {
< 		printk(KERN_ERR "%s: vcc_pls_2.8v is off. so ON\n",
< 		__func__);
< 		ret = regulator_enable(regulator);
< 	}
< 	regulator_put(regulator);
< 	mdelay(100);
< #endif
diff -r update5/drivers/usb/host/shost/shost_driver.c update6/drivers/usb/host/shost/shost_driver.c
129c129
< 	pr_info("otg probe start : 0x%x\n", regs);
---
> 	pr_info("%s + regs=0x%x\n", __func__, regs);
130a131
> 	/* 1. hcd */
136a138,151
> 	g_pUsbHcd->self.otg_port = 1;
> 
> 	/* sec_otghost */
> 	otghost = hcd_to_sec_otghost(g_pUsbHcd);
> 	if (otghost == NULL) {
> 		otg_err(true, "failed to get otghost hcd\n");
> 		ret_val = USB_ERR_FAIL;
> 		goto err_out_create_hcd;
> 	}
> 	otghost->otg_data = otg_data;
> 
> 	/* 2. wake lock */
> 	wake_lock_init(&otghost->wake_lock, WAKE_LOCK_SUSPEND, "usb_otg");
> 	wake_lock(&otghost->wake_lock);
137a153
> 	/* base address */
148,157c164
< 	g_pUsbHcd->self.otg_port = 1;
< 
< 	otghost = hcd_to_sec_otghost(g_pUsbHcd);
< 	if (otghost == NULL) {
< 		otg_err(true, "failed to get otghost hcd\n");
< 		ret_val = USB_ERR_FAIL;
< 		goto err_out_create_hcd;
< 	}
< 	otghost->otg_data = otg_data;
< 
---
> 	/* 3. workqueue */
161c168
< 	/* call others' init() */
---
> 	/* 4. phy */
182a190
> 
189c197
< 	/*
---
> 	/* 5. hcd
209,211c217
< 
< 	wake_lock_init(&otghost->wake_lock, WAKE_LOCK_SUSPEND, "usb_otg");
< 	wake_lock(&otghost->wake_lock);
---
> 	pr_info("%s -\n", __func__);
231c237
< 	pr_info("+++++ OTG STOP\n");
---
> 	pr_info("%s +\n", __func__);
239,243c245
< 	destroy_workqueue(otghost->wq);
< 
< 	wake_unlock(&otghost->wake_lock);
< 	wake_lock_destroy(&otghost->wake_lock);
< 
---
> 	/* 5. hcd */
245d246
< 
252,254c253
< 
< 	usb_put_hcd(g_pUsbHcd);
< 
---
> 	/* 4. phy */
260a260,271
> 	/* 3. workqueue */
> 	destroy_workqueue(otghost->wq);
> 
> 	/* 2. wake lock */
> 	wake_unlock(&otghost->wake_lock);
> 	wake_lock_destroy(&otghost->wake_lock);
> 
> 	/* 1. hcd */
> 	usb_put_hcd(g_pUsbHcd);
> 
> 	pr_info("%s -\n", __func__);
> 
309c320
< static int s5pc110_otg_drv_remove(struct platform_device *dev)
---
> static int s5pc110_otg_drv_remove(struct platform_device *pdev)
diff -r update5/drivers/usb/host/shost/shost_hcd.c update6/drivers/usb/host/shost/shost_hcd.c
260a261
> 	usb_hcd_p->has_tt = 1;
382,386d382
< 	if (ped->ed_desc.sched_frame != (u8)(urb->start_frame)) {
< 		ped->ed_desc.sched_frame = (u8)urb->start_frame;
< 		update |= 1 << 5;
< 	}
< 
652,658d647
< 	/* Dequeue should be performed only if endpoint is enabled */
< 	if (_urb->ep->enabled == 0) {
< 		spin_unlock_irqrestore(&otghost->lock, spin_lock_flag);
< 		usb_hcd_giveback_urb(_hcd, _urb, status);
< 		return USB_ERR_SUCCESS;
< 	}
< 
671d659
< 		usb_hcd_giveback_urb(_hcd, _urb, status);
diff -r update5/drivers/usb/host/shost/shost_transfer.c update6/drivers/usb/host/shost/shost_transfer.c
158c158
< 		if (parent_ed->num_td == 0)
---
> 		if (parent_ed->num_td == 0) {
159a160,161
> 			parent_ed->is_need_to_insert_scheduler = true;
> 		}
Nur in update5/: GT-I9100_ICS_Opensource_Update5.zip.
Nur in update6/: GT-I9100_ICS_Opensource_Update6.zip.
Binärdateien update5/GT-I9100_Kernel.tar.gz and update6/GT-I9100_Kernel.tar.gz sind verschieden.
Binärdateien update5/GT-I9100_Platform.tar.gz and update6/GT-I9100_Platform.tar.gz sind verschieden.
diff -r update5/include/linux/mfd/mc1n2_pdata.h update6/include/linux/mfd/mc1n2_pdata.h
26c26
< 	void (*set_adc_power_contraints)(int disabled);
---
> 	int (*set_adc_power_constraints)(int disabled);
diff -r update5/sound/soc/codecs/mc1n2/mc1n2.c update6/sound/soc/codecs/mc1n2/mc1n2.c
3701a3702
> 	int err;
3713c3714,3718
< 		mc1n2->pdata->set_adc_power_contraints(0);
---
> 		err = mc1n2->pdata->set_adc_power_constraints(0);
> 		if (err < 0) {
> 			dev_err(codec->dev,
> 				"%s:%d:Error VADC_3.3V[On]\n", __func__, err);
> 		}
3717c3722,3726
< 		mc1n2->pdata->set_adc_power_contraints(1);
---
> 		err = mc1n2->pdata->set_adc_power_constraints(1);
> 		if (err < 0) {
> 			dev_err(codec->dev,
> 				"%s:%d:Error VADC_3.3V[Off]\n", __func__, err);
> 		}
